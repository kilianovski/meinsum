{"version":3,"file":"static/chunks/app/page-28c10aca24a23eea.js","mappings":"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","sources":["webpack://_N_E/?cac0","webpack://_N_E/./src/utils/basic.ts","webpack://_N_E/./src/utils/renderPhases.ts","webpack://_N_E/./src/utils/vector.ts","webpack://_N_E/./src/utils/data.ts","webpack://_N_E/./src/utils/math.ts","webpack://_N_E/./src/utils/shader.ts","webpack://_N_E/./src/llm/GptModel.ts","webpack://_N_E/./src/utils/matrix.ts","webpack://_N_E/./src/llm/render/sharedRender.ts","webpack://_N_E/./src/llm/render/fontRender.ts","webpack://_N_E/./src/utils/random.ts","webpack://_N_E/./src/utils/tensor.ts","webpack://_N_E/./src/utils/hooks.ts","webpack://_N_E/./src/utils/pointer.ts","webpack://_N_E/./src/llm/walkthrough/WalkthroughTools.ts","webpack://_N_E/./src/llm/PhaseTimeline.tsx","webpack://_N_E/./src/llm/GptModelLayout.ts","webpack://_N_E/./src/llm/render/lineRender.ts","webpack://_N_E/./src/llm/Camera.ts","webpack://_N_E/./src/llm/Annotations.ts","webpack://_N_E/./src/llm/render/threadRender.ts","webpack://_N_E/./src/llm/SavedState.ts","webpack://_N_E/./src/llm/render/triRender.ts","webpack://_N_E/./src/llm/components/TextLayout.ts","webpack://_N_E/./src/llm/components/ModelCard.ts","webpack://_N_E/./src/llm/components/DataFlow.ts","webpack://_N_E/./src/llm/Interaction.ts","webpack://_N_E/./src/llm/walkthrough/Walkthrough00_Intro.tsx","webpack://_N_E/./src/llm/walkthrough/Walkthrough01_Prelim.tsx","webpack://_N_E/./src/llm/walkthrough/Walkthrough02_Embedding.tsx","webpack://_N_E/./src/llm/walkthrough/Walkthrough03_LayerNorm.tsx","webpack://_N_E/./src/llm/components/CommentaryHelpers.tsx","webpack://_N_E/./src/llm/walkthrough/Walkthrough04_SelfAttention.tsx","webpack://_N_E/./src/llm/walkthrough/Walkthrough05_Softmax.tsx","webpack://_N_E/./src/llm/walkthrough/Walkthrough06_Projection.tsx","webpack://_N_E/./src/llm/walkthrough/Walkthrough07_Mlp.tsx","webpack://_N_E/./src/llm/walkthrough/Walkthrough08_Transformer.tsx","webpack://_N_E/./src/llm/walkthrough/Walkthrough09_Output.tsx","webpack://_N_E/./src/llm/walkthrough/Walkthrough.ts","webpack://_N_E/./src/llm/components/TocDiagram.tsx","webpack://_N_E/./src/llm/Commentary.tsx","webpack://_N_E/./src/llm/Sidebar.tsx","webpack://_N_E/./src/llm/EinsumLayout.ts","webpack://_N_E/./src/llm/render/blockRender.ts","webpack://_N_E/./src/llm/render/blurRender.ts","webpack://_N_E/./src/llm/render/queryManager.ts","webpack://_N_E/./src/llm/render/modelRender.ts","webpack://_N_E/./src/llm/components/BlockInfo.ts","webpack://_N_E/./src/llm/NativeBindings.ts","webpack://_N_E/./src/llm/GptModelWasm.ts","webpack://_N_E/./src/app/meinsum/OperandItem.tsx","webpack://_N_E/./src/app/meinsum/EinsumInputManager.tsx","webpack://_N_E/./src/llm/meinsum.js","webpack://_N_E/./src/app/meinsum/MeinsumStringification.ts","webpack://_N_E/./src/app/meinsum/EinsumDemoApp.tsx","webpack://_N_E/./src/llm/MyProgram.ts","webpack://_N_E/./src/llm/CanvasEventSurface.tsx","webpack://_N_E/./src/llm/components/MovementControls.tsx","webpack://_N_E/./src/utils/layout.ts","webpack://_N_E/./src/utils/keyboard.ts","webpack://_N_E/./src/utils/Resizer.tsx","webpack://_N_E/./src/llm/components/ModelSelectorToolbar.tsx","webpack://_N_E/./src/llm/MeinsumMenu.tsx","webpack://_N_E/./src/llm/MeinsumSidebar.tsx","webpack://_N_E/./src/llm/LayerView.tsx","webpack://_N_E/./src/llm/LayerView.module.scss","webpack://_N_E/./src/llm/Sidebar.module.scss","webpack://_N_E/<anon>"],"sourcesContent":["import(/* webpackMode: \"eager\" */ \"/Users/mykhailokilianovskyi/src/llm-viz/src/llm/LayerView.tsx\")","\nexport function nonNil<T>(value: T | null | undefined): value is T {\n  return value !== null && value !== undefined;\n}\n","import { IProgram } from \"./shader\";\n\nexport function logArr(name: string, arr: Float32Array, n = 15) {\n    console.log(name, [...arr.subarray(0, n)].map(a => parseFloat(a.toFixed(3))));\n}\n\nexport function arraysEqual(a: Float32Array, b: Float32Array) {\n    if (a.length !== b.length) return false;\n    for (let i = 0; i < a.length; i++) {\n        if (Math.abs(a[i] - b[i]) > 1e-4) return false;\n    }\n    return true;\n}\n\nexport function setProgramTexUniforms(gl: WebGL2RenderingContext, program: IProgram, names: string[]) {\n    gl.useProgram(program.program);\n    for (let i = 0; i < names.length; i++) {\n        let loc = gl.getUniformLocation(program.program, names[i]);\n        if (!loc) {\n            console.log('uniform not found:', names[i], '(may just be unused)');\n            continue;\n        }\n        gl.uniform1i(loc, i);\n    }\n}\n\nexport interface IBufferTex {\n    width: number;\n    height: number;\n    channels: number;\n    texture: WebGLTexture;\n    localBuffer?: Float32Array;\n}\n\n// we transform from 1 set of textures to another set within a shader\n// each buffer is a standard layer of the ML model\n// note that the dest buffers must all be the same size, but the src buffers can be different sizes\nexport interface IRenderPhase {\n    destBuffers: IBufferTex[];\n    srcBuffers: IBufferTex[];\n    fbo: WebGLFramebuffer;\n    program: IProgram;\n    uniformsSet: boolean;\n    uniformNames?: string[];\n}\n\nexport function createRenderPhase(gl: WebGL2RenderingContext, program: IProgram, dest: IBufferTex[], src: IBufferTex[], names?: string[]): IRenderPhase {\n    if (names) {\n        if (names.length !== src.length) {\n            throw new Error(`Number of texture names (${names.length}) does not match number of src textures (${src.length})`);\n        }\n    }\n\n    let fbo = gl.createFramebuffer()!;\n    gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);\n\n    for (let i = 0; i < dest.length; i++) {\n        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gl.TEXTURE_2D, dest[i].texture, 0);\n    }\n\n    gl.drawBuffers(dest.map((_, i) => gl.COLOR_ATTACHMENT0 + i));\n\n    let status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);\n    if (status !== gl.FRAMEBUFFER_COMPLETE) {\n        console.log(\"createRenderPhase: framebuffer not complete: \" + status);\n    }\n\n    return {\n        destBuffers: dest,\n        srcBuffers: src,\n        fbo,\n        program,\n        uniformNames: names,\n        uniformsSet: false,\n    };\n}\n\nexport let RenderPhaseStats = {\n    bindAndDrawCount: 0,\n};\n\nexport function runRenderPhase(gl: WebGL2RenderingContext, phase: IRenderPhase) {\n    gl.useProgram(phase.program.program);\n\n    if (!phase.uniformsSet) {\n        phase.uniformNames && setProgramTexUniforms(gl, phase.program, phase.uniformNames!);\n        phase.uniformsSet = true;\n    }\n\n    for (let i = 0; i < phase.srcBuffers.length; i++) {\n        gl.activeTexture(gl.TEXTURE0 + i);\n        gl.bindTexture(gl.TEXTURE_2D, phase.srcBuffers[i].texture);\n    }\n    gl.bindFramebuffer(gl.FRAMEBUFFER, phase.fbo);\n    // let status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);\n    // if (status !== gl.FRAMEBUFFER_COMPLETE) {\n    //     console.log(\"runRenderPhase: framebuffer not complete: \" + status);\n    // }\n    gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);\n    RenderPhaseStats.bindAndDrawCount += 1;\n}\n\nexport function createBufferTex(gl: WebGL2RenderingContext, width: number, height: number, channels: number): IBufferTex {\n    let texture = gl.createTexture()!;\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    let [format, iformat] = channelsToFormat(gl, channels);\n    gl.texImage2D(gl.TEXTURE_2D, 0, iformat, width, height, 0, format, gl.FLOAT, null);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n\n    return {\n        width,\n        height,\n        texture,\n        channels,\n    };\n}\n\nexport function writeToBufferTex(gl: WebGL2RenderingContext, buffer: IBufferTex, data: Float32Array) {\n    if (data.length !== buffer.width * buffer.height * buffer.channels) {\n        throw new Error('Data length does not match buffer size');\n    }\n    gl.bindTexture(gl.TEXTURE_2D, buffer.texture);\n    let [format] = channelsToFormat(gl, buffer.channels);\n    gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, buffer.width, buffer.height, format, gl.FLOAT, data);\n}\n\nexport function readFromRenderPhase(gl: WebGL2RenderingContext, phase: IRenderPhase, index: number, out: Float32Array) {\n    let buffer = phase.destBuffers[index];\n    if (out.length !== buffer.width * buffer.height * buffer.channels) {\n        throw new Error(`Data length does not match output size: expected ${buffer.width * buffer.height * buffer.channels}, got supplied buffer is ${out.length}`);\n    }\n    gl.bindFramebuffer(gl.FRAMEBUFFER, phase.fbo);\n    gl.readBuffer(gl.COLOR_ATTACHMENT0 + index);\n    let [format] = channelsToFormat(gl, buffer.channels);\n\n    let altFormat = gl.getParameter(gl.IMPLEMENTATION_COLOR_READ_FORMAT);\n    let altType = gl.getParameter(gl.IMPLEMENTATION_COLOR_READ_TYPE);\n\n    if (altType !== gl.FLOAT) {\n        throw new Error(`Implementation does not support reading back float data. Got type ${GlType[altType] ?? altType}`);\n    }\n\n    if (altFormat !== format) {\n        // Sometimes the implementation doesn't support reading back float data for the particular number of channels we're after\n        // In this case, they typically support RGBA32F for channels < 4, so handle that case, and manually down-convert\n        if (altFormat !== gl.RGBA) {\n            throw new Error(`Implementation does not support reading back float data for ${buffer.channels} channels, or 4 channels. Got format ${GlFormat[altFormat] ?? altFormat}.`);\n        }\n        let temp = new Float32Array(buffer.width * buffer.height * 4);\n        gl.readPixels(0, 0, buffer.width, buffer.height, altFormat, gl.FLOAT, temp);\n        for (let c = 0; c < buffer.channels; c++) {\n            for (let i = 0; i < out.length; i++) {\n                out[i] = temp[i * 4 + c];\n            }\n        }\n    } else {\n        gl.readPixels(0, 0, buffer.width, buffer.height, format, gl.FLOAT, out);\n    }\n}\n\nexport function channelsToFormat(gl: WebGL2RenderingContext, channels: number): [GlFormat, GlInternalFormat] {\n    switch (channels) {\n        case 1: return [gl.RED, gl.R32F];\n        case 2: return [gl.RG, gl.RG32F];\n        case 3: return [gl.RGB, gl.RGB32F];\n        case 4: return [gl.RGBA, gl.RGBA32F];\n        default: throw new Error(`Invalid number of channels: ${channels}. Must be 1, 2, 3, or 4.`);\n    }\n}\n\nexport enum GlFormat {\n    RED = 0x1903,\n    RG = 0x8227,\n    RGB = 0x1907,\n    RGBA = 0x1908,\n}\n\nexport enum GlInternalFormat {\n    R32F = 0x822E,\n    RG32F = 0x8230,\n    RGB32F = 0x8815,\n    RGBA32F = 0x8814,\n}\n\nexport enum GlType {\n    UNSIGNED_BYTE = 0x1401,\n    FLOAT = 0x1406,\n}","\n/* Design decisions for Vec3/Vec4\n\nMethods have immutable behavior (rather than in-place) for less error-prone usage, but that naturally\nmeans a drop in perf. Happy with this trade.\nAll methods only have at most 1 new Vec*, even if it means a bit more repetition.\n\nFact-check: false:\n    Inheriting from Array<number> seems to give good structure in V8. In particular, the number array\n    elements (as doubles) are inline in the array, and the initialization with the size means the array\n    is actually that size. It looks like there's an extra pointer hop from this class to get to the\n    actual array data which is not strictly ideal, but better than both Float64Array and 3 pointer hops\n    in the case of { x: number, y: number, z: number } (V8 doesn't do double de-boxing :( ).\n\nProbably due to inhieriting from Array<number>, the constructor is painfully slow, showing up in\nstack traces.\n\nBack to simple objects, on the idea that ones that live on the stack will get jitted away anyway.\n\nV8 shows Vec3 & Vec4 as having an 24 byte overhead, which... isn't toooo bad\n\n*/\n\nimport { clamp } from \"./data\";\n\nexport enum Dim {\n    X = 0,\n    Y = 1,\n    Z = 2,\n}\n\nexport class Vec3 {\n    x: number;\n    y: number;\n    z: number;\n    constructor(x: number = 0.0, y: number = 0.0, z: number = 0.0) {\n        this.x = +x;\n        this.y = +y;\n        this.z = +z;\n    }\n\n    add(a: Vec3): Vec3 { return new Vec3(this.x + a.x, this.y + a.y, this.z + a.z); }\n    sub(a: Vec3): Vec3 { return new Vec3(this.x - a.x, this.y - a.y, this.z - a.z); }\n    dot(a: Vec3): number { return this.x * a.x + this.y * a.y + this.z * a.z; }\n    mul(a: number): Vec3 { return new Vec3(this.x * a, this.y * a, this.z * a); }\n    mulAdd(a: Vec3, b: number): Vec3 { return new Vec3(this.x + a.x * b, this.y + a.y * b, this.z + a.z * b); }\n    lenSq(): number { return this.x * this.x + this.y * this.y + this.z * this.z; }\n    distSq(a: Vec3): number {\n        let dx = this.x - a.x;\n        let dy = this.y - a.y;\n        let dz = this.z - a.z;\n        return dx * dx + dy * dy + dz * dz;\n    }\n    len(): number { return Math.sqrt(this.lenSq()); }\n    dist(a: Vec3): number { return Math.sqrt(this.distSq(a)); }\n    normalize(): Vec3 { return this.mul(1.0 / Math.sqrt(this.lenSq())); }\n    mid(a: Vec3): Vec3 { return new Vec3((this.x + a.x) * 0.5, (this.y + a.y) * 0.5, (this.z + a.z) * 0.5); }\n    abs() { return new Vec3(Math.abs(this.x), Math.abs(this.y), Math.abs(this.z)); }\n    clone(): Vec3 { return new Vec3(this.x, this.y, this.z); }\n    toVec4(): Vec4 { return new Vec4(this.x, this.y, this.z, 1.0); }\n    round(): Vec3 { return new Vec3(Math.round(this.x), Math.round(this.y), Math.round(this.z)); }\n    round_(): Vec3 { this.x = Math.round(this.x); this.y = Math.round(this.y); this.z = Math.round(this.z); return this; }\n    copy_(a: Vec3) { this.x = a.x; this.y = a.y; this.z = a.z; }\n    static cross(a: Vec3, b: Vec3): Vec3 { return new Vec3(\n        a.y * b.z - a.z * b.y,\n        a.z * b.x - a.x * b.z,\n        a.x * b.y - a.y * b.x); }\n    writeToBuf(buf: Float32Array, offset: number) {\n        buf[offset + 0] = this.x;\n        buf[offset + 1] = this.y;\n        buf[offset + 2] = this.z;\n    }\n    static fromArray(a: ArrayLike<number>, offset: number = 0): Vec3 {\n        return new Vec3(a[offset + 0], a[offset + 1], a[offset + 2]);\n    }\n    setAt(i: number, v: number) {\n        switch (i) {\n        case 0: this.x = v; break;\n        case 1: this.y = v; break;\n        case 2: this.z = v; break;\n        }\n        return this;\n    }\n    addAt(i: number, v: number) {\n        switch (i) {\n        case 0: this.x += v; break;\n        case 1: this.y += v; break;\n        case 2: this.z += v; break;\n        }\n        return this;\n    }\n    getAt(i: number): number {\n        switch (i) {\n        case 0: return this.x;\n        case 1: return this.y;\n        case 2: return this.z;\n        }\n        return 0.0;\n    }\n    withSetAt(i: number, v: number): Vec3 { return this.clone().setAt(i, v); }\n    withAddAt(i: number, v: number): Vec3 { return this.clone().addAt(i, v); }\n    toString(dp: number = 3): string {\n        return `Vec3(${numMaxDp(this.x, dp)}, ${numMaxDp(this.y, dp)}, ${numMaxDp(this.z, dp)})`;\n    }\n    rotateAbout(k: Vec3, thetaRad: number) {\n        // https://en.wikipedia.org/wiki/Rodrigues%27_rotation_formula\n        // k must have unit length\n        let c = Math.cos(thetaRad);\n        let s = Math.sin(thetaRad);\n        let kCrossV = Vec3.cross(k, this);\n        let kDotV = k.dot(this);\n        return this.mul(c).add(kCrossV.mul(s)).add(k.mul(kDotV * (1 - c)));\n    }\n    lerp(a: Vec3, t: number): Vec3 {\n         return new Vec3(\n            a.x * t + this.x * (1 - t),\n            a.y * t + this.y * (1 - t),\n            a.z * t + this.z * (1 - t),\n         );\n    }\n    static zero = new Vec3(0, 0, 0);\n    static one = new Vec3(1, 1, 1);\n}\n\n\nexport class Vec4 {\n    x: number;\n    y: number;\n    z: number;\n    w: number;\n    constructor(x: number = 0.0, y: number = 0.0, z: number = 0.0, w: number = 1.0) {\n        this.x = +x;\n        this.y = +y;\n        this.z = +z;\n        this.w = +w;\n    }\n\n    getIdx(i: number): number {\n        switch (i) {\n        case 0: return this.x;\n        case 1: return this.y;\n        case 2: return this.z;\n        case 3: return this.w;\n        default: throw new Error(`Invalid index ${i}`);\n        }\n    }\n    add(a: Vec4): Vec4 { return new Vec4(this.x + a.x, this.y + a.y, this.z + a.z, this.w + a.w); }\n    sub(a: Vec4): Vec4 { return new Vec4(this.x - a.x, this.y - a.y, this.z - a.z, this.w - a.w); }\n    dot(a: Vec4): number { return this.x*a.x + this.y*a.y + this.z*a.z + this.w+a.w; }\n    mul(a: number): Vec4 { return new Vec4(this.x * a, this.y * a, this.z * a, this.w * a); }\n    lenSq(): number { return this.x*this.x + this.y*this.y + this.z*this.z + this.w*this.w; }\n    distSq(a: Vec4): number {\n        let dx = this.x - a.x;\n        let dy = this.y - a.y;\n        let dz = this.z - a.z;\n        let dw = this.w - a.w;\n        return dx * dx + dy * dy + dz * dz + dw * dw;\n    }\n    len(): number { return Math.sqrt(this.lenSq()); }\n    dist(a: Vec4): number { return Math.sqrt(this.distSq(a)); }\n    normalize(): Vec4 { return this.mul(1.0 / Math.sqrt(this.lenSq())); }\n    projToVec3(): Vec3 { return new Vec3(this.x / this.w, this.y / this.w, this.z / this.w); }\n    static lerp(a: Vec4, b: Vec4, t: number): Vec4 {\n        return a.add(b.sub(a).mul(t));\n    }\n    writeToBuf(buf: Float32Array, offset: number) {\n        buf[offset + 0] = this.x;\n        buf[offset + 1] = this.y;\n        buf[offset + 2] = this.z;\n        buf[offset + 3] = this.w;\n    }\n    static fromArray(a: ArrayLike<number>, offset: number = 0): Vec4 {\n        return new Vec4(a[offset + 0], a[offset + 1], a[offset + 2], a[offset + 3]);\n    }\n    static fromVec3(v: Vec3, w: number = 1.0): Vec4 {\n        return new Vec4(v.x, v.y, v.z, w);\n    }\n    toArray(): ArrayLike<number> {\n        return [this.x, this.y, this.z, this.w];\n    }\n    static fromHexColor(s: string, alpha: number = 1.0): Vec4 {\n        if (s.startsWith('#')) s = s.slice(1);\n        let hexVal = parseInt(s, 16);\n        let x = (hexVal >> 16) & 0xFF;\n        let y = (hexVal >> 8) & 0xFF;\n        let z = hexVal & 0xFF;\n        return new Vec4(x / 255.0 * alpha, y / 255.0 * alpha, z / 255.0 * alpha, alpha);\n    }\n    toHexColor(): string {\n        let toPair = (v: number) => Math.floor(v * 255).toString(16).padStart(2, '0');\n        return `#${toPair(this.x)}${toPair(this.y)}${toPair(this.z)}${toPair(this.w)}`;\n    }\n    toString(): string {\n        return `Vec4(${numMaxDp(this.x)}, ${numMaxDp(this.y)}, ${numMaxDp(this.z)}, ${numMaxDp(this.w)})`;\n    }\n}\n\nfunction numMaxDp(x: number, dp: number = 3) {\n    return parseFloat(x.toFixed(dp)).toString();\n}\n\nexport class BoundingBox3d {\n    public min: Vec3 = new Vec3();\n    public max: Vec3 = new Vec3();\n    public empty: boolean = true;\n\n    constructor(...args: Array<Vec3>) {\n        for (let v of args)\n            this.addInPlace(v);\n    }\n\n    addInPlace(v: Vec3) {\n        if (this.empty) {\n            this.min.x = v.x;\n            this.min.y = v.y;\n            this.min.z = v.z;\n            this.max.x = v.x;\n            this.max.y = v.y;\n            this.max.z = v.z;\n            this.empty = false;\n        } else {\n            this.min.x = Math.min(this.min.x, v.x);\n            this.min.y = Math.min(this.min.y, v.y);\n            this.min.z = Math.min(this.min.z, v.z);\n            this.max.x = Math.max(this.max.x, v.x);\n            this.max.y = Math.max(this.max.y, v.y);\n            this.max.z = Math.max(this.max.z, v.z);\n        }\n        return this;\n    }\n\n    combineInPlace(v: BoundingBox3d) {\n        return v.empty ? this : this.addInPlace(v.min).addInPlace(v.max);\n    }\n\n    center(): Vec3 {\n        let a = this.max;\n        let b = this.min;\n        return new Vec3(\n            a.x + 0.5 * (b.x - a.x),\n            a.y + 0.5 * (b.y - a.y),\n            a.z + 0.5 * (b.z - a.z));\n    }\n\n    size(): Vec3 {\n        return this.max.sub(this.min);\n    }\n\n    contains(p: Vec3) {\n        return !this.empty &&\n            p.x >= this.min.x && p.x <= this.max.x &&\n            p.y >= this.min.y && p.y <= this.max.y &&\n            p.z >= this.min.z && p.z <= this.max.z;\n    }\n\n    intersects(b: BoundingBox3d) {\n        return !this.empty && !b.empty &&\n            this.max.x >= b.min.x && this.min.x <= b.max.x &&\n            this.max.y >= b.min.y && this.min.y <= b.max.y &&\n            this.max.z >= b.min.z && this.min.z <= b.max.z;\n    }\n\n    expandInPlace(border: number) {\n        if (!this.empty) {\n            this.min.x -= border;\n            this.min.y -= border;\n            this.min.z -= border;\n            this.max.x += border;\n            this.max.y += border;\n            this.max.z += border;\n        }\n        return this;\n    }\n\n    shrinkInPlaceXY(inset: number) {\n        if (!this.empty) {\n            this.min.x += inset;\n            this.min.y += inset;\n            this.max.x -= inset;\n            this.max.y -= inset;\n            if (this.min.x > this.max.x || this.min.y > this.max.y) {\n                this.empty = true;\n                this.min = new Vec3();\n                this.max = new Vec3();\n            }\n        }\n        return this;\n    }\n\n    clone(): BoundingBox3d {\n        let b = new BoundingBox3d();\n        b.min = this.min.clone();\n        b.max = this.max.clone();\n        b.empty = this.empty;\n        return b;\n    }\n\n    toString(): string {\n        return `BoundingBox3d(${this.min}, ${this.max})`;\n    }\n}\n\n// static functions that operate on Float32Arrays (or Float64Arrays)\n// all functions are in-place, and read/write from specified offsets\n// safe to use with the same array for both input and output\n\nexport type IArr = Float32Array | Float64Array;\n\nexport class Vec3Buf {\n\n    static add_(a: IArr, aOff: number, b: IArr, bOff: number, out: IArr, outOff: number) {\n        out[outOff + 0] = a[aOff + 0] + b[bOff + 0];\n        out[outOff + 1] = a[aOff + 1] + b[bOff + 1];\n        out[outOff + 2] = a[aOff + 2] + b[bOff + 2];\n    }\n\n    static sub_(a: IArr, aOff: number, b: IArr, bOff: number, out: IArr, outOff: number) {\n        out[outOff + 0] = a[aOff + 0] - b[bOff + 0];\n        out[outOff + 1] = a[aOff + 1] - b[bOff + 1];\n        out[outOff + 2] = a[aOff + 2] - b[bOff + 2];\n    }\n\n    static copy_(a: IArr, aOff: number, out: IArr, outOff: number) {\n        out[outOff + 0] = a[aOff + 0];\n        out[outOff + 1] = a[aOff + 1];\n        out[outOff + 2] = a[aOff + 2];\n    }\n\n    static normalize_(a: IArr, aOff: number, out: IArr, outOff: number) {\n        let x = a[aOff + 0];\n        let y = a[aOff + 1];\n        let z = a[aOff + 2];\n        let lenInv = 1.0 / Math.sqrt(x * x + y * y + z * z);\n        out[outOff + 0] = x * lenInv;\n        out[outOff + 1] = y * lenInv;\n        out[outOff + 2] = z * lenInv;\n    }\n\n    static len_(a: Float32Array, aOff: number): number {\n        let x = a[aOff + 0];\n        let y = a[aOff + 1];\n        let z = a[aOff + 2];\n        return Math.sqrt(x * x + y * y + z * z);\n    }\n}\n\nexport class Vec4Buf {\n    static copy_(a: IArr, aOff: number, out: IArr, outOff: number) {\n        out[outOff + 0] = a[aOff + 0];\n        out[outOff + 1] = a[aOff + 1];\n        out[outOff + 2] = a[aOff + 2];\n        out[outOff + 3] = a[aOff + 3];\n    }\n}\n\nexport function segmentNearestPoint(p0: Vec3, p1: Vec3, x: Vec3) {\n    let v = p1.sub(p0);\n    let w = x.sub(p0);\n    let t = clamp(w.dot(v) / v.dot(v), 0, 1);\n    return p0.mulAdd(v, t);\n}\n\nexport function segmentNearestT(p0: Vec3, p1: Vec3, x: Vec3) {\n    let v = p1.sub(p0);\n    let w = x.sub(p0);\n    return clamp(w.dot(v) / v.dot(v), 0, 1);\n}\n\n// project x onto v\nexport function projectOntoVector(x: Vec3, v: Vec3) {\n    return v.mul(x.dot(v) / v.dot(v));\n}\n","import { Vec3 } from \"./vector\";\n\nexport function makeArray<T = number>(length: number, val?: T): T[] {\n    return new Array(length).fill(val ?? 0);\n}\n\nexport function makeArrayRange(length: number, min: number, max: number): number[] {\n    return new Array(length).fill(0).map((_, i) => min + i * (max - min) / (length - 1));\n}\n\nexport function oneHotArray(length: number, index: number, val: number, defaultVal: number = 0.0): number[] {\n    let arr = new Array(length).fill(defaultVal);\n    arr[index] = val;\n    return arr;\n}\n\nexport function assignImm<T>(target: T, source: Partial<T>): T {\n    let keys = Object.keys(source);\n    let changed = false;\n    target = target ?? {} as any;\n    for (let k of keys) {\n        let src = (source as any)[k];\n        let dst = (target as any)[k];\n        if ((src === dst) ||\n            (src instanceof Date && dst instanceof Date && +src === +dst) ||\n            (src instanceof Vec3 && dst instanceof Vec3 && src.distSq(dst) === 0.0)\n        ) {\n            continue;\n        }\n        changed = true;\n    }\n    return changed ? Object.assign({}, target, source) : target;\n}\n\nexport function assignImmFull<T>(target: T | null, source: T | null): T | null {\n    return source && target ? assignImm(target, source) : source;\n}\n\nexport function isNil(a: any): a is null | undefined {\n    return a === null || a === undefined;\n}\n\nexport function isNotNil<T>(a: T | null | undefined): a is T {\n    return a !== null && a !== undefined;\n}\n\nexport type StateSetter<T> = (action: React.SetStateAction<T>) => void;\n\nexport function applySetter<T>(setState: React.SetStateAction<T>, existing: T) {\n    return setState instanceof Function ? setState(existing) : setState;\n}\n\nexport function clamp(num: number, min: number, max: number) {\n    if (num < min) {\n        return min;\n    } else if (num > max) {\n        return max;\n    }\n    return num;\n}\n\nexport function base64ToArrayBuffer(base64: string) {\n    let binaryString = window.atob(base64);\n    let len = binaryString.length;\n    let bytes = new Uint8Array(len);\n    for (let i = 0; i < len; i++) {\n        bytes[i] = binaryString.charCodeAt(i);\n    }\n    return bytes.buffer;\n}\n\nexport function getOrAddToMap<K, V>(map: Map<K, V>, key: K, valueFn: () => V): V {\n    let existing = map.get(key);\n    if (existing === undefined) {\n        let value = valueFn();\n        map.set(key, value);\n        return value;\n    }\n    return existing;\n}\n\nexport function hasFlag(flags: number, flag: number) {\n    return (flags & flag) === flag;\n}\n","import { clamp } from \"./data\";\n\nexport function lerp(a: number, b: number, t: number) {\n    return a + (b - a) * clamp(t, 0, 1);\n}\n\n// we lerp after running the smoothstep, and t is clamped to [0, 1]\nexport function lerpSmoothstep(a: number, b: number, t: number) {\n    if (t <= 0.0) return a;\n    if (t >= 1.0) return b;\n    return a + (b - a) * t * t * (3 - 2 * t);\n}\n\nexport function roundUpTo(a: number, b: number) {\n    return Math.ceil(a / b) * b;\n}\n","import { ISharedRender } from \"../llm/render/sharedRender\";\nimport { roundUpTo } from \"./math\";\n\nexport interface IGLContext {\n    gl: WebGL2RenderingContext;\n    shaderManager: IShaderManager;\n    ext: {\n        colorBufferFloat: EXT_color_buffer_float | null;\n        disjointTimerQuery: EXT_disjoint_timer_query_webgl2 | null;\n    },\n}\n\nexport interface EXT_disjoint_timer_query_webgl2 {\n    TIME_ELAPSED_EXT: number;\n}\n\nexport interface IProgram<T extends string = any> {\n    name: string;\n    program: WebGLProgram;\n    vertShader: WebGLShader;\n    fragShader: WebGLShader;\n    vertSource: string;\n    fragSource: string;\n    ready: boolean;\n    locs: Record<T, WebGLUniformLocation>;\n    uboBindings: Record<string, number>;\n}\n\nexport interface IShaderManager {\n    gl: WebGL2RenderingContext;\n    vertShaders: Map<string, WebGLShader>;\n    fragShaders: Map<string, WebGLShader>;\n    programs: IProgram[];\n    unlinkedPrograms: IProgram[];\n}\n\nexport function createShaderManager(gl: WebGL2RenderingContext) {\n    return {\n        gl,\n        vertShaders: new Map(),\n        fragShaders: new Map(),\n        programs: [],\n        unlinkedPrograms: [],\n    };\n}\n\nexport interface IShaderExtras {\n    uboBindings: Record<string, number>;\n}\n\nexport function createShaderProgram<T extends string>(manager: IShaderManager | IGLContext, name: string, vert: string, frag: string, uniformNames?: T[], extra?: IShaderExtras): IProgram<T> | null {\n    if ('shaderManager' in manager) {\n        manager = manager.shaderManager;\n    }\n\n    let gl = manager.gl;\n\n    let program = gl.createProgram()!;\n\n    function compileAndAttachShader(type: number, source: string, typeStr: string, map: Map<string, WebGLShader>) {\n        let shader = map.get(source);\n        if (!shader) {\n            shader = gl.createShader(type)!;\n            gl.shaderSource(shader, source);\n            gl.compileShader(shader);\n            map.set(source, shader);\n        }\n        gl.attachShader(program, shader);\n        return shader;\n    }\n\n    let vertShader = compileAndAttachShader(gl.VERTEX_SHADER, vert, 'vert', manager.vertShaders);\n    let fragShader = compileAndAttachShader(gl.FRAGMENT_SHADER, frag, 'frag', manager.fragShaders);\n\n    let locs = {} as Record<T, WebGLUniformLocation>;\n\n    if (uniformNames) {\n        for (let name of uniformNames) {\n            locs[name] = -1;\n        }\n    }\n\n    let prog: IProgram<T> = {\n        name,\n        program,\n        vertSource: vert,\n        fragSource: frag,\n        vertShader,\n        fragShader,\n        locs,\n        uboBindings: extra?.uboBindings ?? {},\n        ready: false,\n    };\n\n    manager.unlinkedPrograms.push(prog);\n\n    return prog;\n}\n\n\nexport function ensureShadersReady(manager: IShaderManager) {\n    let gl = manager.gl;\n\n    for (let prog of manager.unlinkedPrograms) {\n        gl.linkProgram(prog.program);\n    }\n\n    for (let prog of manager.unlinkedPrograms) {\n        let program = prog.program;\n\n        if (gl.getProgramParameter(program, gl.LINK_STATUS)) {\n\n            for (let name of Object.keys(prog.locs)) {\n                let loc = gl.getUniformLocation(program, name);\n                if (!loc) {\n                    console.log(`uniform of ${prog.name} not found: ${name} (may just be unused)`);\n                }\n                prog.locs[name] = loc!;\n            }\n            prog.ready = true;\n\n            for (let uboName of Object.keys(prog.uboBindings)) {\n                let uboIndex = gl.getUniformBlockIndex(program, uboName);\n                if (uboIndex < 0) {\n                    console.log(`ubo of ${prog.name} not found: ${uboName} (may just be unused)`);\n                }\n                gl.uniformBlockBinding(program, uboIndex, prog.uboBindings[uboName]);\n            }\n\n        } else {\n\n            let progInfoLog = gl.getProgramInfoLog(program);\n            if (progInfoLog) {\n                let prefix = `---- '${prog.name}' program info log ----`;\n                console.log(`${prefix}\\n` + gl.getProgramInfoLog(program)?.replace('\\x00', '').trimEnd());\n            }\n\n            logShader(prog.vertShader, prog.name, 'vert');\n            logShader(prog.fragShader, prog.name, 'frag');\n        }\n    }\n\n    manager.programs.push(...manager.unlinkedPrograms);\n    manager.unlinkedPrograms = [];\n\n    function logShader(shader: WebGLShader, name: string, typeStr: string) {\n        let infoLog = gl.getShaderInfoLog(shader);\n        if (infoLog) {\n            let prefix = `---- ${name} ${typeStr} shader info log ----`;\n            console.log(`${prefix}\\n` + infoLog.replace('\\x00', '').trimEnd());\n        }\n    }\n}\n\nexport interface IBindOpts {\n    divisor?: number;\n    locOffset?: number;\n    bufOffset?: number;\n}\n\nexport interface IFloatAttrib {\n    name: string;\n    size: number;\n    nCols?: number; // for matrices\n}\n\nexport function bindFloatAttribs(gl: WebGL2RenderingContext, buf: WebGLBuffer, opts: IBindOpts, attribs: IFloatAttrib[]) {\n    gl.bindBuffer(gl.ARRAY_BUFFER, buf);\n    let locId = opts.locOffset || 0;\n    let offset = opts.bufOffset || 0;\n    let divisor = opts.divisor || 0;\n    let byteStride = 0;\n    for (let a of attribs) {\n        byteStride += a.size * 4 * (a.nCols ?? 1);\n    }\n    for (let a of attribs) {\n        for (let i = 0; i < (a.nCols ?? 1); i++) {\n            gl.enableVertexAttribArray(locId);\n            gl.vertexAttribPointer(locId, a.size, gl.FLOAT, false, byteStride, offset);\n            gl.vertexAttribDivisor(locId, divisor);\n            offset += a.size * 4;\n            locId++;\n        }\n    }\n    return byteStride;\n}\n\n/*\nWe store multiple buffers client-side, each one can grow independently, and each represents the\ndata drawn in a specific phase.  Then we can upload the data nicely packed.\nWe still have to do multiple draw calls, since each phase is made up of different renderers, but\njust need a single WebGLBuffer with its vertexAttribs etc.\n*/\nexport interface IFloatLocalBuffer {\n    buf: Float32Array;\n    strideFloats: number;\n    strideBytes: number;\n    capacityEls: number; // elements\n    usedEls: number; // elements\n\n    glOffsetEls: number;\n}\n\nexport interface IFloatBuffer {\n    target: number; // gl.ARRAY_BUFFER, gl.UNIFORM_BUFFER, etc\n    localBufs: IFloatLocalBuffer[];\n    buf: WebGLBuffer;\n    strideFloats: number;\n    strideBytes: number;\n\n    glCapacityEls: number; // elements in the gl buffer. May lag capacityEls\n    sharedRender?: ISharedRender;\n}\n\nexport function createFloatBuffer(gl: WebGL2RenderingContext, target: number, buf: WebGLBuffer, capacityEls: number, strideBytes: number, sharedRender: ISharedRender | null): IFloatBuffer {\n    let numPhases = sharedRender?.numPhases || 1;\n    if (target === gl.UNIFORM_BUFFER) {\n        let uboBlockOffsetAlign = gl.getParameter(gl.UNIFORM_BUFFER_OFFSET_ALIGNMENT);\n        strideBytes = roundUpTo(strideBytes, uboBlockOffsetAlign);\n    }\n\n    let strideFloats = strideBytes / 4;\n    gl.bindBuffer(target, buf);\n    gl.bufferData(target, capacityEls * strideBytes, gl.DYNAMIC_DRAW);\n\n    let localBufs: IFloatLocalBuffer[] = [];\n    for (let i = 0; i < numPhases; i++) {\n        localBufs.push({\n            buf: new Float32Array(capacityEls * strideFloats),\n            strideFloats,\n            strideBytes,\n            capacityEls,\n            usedEls: 0,\n            glOffsetEls: 0,\n        });\n    }\n\n    return { target, buf, strideFloats, strideBytes, glCapacityEls: capacityEls, localBufs };\n}\n\nexport function ensureFloatBufferSize(localBuf: IFloatLocalBuffer, countEls: number) {\n    let newUsedEls = localBuf.usedEls + countEls;\n\n    if (newUsedEls > localBuf.capacityEls) {\n        while (newUsedEls > localBuf.capacityEls) {\n            localBuf.capacityEls *= 2;\n        }\n\n        let newLocalBuf = new Float32Array(localBuf.capacityEls * localBuf.strideFloats);\n        newLocalBuf.set(localBuf.buf);\n        localBuf.buf = newLocalBuf;\n    }\n}\n\nexport function uploadFloatBuffer(gl: WebGL2RenderingContext, bufMap: IFloatBuffer) {\n    gl.bindBuffer(bufMap.target, bufMap.buf);\n\n    let totalUsed = 0;\n    for (let i = 0; i < bufMap.localBufs.length; i++) {\n        let localBuf = bufMap.localBufs[i];\n        totalUsed += localBuf.usedEls;\n    }\n\n    if (totalUsed > bufMap.glCapacityEls) {\n        while (totalUsed > bufMap.glCapacityEls) {\n            bufMap.glCapacityEls *= 2;\n        }\n        gl.bufferData(bufMap.target, bufMap.glCapacityEls * bufMap.strideBytes, gl.DYNAMIC_DRAW);\n    }\n\n    let offsetEls = 0;\n    for (let i = 0; i < bufMap.localBufs.length; i++) {\n        let localBuf = bufMap.localBufs[i];\n        localBuf.glOffsetEls = offsetEls;\n        if (localBuf.usedEls > 0) {\n            gl.bufferSubData(bufMap.target, offsetEls * bufMap.strideBytes, localBuf.buf.subarray(0, localBuf.usedEls * localBuf.strideFloats));\n        }\n        offsetEls += localBuf.usedEls;\n    }\n}\n\nexport function resetFloatBufferMap(bufMap: IFloatBuffer) {\n    for (let i = 0; i < bufMap.localBufs.length; i++) {\n        bufMap.localBufs[i].usedEls = 0;\n    }\n}\n\nexport interface IELementLocalBuffer {\n    buf: Uint32Array;\n    capacityVerts: number;\n    usedVerts: number\n\n    glOffsetBytes: number;\n}\n\nexport interface IElementBuffer {\n    buf: WebGLBuffer;\n    localBufs: IELementLocalBuffer[];\n    glCapacityVerts: number; // verts in the gl buffer. May lag capacityVerts\n}\n\nexport function createElementBuffer(gl: WebGL2RenderingContext, buf: WebGLBuffer, capacityVerts: number, sharedRender: ISharedRender | null): IElementBuffer {\n    let numPhases = sharedRender?.numPhases || 1;\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buf);\n    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, capacityVerts * 4, gl.DYNAMIC_DRAW);\n\n    let localBufs: IELementLocalBuffer[] = [];\n    for (let i = 0; i < numPhases; i++) {\n        localBufs.push({\n            buf: new Uint32Array(capacityVerts),\n            capacityVerts,\n            usedVerts: 0,\n            glOffsetBytes: 0,\n        });\n    }\n\n    return { buf, glCapacityVerts: capacityVerts, localBufs };\n}\n\nexport function ensureElementBufferSize(localBuf: IELementLocalBuffer, countVerts: number) {\n    let newUsedVerts = localBuf.usedVerts + countVerts;\n\n    if (newUsedVerts > localBuf.capacityVerts) {\n        let newCapacityVerts = localBuf.capacityVerts * 2;\n        while (newUsedVerts > newCapacityVerts) {\n            newCapacityVerts *= 2;\n        }\n\n        let newLocalBuf = new Uint32Array(newCapacityVerts);\n        newLocalBuf.set(localBuf.buf);\n\n        localBuf.capacityVerts = newCapacityVerts;\n        localBuf.buf = newLocalBuf;\n    }\n}\n\nexport function uploadElementBuffer(gl: WebGL2RenderingContext, bufMap: IElementBuffer) {\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, bufMap.buf);\n\n    let totalUsed = 0;\n    for (let i = 0; i < bufMap.localBufs.length; i++) {\n        let localBuf = bufMap.localBufs[i];\n        totalUsed += localBuf.usedVerts;\n    }\n\n    if (totalUsed > bufMap.glCapacityVerts) {\n        while (totalUsed > bufMap.glCapacityVerts) {\n            bufMap.glCapacityVerts *= 2;\n        }\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, bufMap.glCapacityVerts * 4, gl.DYNAMIC_DRAW);\n    }\n\n    let offsetIndex = 0;\n    for (let i = 0; i < bufMap.localBufs.length; i++) {\n        let localBuf = bufMap.localBufs[i];\n        localBuf.glOffsetBytes = offsetIndex * 4;\n        let srcBuf = localBuf.buf.subarray(0, localBuf.usedVerts);\n        if (localBuf.usedVerts > 0) {\n            gl.bufferSubData(gl.ELEMENT_ARRAY_BUFFER, offsetIndex * 4, srcBuf);\n        }\n        offsetIndex += localBuf.usedVerts;\n    }\n}\n\nexport function resetElementBufferMap(bufMap: IElementBuffer) {\n    for (let i = 0; i < bufMap.localBufs.length; i++) {\n        bufMap.localBufs[i].usedVerts = 0;\n    }\n}\n","import { NativeFunctions } from \"./NativeBindings\";\nimport { IRenderState } from \"./render/modelRender\";\nimport { createSyncObject, ISyncObject } from \"./render/syncObjects\";\nimport { nonNil } from \"@/src/utils/basic\";\nimport { Random } from \"@/src/utils/random\";\nimport { createBufferTex, writeToBufferTex, createRenderPhase, IBufferTex, runRenderPhase, readFromRenderPhase, arraysEqual, IRenderPhase, logArr, RenderPhaseStats } from \"@/src/utils/renderPhases\";\nimport { createShaderProgram, ensureShadersReady, IProgram, IShaderManager } from \"@/src/utils/shader\";\nimport { IGptModelConfig, ITensorSet } from \"@/src/utils/tensor\";\n\nexport interface IModelShape {\n    B: number;\n    vocabSize: number;\n    nBlocks: number;\n    C: number;\n    nHeads: number;\n    T: number;\n    A: number;\n}\n\nexport interface ILayerBuilder {\n    gl: WebGL2RenderingContext;\n    model: ITensorSet;\n    shape: IModelShape;\n    shaderManager: IShaderManager;\n}\n\n\nexport interface IDataAndModel {\n    data: ITensorSet;\n    model: ITensorSet;\n    native: NativeFunctions;\n}\n\nexport type IModelState = ReturnType<typeof initModel>;\n\n/* TODO: think about how to handle working computation buffers.\n\nFor each layer, we're typically abe to re-use the working memory buffers (provided they're the same dims, or smaller).\nBut the layers each have different weights.\nHowever, for debugging etc, we also want to keep all the working buffers around.\nWe also want to re-use programs and shader objects where possible. Can just do a string compare on the shader source.\nBaking in the constants remains a good idea I think, since the div/mod's can be flattened since they're often powers of 2 (& constant).\n\nAlso have the issue of passing input/output buffers between stages, where we can often re-use those buffers\n(not always, e.g. layerNorm). However, the (B, T, C) buffers can sometimes allow for a ping-pong process.\n\nWe might as well build the nested structure of the real model, with each chunk having create + execute methods.\n*/\n\nexport function initModel(state: IRenderState, dataAndModel: IDataAndModel, B: number) {\n    // let gptLayerTest = createGptModel(state.ctx.shaderManager, dataAndModel.model, dataAndModel.data.config.B!);\n    // runModel(state, gptLayerTest, dataAndModel.data);\n    // cleanupGptModel(state.gl, gptLayerTest);\n\n    return createGptModel(state.ctx.shaderManager, dataAndModel.model, B);\n}\n\nexport function setModelInputData(renderState: IRenderState, gptModel: IGpuGptModel, rand: Random) {\n    let { gl } = renderState;\n    let { inputTokens, shape: { B, T } } = gptModel;\n\n    let buf = new Float32Array(B * T);\n    for (let i = 0; i < buf.length; i++) {\n        buf[i] = rand.randint(0, 3);\n    }\n\n    buf.set([2, 1, 0, 1, 1, 2, 0, 0, 0, 0, 0]);\n\n    gptModel.inputBuf = buf;\n    gptModel.inputLen = 6;\n    writeToBufferTex(gl, inputTokens, buf);\n}\n\nexport function runModel(renderState: IRenderState, gptModel: IGpuGptModel, validationData?: ITensorSet) {\n    let { ctx: { gl }, quadVao } = renderState;\n    let {\n        inputTokens,\n        add,\n        posEmbed,\n        vocabEmbed,\n        blocks,\n        ln_f,\n        lm_head,\n        softmaxFinal,\n        shape,\n    } = gptModel;\n\n    let { B, C, T, nBlocks } = shape;\n\n    console.log(`---- running GPT model B=${B} C=${C} T=${T} layers=${nBlocks} ----`);\n\n    let allValid = true;\n\n    RenderPhaseStats.bindAndDrawCount = 0;\n    gl.disable(gl.DEPTH_TEST);\n    gl.disable(gl.CULL_FACE);\n    gl.disable(gl.BLEND);\n    gl.bindVertexArray(quadVao);\n\n    if (validationData) {\n        let tIdx = validationData.idx; // (B, T)\n        gptModel.inputBuf = tIdx.buffer;\n        writeToBufferTex(gl, inputTokens, tIdx.buffer);\n    }\n\n    runRenderPhase(gl, vocabEmbed.phase);\n    runRenderPhase(gl, posEmbed.phase);\n    runRenderPhase(gl, add.addPhase);\n\n    // gl.flush();\n    validate('x', add.addPhase);\n\n    for (let blockId = 0; blockId < blocks.length; blockId++) {\n        let { ln_1, attn, ln_2, mlp } = blocks[blockId];\n\n        gl.flush();\n        runRenderPhase(gl, ln_1.aggPhase);\n        runRenderPhase(gl, ln_1.applyPhase);\n        runRenderPhase(gl, attn.qkvPhase);\n        runRenderPhase(gl, attn.selfAttendPhase);\n        runRenderPhase(gl, attn.attnMatrixAggPhase);\n        runRenderPhase(gl, attn.attnMatrixSoftmaxPhase);\n        runRenderPhase(gl, attn.scaledVectorsPhase);\n        runRenderPhase(gl, attn.proj.linearPhase);\n        gl.flush();\n        runRenderPhase(gl, attn.add.addPhase);\n        runRenderPhase(gl, ln_2.aggPhase);\n        runRenderPhase(gl, ln_2.applyPhase);\n        runRenderPhase(gl, mlp.fcLayer.linearPhase);\n        runRenderPhase(gl, mlp.geluPhase);\n        runRenderPhase(gl, mlp.projLayer.linearPhase);\n        runRenderPhase(gl, mlp.addLayer.addPhase);\n\n        gl.flush();\n        validate(`block${blockId}`, mlp.addLayer.addPhase);\n    }\n\n    runRenderPhase(gl, ln_f.aggPhase);\n    runRenderPhase(gl, ln_f.applyPhase);\n    runRenderPhase(gl, lm_head.linearPhase);\n\n    gl.flush();\n\n    runRenderPhase(gl, softmaxFinal.aggPhase);\n    runRenderPhase(gl, softmaxFinal.softmaxPhase);\n\n    function validate(name: string, phase: IRenderPhase) {\n        if (!validationData) {\n            return;\n        }\n        let expected = validationData[name].toFloat32Array();\n        let dataFromGpu = new Float32Array(expected.length);\n        readFromRenderPhase(gl, phase, 0, dataFromGpu);\n        let isEqual = arraysEqual(dataFromGpu, expected);\n        if (!isEqual) {\n            logArr('expected', expected);\n            logArr('actual', dataFromGpu);\n        }\n        allValid = allValid && isEqual;\n        console.log(name, isEqual);\n    }\n\n    if (validationData) {\n        setTimeout(() => {\n            validate('x', add.addPhase);\n\n            for (let blockId = 0; blockId < blocks.length; blockId++) {\n                validate(`block${blockId}`, blocks[blockId].mlp.addLayer.addPhase);\n            }\n\n            validate('lm_head', lm_head.linearPhase);\n\n            validate('probs', softmaxFinal.softmaxPhase);\n\n            if (!allValid) {\n                console.error('VALIDATION FAILED');\n            }\n        }, 200);\n    }\n\n    if (!validationData) {\n        gptModel.readbackSync = createSyncObject(renderState);\n        gl.flush();\n    }\n\n    console.log(`---- done running GPT model drawCount = ${RenderPhaseStats.bindAndDrawCount} ----`);\n}\n\nexport function loopModelOutputToInput(renderState: IRenderState, model: IGpuGptModel) {\n    let gl = model.gl;\n\n    gl.useProgram(model.copyOutputToInput.copyPhase.program.program);\n    gl.uniform1i(model.copyOutputToInput.copyPhase.program.locs['u_targetTIdx'], model.inputLen);\n    runRenderPhase(gl, model.copyOutputToInput.copyPhase);\n\n    model.inputLen++;\n}\n\nexport function readModelResultsBackWhenReady(model: IGpuGptModel) {\n    if (model.readbackSync && model.readbackSync.isReady) {\n        console.log('sync is ready after', model.readbackSync.elapsedMs.toFixed(1), 'ms');\n        readModelResultsBack(model);\n        model.readbackSync = null;\n    }\n}\n\nexport function readModelResultsBack(model: IGpuGptModel) {\n\n    let { gl, shape: { B, T, C, vocabSize } } = model;\n    let size = B * T * vocabSize;\n\n    if (!model.resultBuf || model.resultBuf.length !== size) {\n        model.resultBuf = new Float32Array(size);\n    }\n\n    readFromRenderPhase(gl, model.softmaxFinal.softmaxPhase, 0, model.resultBuf);\n\n    let sortedBuf = new Float32Array(T * vocabSize * 2);\n    for (let t = 0; t < T; t++) {\n        let options = [...model.resultBuf.slice(t * vocabSize, (t + 1) * vocabSize)].map((v, i) => ({ v, i }));\n        options.sort((a, b) => b.v - a.v);\n        for (let i = 0; i < options.length; i++) {\n            sortedBuf[(t * vocabSize + i) * 2 + 0] = options[i].i;\n            sortedBuf[(t * vocabSize + i) * 2 + 1] = options[i].v;\n        }\n    }\n    model.sortedBuf = sortedBuf;\n}\n\nfunction cleanupGptModel(gl: WebGL2RenderingContext, model: IGpuGptModel) {\n    // @TODO: need a way of collecting all resources:\n    // - texture buffers\n    // - render phases\n}\n\nexport const basicVertexShader = /*glsl*/`#version 300 es\nprecision highp float;\nlayout(location = 0) in vec2 a_position;\nvoid main() {\n    gl_Position = vec4(a_position, 0, 1);\n}\n`;\n\nexport interface IEmbedLayerLink {\n    weight: IBufferTex;\n    output: IBufferTex;\n}\n\nexport interface ILinearLayerLink {\n    weight: IBufferTex;\n    bias: IBufferTex | null;\n    output: IBufferTex;\n}\n\nexport interface ILayerNormLayerLink {\n    normAgg: IBufferTex;\n    normWeight: IBufferTex;\n    normBias: IBufferTex;\n    output: IBufferTex;\n}\n\nexport interface ISoftmaxLayerLink {\n    agg: IBufferTex;\n    output: IBufferTex;\n}\n\nexport interface IAddLayerLink {\n    output: IBufferTex;\n}\n\nexport interface IBlockLayerLink {\n    output: IBufferTex;\n    ln_1: ILayerNormLayerLink;\n    ln_2: ILayerNormLayerLink;\n    attn: IAttentionLayerLink;\n    mlp: IMlpLayerLink;\n}\n\nexport interface IAttentionLayerLink {\n    qkvWeight: IBufferTex;\n    qkvBias: IBufferTex;\n    qkvOutput: IBufferTex;\n    attnMatrix: IBufferTex;\n    attnMatrixAgg: IBufferTex;\n    attnMatrixSoftmax: IBufferTex;\n    scaledVectors: IBufferTex;\n    proj: ILinearLayerLink;\n    add: IAddLayerLink;\n    output: IBufferTex;\n}\n\nexport interface IMlpLayerLink {\n    fcLayer: ILinearLayerLink;\n    mlpGelu: IBufferTex;\n    projLayer: ILinearLayerLink;\n    addLayer: IAddLayerLink;\n    output: IBufferTex;\n}\n\nexport interface IGptModelLink {\n    gl: WebGL2RenderingContext;\n    inputBuf: Float32Array;\n    inputTokens: IBufferTex;\n    vocabEmbed: IEmbedLayerLink;\n    posEmbed: IEmbedLayerLink;\n    add: IAddLayerLink;\n    blocks: IBlockLayerLink[],\n    ln_f: ILayerNormLayerLink;\n    lm_head: ILinearLayerLink;\n    softmaxFinal: ISoftmaxLayerLink;\n    shape: IModelShape;\n    output: IBufferTex;\n    resultBuf: Float32Array | null;\n    sortedBuf: Float32Array | null;\n    inputLen: number;\n}\n\nexport interface IGpuGptModel extends IGptModelLink {\n    vocabEmbed: IGpuEmbeddingLayer;\n    posEmbed: IGpuEmbeddingLayer;\n    add: IGpuAddLayer;\n    ln_f: IGpuLayerNormLayer;\n    lm_head: IGpuLinearLayer;\n    softmaxFinal: IGpuSoftmaxLayer;\n    blocks: IGpuGptBlockLayer[];\n\n    copyOutputToInput: { copyPhase: IRenderPhase };\n    readbackSync: ISyncObject | null;\n}\n\nexport function createGptModel(shaderManager: IShaderManager, model: ITensorSet, B: number): IGpuGptModel {\n    let gl = shaderManager.gl;\n    let prefix = 'transformer';\n\n    let config = model.config;\n\n    let C = config.n_embd;\n    let nHeads = config.n_head;\n    let T = config.block_size;\n    let nBlocks = config.n_layer;\n    let vocabSize = config.vocab_size;\n    let A = C / nHeads; // n elements in each Q, K, V vector, i.e. what we project down to\n\n    let shape: IModelShape = { B, C, nHeads, T, A, nBlocks, vocabSize };\n    let layerBuilder: ILayerBuilder = { gl, model, shape, shaderManager };\n\n    let inputBuf = new Float32Array(B * T);\n    let inputTokens = createBufferTex(gl, 1, B * T, 1);\n\n    // not ideal to have to create one for each batch, but works for now\n    let posArr = new Float32Array(B * T);\n    for (let i = 0; i < B; i++) {\n        for (let j = 0; j < T; j++) {\n            posArr[i * T + j] = j;\n        }\n    }\n    let pos = createBufferTex(gl, 1, B * T, 1);\n    writeToBufferTex(gl, pos, posArr);\n\n    let vocabEmbed = createEmbeddingLayer(layerBuilder, prefix + '.wte', vocabSize, C, inputTokens);\n    let posEmbed = createEmbeddingLayer(layerBuilder, prefix + '.wpe', T, C, pos);\n    let add = createAddLayer(layerBuilder, vocabEmbed.output, posEmbed.output); // add has shape (C, B * T)\n\n    let blocks = [];\n    let x = add.output;\n    for (let i = 0; i < nBlocks; i++) {\n        let block = createBlockLayer(layerBuilder, prefix + '.h.' + i, x);\n        blocks.push(block);\n        x = block.output;\n    }\n\n    let ln_f = createLayerNorm(layerBuilder, prefix + '.ln_f', x);\n    let lm_head = createLinearLayer(layerBuilder, 'lm_head', C, vocabSize, ln_f.output, undefined, false);\n\n    let softmaxFinal = createSoftmaxLayer(layerBuilder, lm_head.output);\n\n    let copyOutputToInput = createCopyOutputToInputLayer(layerBuilder, softmaxFinal.output, inputTokens);\n\n    ensureShadersReady(shaderManager);\n\n    return {\n        gl,\n        inputBuf,\n        inputTokens,\n        vocabEmbed,\n        posEmbed,\n        add,\n        blocks,\n        ln_f,\n        lm_head,\n        shape,\n        softmaxFinal,\n        copyOutputToInput,\n        output: softmaxFinal.output,\n        inputLen: 6,\n        resultBuf: null as Float32Array | null,\n        sortedBuf: null as Float32Array | null,\n        readbackSync: null as ISyncObject | null,\n    };\n}\n\nexport interface IGpuGptBlockLayer extends IBlockLayerLink {\n    ln_1: IGpuLayerNormLayer;\n    ln_2: IGpuLayerNormLayer;\n    attn: IGpuAttnLayer;\n    mlp: IGpuMlpLayer;\n}\n\nfunction createBlockLayer(layerBuilder: ILayerBuilder, prefix: string, input: IBufferTex): IGpuGptBlockLayer {\n    let ln_1 = createLayerNorm(layerBuilder, prefix + '.ln_1', input);\n    let attn = createAttnLayer(layerBuilder, prefix + '.attn', ln_1.output, input);\n    let ln_2 = createLayerNorm(layerBuilder, prefix + '.ln_2', attn.output);\n    let mlp = createMLP(layerBuilder, prefix + '.mlp', ln_2.output, attn.output);\n\n    return {\n        attn,\n        ln_1,\n        ln_2,\n        mlp,\n        output: mlp.output,\n    };\n}\n\nexport interface IGpuAttnLayer extends IAttentionLayerLink {\n    qkvPhase: IRenderPhase;\n    selfAttendPhase: IRenderPhase;\n    attnMatrixAggPhase: IRenderPhase;\n    attnMatrixSoftmaxPhase: IRenderPhase;\n    scaledVectorsPhase: IRenderPhase;\n    proj: IGpuLinearLayer;\n    add: IGpuAddLayer;\n}\n\nfunction createAttnLayer(layerBuilder: ILayerBuilder, prefix: string, input: IBufferTex, residual: IBufferTex): IGpuAttnLayer {\n    let { gl, model, shape: { B, T, C, nHeads, A }, shaderManager } = layerBuilder;\n\n    // move the 1st dim to the end, i.e. the QKV split will be packed into RGB tex channels\n    let tAttnWeight = model[prefix + '.c_attn.weight'].view([3, nHeads, A, C]).permute(1, 2, 3, 0);\n    let tAttnBias = model[prefix + '.c_attn.bias'].view([3, nHeads, A]).permute(1, 2, 0);\n\n    // weights\n    let qkvWeight         = createBufferTex(gl, C, nHeads * A, 3);\n    let qkvBias           = createBufferTex(gl, 1, nHeads * A, 3);\n\n    // inputs; buffers; outputs\n    let qkvOutput         = createBufferTex(gl, A, B * nHeads * T, 4); // 4 channels required for color-renderable\n    let attnMatrix        = createBufferTex(gl, T, B * nHeads * T, 1);\n    let attnMatrixAgg     = createBufferTex(gl, 1, B * nHeads * T, 2);\n    let attnMatrixSoftmax = createBufferTex(gl, T, B * nHeads * T, 1);\n    let scaledVectors     = createBufferTex(gl, nHeads * A, B * T, 1);\n\n    writeToBufferTex(gl, qkvWeight, tAttnWeight.toFloat32Array());\n    writeToBufferTex(gl, qkvBias, tAttnBias.toFloat32Array());\n\n    let qkvProg = createShaderProgram(shaderManager, 'qkv', basicVertexShader, /*glsl*/`#version 300 es\n        precision highp float;\n        uniform sampler2D attnInput; // (B, T)         (C)\n        uniform sampler2D qkvWeight; // (nHeads, A)    (C) [3]\n        uniform sampler2D qkvBias;   // (nHeads, A)    (1) [3]\n        out vec4 qkvOutput;          // (B, nHeads, T) (A)\n\n        void main() {\n            ivec2 pos = ivec2(gl_FragCoord.xy);\n\n            int headIdx = pos.y / ${T};\n            int tIdx = pos.y % ${T};\n            int bIdx = headIdx / ${nHeads};\n            headIdx = headIdx % ${nHeads};\n\n            vec3 a = texelFetch(qkvBias, ivec2(0, headIdx * ${A} + pos.x), 0).rgb;\n            for (int i = 0; i < ${C}; i++) {\n                float inVal = texelFetch(attnInput, ivec2(i, tIdx + bIdx * ${T}    ), 0).r;\n                vec3 qkvW   = texelFetch(qkvWeight,  ivec2(i, headIdx * ${A} + pos.x), 0).rgb;\n                a += inVal * qkvW;\n            }\n\n            qkvOutput = vec4(a, 1);\n        }\n    `);\n\n    let selfAttendProg = createShaderProgram(shaderManager, 'selfAttend', basicVertexShader, /* glsl */`#version 300 es\n        precision highp float;\n        uniform sampler2D qkvOutput; // (B, nHeads, T) (A)\n        out float attnMatrix;        // (B, nHeads, T) (T)\n\n        void main() {\n            ivec2 pos = ivec2(gl_FragCoord.xy);\n            int tIdxK = pos.x;\n            int tIdxQ = pos.y % ${T};\n            int yOffset = pos.y - tIdxQ;\n\n            if (tIdxK > tIdxQ) { // # forward attention only\n                discard;\n            }\n\n            float a = 0.0;\n            for (int i = 0; i < ${A}; i++) {\n                float q = texelFetch(qkvOutput, ivec2(i, yOffset + tIdxQ), 0).r;\n                float k = texelFetch(qkvOutput, ivec2(i, yOffset + tIdxK), 0).g;\n                a += q * k;\n            }\n\n            attnMatrix = a / sqrt(float(${A}));\n        }\n    `);\n\n    let attnMatrixAggProg = createShaderProgram(shaderManager, 'attnMatrixAgg', basicVertexShader, /*glsl*/`#version 300 es\n        precision highp float;\n        uniform sampler2D attnMatrix; // (B, nHeads, T) (T)\n        out vec2 attnMatrixAgg;       // (B, nHeads, T) (1) [2]\n\n        void main() {\n            ivec2 pos = ivec2(gl_FragCoord.xy);\n            int tIdxY = pos.y % ${T};\n\n            // Pass 1 finds the max\n            float m = 0.0;\n            for (int i = 0; i <= tIdxY; i++) {\n                float p = texelFetch(attnMatrix, ivec2(i, pos.y), 0).r;\n                m = max(m, p);\n            }\n\n            // Pass 2 finds the exp sum (shifted by max)\n            float a = 0.0;\n            for (int i = 0; i <= tIdxY; i++) {\n                float p = texelFetch(attnMatrix, ivec2(i, pos.y), 0).r;\n                a += exp(p - m);\n            }\n\n            // Store sufficient information to compute/apply the softmax\n            attnMatrixAgg = vec2(1.0 / a, m);\n        }\n    `);\n\n    let attnMatrixSoftmaxProg = createShaderProgram(shaderManager, 'attnMatrixSoftmax', basicVertexShader, /*glsl*/`#version 300 es\n        precision highp float;\n        uniform sampler2D attnMatrix;    // (B, nHeads, T) (T)\n        uniform sampler2D attnMatrixAgg; // (B, nHeads, T) (1) [2]\n        out float attnMatrixSoftmax;     // (B, nHeads, T) (T)\n\n        void main() {\n            ivec2 pos = ivec2(gl_FragCoord.xy);\n            int tIdxX = pos.x;\n            int tIdxY = pos.y % ${T};\n\n            if (tIdxX > tIdxY) { // # forward attention only\n                attnMatrixSoftmax = 0.0;\n                discard;\n            }\n\n            vec2 agg = texelFetch(attnMatrixAgg, ivec2(0, pos.y), 0).rg;\n            float expSumInv = agg.r;\n            float maxVal = agg.g;\n\n            float p = texelFetch(attnMatrix, pos, 0).r;\n            attnMatrixSoftmax = exp(p - maxVal) * expSumInv;\n        }\n    `);\n\n    let scaledVectorsProg = createShaderProgram(shaderManager, 'scaledVectors', basicVertexShader, /*glsl*/`#version 300 es\n        precision highp float;\n        uniform sampler2D qkvOutput;         // (B, nHeads, T) (A)\n        uniform sampler2D attnMatrixSoftmax; // (B, nHeads, T) (T)\n        out float scaledVectors;             // (B, T)         (A * nHeads)\n\n        void main() {\n            ivec2 pos = ivec2(gl_FragCoord.xy);\n            int aIdx = pos.x % ${A};\n            int headIdx = pos.x / ${A};\n\n            int tIdxY = pos.y % ${T};\n            int bIdx = pos.y / ${T};\n\n            int yOffset = bIdx * ${T} * ${nHeads} + headIdx * ${T};\n\n            float res = 0.0;\n            for (int i = 0; i <= tIdxY; i++) {\n                float sm = texelFetch(attnMatrixSoftmax, ivec2(i, yOffset + tIdxY), 0).r;\n                float v = texelFetch(qkvOutput, ivec2(aIdx, yOffset + i), 0).b;\n                res += sm * v;\n            }\n\n            scaledVectors = res;\n        }\n    `);\n\n    if (!qkvProg || !selfAttendProg || !attnMatrixAggProg || !attnMatrixSoftmaxProg || !scaledVectorsProg) {\n        throw new Error(\"Failed to create shader program\");\n    }\n\n    let qkvPhase = createRenderPhase(gl, qkvProg, [qkvOutput], [input, qkvWeight, qkvBias], ['attnInput', 'qkvWeight', 'qkvBias']);\n    let selfAttendPhase = createRenderPhase(gl, selfAttendProg, [attnMatrix], [qkvOutput], ['qkvOutput']);\n    let attnMatrixAggPhase = createRenderPhase(gl, attnMatrixAggProg, [attnMatrixAgg], [attnMatrix], ['attnMatrix']);\n    let attnMatrixSoftmaxPhase = createRenderPhase(gl, attnMatrixSoftmaxProg, [attnMatrixSoftmax], [attnMatrix, attnMatrixAgg], ['attnMatrix', 'attnMatrixAgg']); // Could skip?\n    let scaledVectorsPhase = createRenderPhase(gl, scaledVectorsProg, [scaledVectors], [qkvOutput, attnMatrixSoftmax], ['qkvOutput', 'attnMatrixSoftmax']);\n    let proj = createLinearLayer(layerBuilder, prefix + '.c_proj', C, C, scaledVectors);\n    let add = createAddLayer(layerBuilder, proj.output, residual);\n\n    return {\n        qkvWeight,\n        qkvBias,\n        qkvOutput,\n        attnMatrix,\n        attnMatrixAgg,\n        attnMatrixSoftmax,\n        scaledVectors,\n        qkvPhase,\n        selfAttendPhase,\n        attnMatrixAggPhase,\n        attnMatrixSoftmaxPhase,\n        scaledVectorsPhase,\n        proj,\n        add,\n        output: add.output,\n    };\n}\n\nexport interface IGpuMlpLayer extends IMlpLayerLink {\n    fcLayer: IGpuLinearLayer;\n    geluPhase: IRenderPhase;\n    projLayer: IGpuLinearLayer;\n    addLayer: IGpuAddLayer;\n}\n\nfunction createMLP(layerBuilder: ILayerBuilder, prefix: string, input: IBufferTex, residual: IBufferTex): IGpuMlpLayer {\n    let { gl, shape: { B, T, C }, shaderManager } = layerBuilder;\n\n    // operating memory\n    let mlpGelu = createBufferTex(gl, C * 4, B * T, 1); // (B, T) (4C)\n\n    let geluProg = createShaderProgram(shaderManager, 'mlpGelu', basicVertexShader, /*glsl*/`#version 300 es\n        precision highp float;\n        uniform sampler2D geluInput;  // (B, T) (C * 4)\n        out float geluOutput; // (B, T) (C * 4)\n\n        void main() {\n            ivec2 pos = ivec2(gl_FragCoord.xy);\n            float x = texelFetch(geluInput, pos, 0).r;\n            geluOutput = x * 0.5 * (1.0 + tanh(sqrt(2.0 / 3.14159265358) * (x + 0.044715 * x * x * x)));\n        }\n    `)!;\n\n    let fcLayer = createLinearLayer(layerBuilder, prefix + '.c_fc', C, C * 4, input);\n    let geluPhase = createRenderPhase(gl, geluProg, [mlpGelu], [fcLayer.output], ['geluInput']);\n    let projLayer = createLinearLayer(layerBuilder, prefix + '.c_proj', C * 4, C, mlpGelu);\n    let addLayer = createAddLayer(layerBuilder, projLayer.output, residual);\n\n    return {\n        fcLayer,\n        mlpGelu,\n        geluPhase,\n        projLayer,\n        addLayer,\n        output: addLayer.output,\n    };\n}\n\nexport interface IGpuLayerNormLayer extends ILayerNormLayerLink {\n    aggPhase: IRenderPhase;\n    applyPhase: IRenderPhase;\n}\n\nfunction createLayerNorm(layerBuilder: ILayerBuilder, layerPrefix: string, input: IBufferTex): IGpuLayerNormLayer {\n    let { gl, model, shape: { B, T, C }, shaderManager } = layerBuilder;\n\n    let tWeight = model[layerPrefix + '.weight'];\n    let tBias = model[layerPrefix + '.bias'];\n\n    // weights\n    let normWeight = createBufferTex(gl, 1, C, 1); // (C) (1)\n    let normBias   = createBufferTex(gl, 1, C, 1); // (C) (1)\n\n    // operating memory\n    let normAgg = createBufferTex(gl, 1, B * T, 2); // (B, T) (1) [2]\n    let output  = createBufferTex(gl, C, B * T, 1); // (B, T) (C)\n\n    writeToBufferTex(gl, normWeight, tWeight.toFloat32Array());\n    writeToBufferTex(gl, normBias, tBias.toFloat32Array());\n\n    let normEps = 1e-5;\n\n    let normAggProg = createShaderProgram(shaderManager, 'normAgg', basicVertexShader, /*glsl*/`#version 300 es\n        precision highp float;\n        uniform sampler2D normInput; // (B, T) (C)\n        out vec2 normAgg;            // (B, T) (1) [2]\n\n        void main() {\n            ivec2 pos = ivec2(gl_FragCoord.xy);\n            // Use Welford's algorithm to compute mean and variance\n            float mean = 0.0;\n            float M2 = 0.0;\n            for (int i = 0; i < ${C}; i++) {\n                float x = texelFetch(normInput, ivec2(i, pos.y), 0).r;\n                float delta = x - mean;\n                mean += delta / float(i + 1);\n                M2 += delta * (x - mean);\n            }\n\n            normAgg = vec2(mean, 1.0 / sqrt(M2 / float(${C}) + ${normEps}));\n        }\n    `)!;\n\n    let normApply = createShaderProgram(shaderManager, 'normApply', basicVertexShader, /*glsl*/`#version 300 es\n        precision highp float;\n        uniform sampler2D normInput;  // (B, T) (C)\n        uniform sampler2D normAgg;    // (B, T) (1) [2]\n        uniform sampler2D normWeight; // (C)    (1)\n        uniform sampler2D normBias;   // (C)    (1)\n        out float normOutput;         // (B, T) (C)\n\n        void main() {\n            ivec2 pos = ivec2(gl_FragCoord.xy);\n\n            vec2 agg = texelFetch(normAgg, ivec2(0, pos.y), 0).rg;\n            float mean = agg.r;\n            float stdInv = agg.g;\n\n            float x = texelFetch(normInput, pos, 0).r;\n\n            float weight = texelFetch(normWeight, ivec2(0, pos.x), 0).r;\n            float bias   = texelFetch(normBias,   ivec2(0, pos.x), 0).r;\n\n            normOutput = (x - mean) * stdInv * weight + bias;\n        }\n    `)!;\n\n    let aggPhase = createRenderPhase(gl, normAggProg, [normAgg], [input], ['normInput']);\n    let applyPhase = createRenderPhase(gl, normApply, [output],\n        [input, normAgg, normWeight, normBias],\n        ['normInput', 'normAgg', 'normWeight', 'normBias']);\n\n    return {\n        normAgg,\n        normWeight,\n        normBias,\n        aggPhase,\n        applyPhase,\n        output,\n    };\n}\n\n\nexport interface IGpuLinearLayer extends ILinearLayerLink {\n    linearPhase: IRenderPhase;\n}\n\nfunction createLinearLayer(layerBuilder: ILayerBuilder, prefix: string, nIn: number, nOut: number, input: IBufferTex, residual?: IBufferTex, bias?: boolean): IGpuLinearLayer {\n    let { gl, model, shape: { B, T }, shaderManager } = layerBuilder;\n\n    bias = bias ?? true;\n\n    let tWeight = model[prefix + '.weight'];\n    let tBias = bias ? model[prefix + '.bias'] : null;\n\n    // weights\n    let linearWeight = createBufferTex(gl, nIn, nOut, 1); // (nOut) (nIn)\n    let linearBias   = bias ? createBufferTex(gl, 1, nOut, 1) : null; // (nOut) (1)\n\n    // operating memory\n    let output = createBufferTex(gl, nOut, B * T, 1); // (B, T) (nOut)\n\n    writeToBufferTex(gl, linearWeight, tWeight.buffer);\n    tBias && linearBias && writeToBufferTex(gl, linearBias, tBias.buffer);\n\n    let linearProg = createShaderProgram(shaderManager, 'linear', basicVertexShader, /*glsl*/`#version 300 es\n        precision highp float;          //    y     x\n        uniform sampler2D linearInput;  // (B, T) (nIn)\n        uniform sampler2D linearWeight; // (nOut) (nIn)\n        ${bias ? 'uniform sampler2D linearBias;' : ''}   // (nOut) (1)\n        ${residual ? 'uniform sampler2D linearResidual;' : ''}\n        out float linearOutput;         // (B, T) (nOut)\n\n        void main() {\n            ivec2 pos = ivec2(gl_FragCoord.xy);\n\n            float res = ${bias ? 'texelFetch(linearBias, ivec2(0, pos.x), 0).r' : '0.0'};\n            for (int i = 0; i < ${nIn}; i++) {\n                float x = texelFetch(linearInput, ivec2(i, pos.y), 0).r;\n                float w = texelFetch(linearWeight, ivec2(i, pos.x), 0).r;\n                res += x * w;\n            }\n\n            ${residual ? 'res += texelFetch(linearResidual, pos, 0).r;' : ''}\n            linearOutput = res;\n        }\n    `)!;\n\n    let linearPhase = createRenderPhase(gl, linearProg, [output],\n        [input, linearWeight, linearBias, residual].filter(nonNil),\n        ['linearInput', 'linearWeight', bias ? 'linearBias' : null, residual ? 'linearResidual' : null].filter(nonNil));\n\n    return {\n        weight: linearWeight,\n        bias: linearBias,\n        linearPhase,\n        output,\n    };\n}\n\nexport interface IGpuEmbeddingLayer extends IEmbedLayerLink {\n    phase: IRenderPhase;\n}\n\nfunction createEmbeddingLayer(layerBuilder: ILayerBuilder, prefix: string, nEmbed: number, nDims: number, input: IBufferTex): IGpuEmbeddingLayer {\n    let { gl, model, shape: { B, T }, shaderManager } = layerBuilder;\n\n    let tWeight = model[prefix + '.weight'];\n\n    // weights\n    let weight = createBufferTex(gl, nDims, nEmbed, 1); // (nEmbed) (nDims)\n\n    // operating memory\n    let output = createBufferTex(gl, nDims, B * T, 1); // (B, T) (nDims)\n\n    writeToBufferTex(gl, weight, tWeight.buffer);\n\n    let embedProg = createShaderProgram(shaderManager, 'embed', basicVertexShader, /*glsl*/`#version 300 es\n        precision highp float;          //    y     x\n        uniform sampler2D embedInput;  // (B, T)   (1)\n        uniform sampler2D embedWeight; // (nEmbed) (nDims)\n        out float embedOutput;         // (B, T)   (nDims)\n\n        void main() {\n            ivec2 pos = ivec2(gl_FragCoord.xy);\n\n            int y = int(texelFetch(embedInput, ivec2(0, pos.y), 0).r);\n            float res = texelFetch(embedWeight, ivec2(pos.x, y), 0).r;\n\n            embedOutput = res;\n        }\n    `)!;\n\n    let phase = createRenderPhase(gl, embedProg, [output], [input, weight], ['embedInput', 'embedWeight']);\n\n    return {\n        weight,\n        phase,\n        output,\n    };\n}\n\nexport interface IGpuAddLayer extends IAddLayerLink {\n    addPhase: IRenderPhase;\n}\n\nfunction createAddLayer(layerBuilder: ILayerBuilder, inputA: IBufferTex, inputB: IBufferTex): IGpuAddLayer {\n    let { gl, shape: { B, T, C }, shaderManager } = layerBuilder;\n\n    // operating memory\n    let output = createBufferTex(gl, C, B * T, 1); // (B, T) (C)\n\n    let addProg = createShaderProgram(shaderManager, 'add', basicVertexShader, /*glsl*/`#version 300 es\n        precision highp float;     //    y    x\n        uniform sampler2D inputA;  // (B, T) (C)\n        uniform sampler2D inputB;  // (B, T) (C)\n        out float addOutput;       // (B, T) (C)\n\n        void main() {\n            ivec2 pos = ivec2(gl_FragCoord.xy);\n\n            float a = texelFetch(inputA, pos, 0).r;\n            float b = texelFetch(inputB, pos, 0).r;\n            addOutput = a + b;\n        }\n    `)!;\n\n    let addPhase = createRenderPhase(gl, addProg, [output], [inputA, inputB], ['inputA', 'inputB']);\n\n    return {\n        addPhase,\n        output,\n    };\n}\n\nexport interface IGpuSoftmaxLayer extends ISoftmaxLayerLink {\n    bufs: IBufferTex[];\n    progs: IProgram[];\n    phases: IRenderPhase[];\n    aggPhase: IRenderPhase;\n    softmaxPhase: IRenderPhase;\n}\n\nfunction createSoftmaxLayer(layerBuilder: ILayerBuilder, input: IBufferTex): IGpuSoftmaxLayer {\n    let { gl, shape: { B, T, C, vocabSize }, shaderManager } = layerBuilder;\n\n    // operating memory\n    let agg    = createBufferTex(gl,         1, B * T, 2);\n    let output = createBufferTex(gl, vocabSize, B * T, 1);\n\n    let softmaxAggProg = createShaderProgram(shaderManager, 'softmaxAgg', basicVertexShader, /*glsl*/`#version 300 es\n        precision highp float;       //    y      x\n        uniform sampler2D smInput;   // (B, T) (nVocab)\n        out vec2 smAgg;              // (B)    (nVocab) [2]\n\n        void main() {\n            ivec2 pos = ivec2(gl_FragCoord.xy);\n            int tIdxY = pos.y % ${T};\n\n            // Pass 1 finds the max\n            float m = 0.0;\n            for (int i = 0; i < ${vocabSize}; i++) {\n                float p = texelFetch(smInput, ivec2(i, pos.y), 0).r;\n                m = max(m, p);\n            }\n\n            // Pass 2 finds the exp sum (shifted by max)\n            float a = 0.0;\n            for (int i = 0; i < ${vocabSize}; i++) {\n                float p = texelFetch(smInput, ivec2(i, pos.y), 0).r;\n                a += exp(p - m);\n            }\n\n            // Store sufficient information to compute/apply the softmax\n            smAgg = vec2(1.0 / a, m);\n        }\n    `)!;\n\n    let softmaxProg = createShaderProgram(shaderManager, 'softmax', basicVertexShader, /*glsl*/`#version 300 es\n        precision highp float;\n        uniform sampler2D smInput;    // (B, T) (nVocab)\n        uniform sampler2D smAgg;      // (B)    (nVocab) [2]\n        out float smOutput;           // (B, T) (nVocab)\n\n        void main() {\n            ivec2 pos = ivec2(gl_FragCoord.xy);\n            int tIdxX = pos.x;\n            int tIdxY = pos.y % ${T};\n\n            vec2 agg = texelFetch(smAgg, ivec2(0, pos.y), 0).rg;\n            float expSumInv = agg.r;\n            float maxVal = agg.g;\n\n            float p = texelFetch(smInput, pos, 0).r;\n            smOutput = exp(p - maxVal) * expSumInv;\n        }\n    `)!;\n\n    let aggPhase = createRenderPhase(gl, softmaxAggProg, [agg], [input], ['smInput']);\n    let softmaxPhase = createRenderPhase(gl, softmaxProg, [output], [input, agg], ['smInput', 'smAgg']);\n\n    return {\n        bufs: [agg, output],\n        progs: [softmaxAggProg, softmaxProg],\n        phases: [aggPhase, softmaxPhase],\n        agg,\n        aggPhase,\n        softmaxPhase,\n        output,\n    };\n}\n\nfunction createCopyOutputToInputLayer(layerBuilder: ILayerBuilder, prevOutput: IBufferTex, currInput: IBufferTex) {\n    let { gl, shape: { T, vocabSize }, shaderManager } = layerBuilder;\n\n    let copyProg = createShaderProgram(shaderManager, 'copy', basicVertexShader, /*glsl*/`#version 300 es\n        precision highp float;         //    y    x\n        uniform sampler2D prevOutput;  // (B, T) (n_vocab)\n        uniform int u_targetTIdx;\n        out float currInput;           // (B, T) (1)\n\n        void main() {\n            ivec2 pos = ivec2(gl_FragCoord.xy);\n\n            int tIdx = pos.y % ${T};\n\n            if (tIdx != u_targetTIdx) {\n                discard;\n            }\n\n            int maxVocabI = 0;\n            float maxVocabP = 0.0;\n            for (int i = 0; i < ${vocabSize}; i++) {\n                float p = texelFetch(prevOutput, ivec2(i, pos.y), 0).r;\n                if (p > maxVocabP) {\n                    maxVocabP = p;\n                    maxVocabI = i;\n                }\n            }\n\n            currInput = float(maxVocabI);\n        }\n    `)!;\n\n    let copyPhase = createRenderPhase(gl, copyProg, [currInput], [prevOutput], ['prevOutput']);\n\n    return {\n        copyPhase,\n    };\n}\n","\n/* Design decisions for Mat4\n\nWith 16 floats, Float32Array is the obvious choice, and means it maps to WebGL nicely.\nNote that there's limited precision with floats, if we're ever computing js-side.\n\nThe matrix is in column-major order, also to match WebGL.\n*/\n\nimport { IArr, Vec3, Vec4 } from \"./vector\";\n\n/** Column-major, 16-element float32 matrix, extending a Float32Array.\nMethods will return a copy unless otherwise noted.\n*/\nexport class Mat4f extends Float32Array {\n    constructor(\n    ) {\n        super(16);\n        this[0] = this[5] = this[10] = this[15] = 1.0;\n    }\n\n    static identity = new Mat4f();\n\n    g(r: number, c: number) { return this[c * 4 + r]; }\n    s(r: number, c: number, v: number) { this[c * 4 + r] = v; }\n\n    add(a: Mat4f): Mat4f {\n        let res = new Mat4f();\n        for (let i = 0; i < 16; i++) {\n            res[i] = this[i] + a[i];\n        }\n        return res;\n    }\n\n    sub(a: Mat4f): Mat4f {\n        let res = new Mat4f();\n        for (let i = 0; i < 16; i++) {\n            res[i] = this[i] - a[i];\n        }\n        return res;\n    }\n\n    mul(a: Mat4f): Mat4f {\n        let res = new Mat4f();\n        for (let x = 0; x < 4; x++) {\n            for (let y = 0; y < 4; y++) {\n                let v = 0.0;\n                for (let k = 0; k < 4; k++) {\n                     v += this[k * 4 + y] * a[x * 4 + k];\n                }\n                res[x * 4 + y] = v;\n            }\n        }\n        return res;\n    }\n\n    mulVec4(a: Vec4): Vec4 {\n        let x = this[0] * a.x + this[4] * a.y + this[8] * a.z + this[12] * a.w;\n        let y = this[1] * a.x + this[5] * a.y + this[9] * a.z + this[13] * a.w;\n        let z = this[2] * a.x + this[6] * a.y + this[10] * a.z + this[14] * a.w;\n        let w = this[3] * a.x + this[7] * a.y + this[11] * a.z + this[15] * a.w;\n        return new Vec4(x, y, z, w);\n    }\n\n    mulVec3Proj(a: Vec3): Vec3 {\n        let v4 = this.mulVec4(new Vec4(a.x, a.y, a.z, 1.0));\n        let wInv = 1.0 / v4.w;\n        return new Vec3(v4.x * wInv, v4.y * wInv, v4.z * wInv);\n    }\n\n    mulVec3ProjVec(a: Vec3): Vec3 {\n        let v4 = this.mulVec4(new Vec4(a.x, a.y, a.z, 0.0));\n        return new Vec3(v4.x, v4.y, v4.z);\n    }\n\n    mulVec3Affine(a: Vec3) {\n        let o = new Vec3();\n        this.mulVec3Affine_(a, o);\n        return o;\n    }\n\n    mulVec3Affine_(a: Vec3, o: Vec3) {\n        let x = this[0] * a.x + this[4] * a.y + this[8] * a.z + this[12];\n        let y = this[1] * a.x + this[5] * a.y + this[9] * a.z + this[13];\n        let z = this[2] * a.x + this[6] * a.y + this[10] * a.z + this[14];\n        o.x = x;\n        o.y = y;\n        o.z = z;\n    }\n\n    mulVec3AffineArr_(a: IArr, aOff: number, out: IArr, outOff: number) {\n        let ax = a[aOff];\n        let ay = a[aOff + 1];\n        let az = a[aOff + 2];\n        out[outOff + 0] = this[0] * ax + this[4] * ay + this[8] * az + this[12];\n        out[outOff + 1] = this[1] * ax + this[5] * ay + this[9] * az + this[13];\n        out[outOff + 2] = this[2] * ax + this[6] * ay + this[10] * az + this[14];\n    }\n\n    mulVec3AffineVec_(a: Vec3, o: Vec3) {\n        let x = this[0] * a.x + this[4] * a.y + this[8] * a.z;\n        let y = this[1] * a.x + this[5] * a.y + this[9] * a.z;\n        let z = this[2] * a.x + this[6] * a.y + this[10] * a.z;\n        o.x = x;\n        o.y = y;\n        o.z = z;\n    }\n\n    static fromRowMajor(a: ArrayLike<number> | number[][]) {\n        if (a.length > 0 && Array.isArray(a[0])) {\n            a = (a as number[][]).flatMap(x => x);\n        }\n        let flatArr = a as ArrayLike<number>;\n        if (flatArr.length !== 16) {\n            console.log('need 16 elements');\n        }\n\n        let res = new Mat4f();\n        for (let i = 0; i < 4; i++) {\n            for (let j = 0; j < 4; j++) {\n                res[i * 4 + j] = flatArr[j * 4 + i];\n            }\n        }\n        return res;\n    }\n\n    static fromColMajor(flatArr: ArrayLike<number>, offset: number = 0) {\n        if (flatArr.length - offset < 16) {\n            console.log('need 16 elements');\n        }\n        let res = new Mat4f();\n        for (let i = 0; i < 16; i++) {\n            res[i] = flatArr[offset + i];\n        }\n        return res;\n    }\n\n    static fromTranslation(a: Vec3) {\n        let res = new Mat4f();\n        res[12] = a.x;\n        res[13] = a.y;\n        res[14] = a.z;\n        return res;\n    }\n\n    static fromScaleTranslation(s: Vec3, t: Vec3) {\n        let res = new Mat4f();\n        res[0] = s.x;\n        res[5] = s.y;\n        res[10] = s.z;\n        res[12] = t.x;\n        res[13] = t.y;\n        res[14] = t.z;\n        return res;\n    }\n\n    static fromAxisAngle(axis: Vec3, angleRad: number) {\n        let res = new Mat4f();\n        fromAxisAngle(axis, angleRad, res, 4);\n        return res;\n    }\n\n    static fromQuat(q: Vec4) {\n        let res = new Mat4f();\n        fromQuat(q, res, 4);\n        return res;\n    }\n\n    static fromScale(s: Vec3) {\n        let res = new Mat4f();\n        res[0] = s.x;\n        res[5] = s.y;\n        res[10] = s.z;\n        return res;\n    }\n\n    static fromLookAt(eye: Vec3, center: Vec3, up: Vec3) {\n        let f = eye.sub(center).normalize();\n        let u = up.normalize();\n        let r = Vec3.cross(u, f).normalize();\n        u = Vec3.cross(f, r);\n\n        let res = new Mat4f();\n        res[ 0] = r.x;\n        res[ 1] = u.x;\n        res[ 2] = f.x;\n        res[ 4] = r.y;\n        res[ 5] = u.y;\n        res[ 6] = f.y;\n        res[ 8] = r.z;\n        res[ 9] = u.z;\n        res[10] = f.z;\n        res[12] = -eye.dot(r);\n        res[13] = -eye.dot(u);\n        res[14] = -eye.dot(f);\n        return res;\n    }\n\n    static fromPersp(fovDeg: number, aspect: number, near: number, far: number) {\n        let h = near * Math.tan(fovDeg / 2 * Math.PI / 180) * 2;\n        let w = h * aspect;\n\n        let res = new Mat4f();\n        res[0] = 2 * near / w;\n        res[5] = 2 * near / h;\n        res[10] = - far / (far - near);\n        res[11] = -1;\n        res[14] = - far * near / (far - near);\n        res[15] = 0;\n\n        return res;\n    }\n\n    static fromOrtho(left: number, right: number, bottom: number, top: number, near: number, far: number) {\n        let res = new Mat4f();\n        res[0] = 2 / (right - left);\n        res[5] = 2 / (top - bottom);\n        res[10] = -2 / (far - near);\n        res[12] = -(right + left) / (right - left);\n        res[13] = -(top + bottom) / (top - bottom);\n        res[14] = -(far + near) / (far - near);\n        return res;\n    }\n\n    static zeros() {\n        let res = new Mat4f();\n        res[0] = 0.0;\n        res[5] = 0.0;\n        res[10] = 0.0;\n        res[15] = 0.0;\n        return res;\n    }\n\n    // creates Translation, Rotation, Scale, such that this matrix is the result of multipling\n    // the equivalent matrix forms, as in\n    //\n    // M = T * R * S\n    //\n    // Note that we assume that there is no skew or projective components.\n    // The rotation is given as a quaternion\n    decomposeToTRS(): [Vec3, Vec4, Vec3] {\n        let T = Vec3.fromArray(this, 12);\n        let S = new Vec3(\n            Vec3.fromArray(this, 0).len(),\n            Vec3.fromArray(this, 4).len(),\n            Vec3.fromArray(this, 8).len());\n\n        let tr = this[0] + this[5] + this[10];\n        let R: Vec4;\n        if (tr > 0.0) {\n            let r = Math.sqrt(1 + tr);\n            let s = 0.5 / r;\n            R = new Vec4(\n                (this[6] - this[9]) * s,\n                (this[8] - this[2]) * s,\n                (this[1] - this[4]) * s,\n                0.5 * r,\n            );\n        } else if (this[0] > this[5] && this[0] > this[10]) {\n            let r = Math.sqrt(1.0 + this[0] - this[5] - this[10]);\n            let s = 0.5 / r;\n            R = new Vec4(\n                0.5 * r,\n                (this[1] + this[4]) * s,\n                (this[8] + this[2]) * s,\n                (this[6] - this[9]) * s,\n            );\n        } else if (this[5] > this[10]) {\n            let r = Math.sqrt(1.0 + this[5] - this[0] - this[10]);\n            let s = 0.5 / r;\n            R = new Vec4(\n                (this[4] + this[1]) * s,\n                0.5 * r,\n                (this[9] + this[6]) * s,\n                (this[8] - this[2]) * s,\n            );\n        } else {\n            let r = Math.sqrt(1.0 + this[10] - this[0] - this[5]);\n            let s = 0.5 / r;\n            R = new Vec4(\n                (this[8] + this[2]) * s,\n                (this[9] + this[6]) * s,\n                0.5 * r,\n                (this[1] - this[4]) * s,\n            );\n        }\n        return [T, R, S];\n    }\n\n    invertTRS(): Mat4f {\n        let res = new Mat4f();\n\n        let u = Vec3.fromArray(this, 0);\n        let v = Vec3.fromArray(this, 4);\n        let w = Vec3.fromArray(this, 8);\n        let t = Vec3.fromArray(this, 12);\n\n        res[0] = this[0];\n        res[1] = this[4];\n        res[2] = this[8];\n\n        res[4] = this[1];\n        res[5] = this[5];\n        res[6] = this[9];\n\n        res[8] = this[2];\n        res[9] = this[6];\n        res[10] = this[10];\n\n        res[12] = -u.dot(t);\n        res[13] = -v.dot(t);\n        res[14] = -w.dot(t);\n\n        return res;\n    }\n\n    determinant(): number {\n        let A = new Float64Array(this);\n        let P = new Int32Array(5);\n        luDecomp(A, P, 4);\n        return luDeterminant(A, P, 4);\n    }\n\n    invert(): Mat4f {\n        let A = new Float64Array(this);\n        let P = new Int32Array(5);\n        luDecomp(A, P, 4);\n        let res = new Mat4f();\n        luInvert(A, P, 4, res);\n        return res;\n    }\n\n    toString(): string {\n        let s = '\\n';\n        for (let i = 0; i < 4; i++) {\n            s += i === 0 ? '[[' : ' [';\n            for (let j = 0; j < 4; j++) {\n                let v = this.g(i, j);\n                s += (v < 0 ? '' : ' ') + v.toFixed(3) + (j === 3 ? ']' : ', ');\n            }\n            s += i === 3 ? ']' : '\\n';\n        }\n        return s;\n    }\n}\n\n/** Column-major, 9-element float32 matrix, extending a Float32Array.\nMethods will return a copy unless otherwise noted.\n*/\nexport class Mat3f extends Float32Array {\n    constructor(\n    ) {\n        super(9);\n        this[0] = this[4] = this[8] = 1.0;\n    }\n\n    g(r: number, c: number) { return this[c * 3 + r]; }\n    s(r: number, c: number, v: number) { this[c * 3 + r] = v; }\n\n    add(a: Mat3f): Mat3f {\n        let res = new Mat3f();\n        for (let i = 0; i < 9; i++) {\n            res[i] = this[i] + a[i];\n        }\n        return res;\n    }\n\n    sub(a: Mat3f): Mat3f {\n        let res = new Mat3f();\n        for (let i = 0; i < 9; i++) {\n            res[i] = this[i] - a[i];\n        }\n        return res;\n    }\n\n    mul(a: Mat3f): Mat3f {\n        let res = new Mat3f();\n        for (let x = 0; x < 3; x++) {\n            for (let y = 0; y < 3; y++) {\n                let v = 0.0;\n                for (let k = 0; k < 3; k++) {\n                     v += this[k * 3 + y] * a[x * 3 + k];\n                }\n                res[x * 3 + y] = v;\n            }\n        }\n        return res;\n    }\n\n    mulVec3(a: Vec3): Vec3 {\n        let x = this[0] * a.x + this[3] * a.y + this[6] * a.z;\n        let y = this[1] * a.x + this[4] * a.y + this[7] * a.z;\n        let z = this[2] * a.x + this[5] * a.y + this[8] * a.z;\n        return new Vec3(x, y, z);\n    }\n\n    transpose(): Mat3f {\n        let res = new Mat3f();\n        res[0] = this[0];\n        res[1] = this[3];\n        res[2] = this[6];\n        res[3] = this[1];\n        res[4] = this[4];\n        res[5] = this[7];\n        res[6] = this[2];\n        res[7] = this[5];\n        res[8] = this[8];\n        return res;\n    }\n\n    static fromRowMajor(a: ArrayLike<number> | number[][]) {\n        if (a.length > 0 && Array.isArray(a[0])) {\n            a = (a as number[][]).flatMap(x => x);\n        }\n        let flatArr = a as ArrayLike<number>;\n        if (flatArr.length !== 9) {\n            console.log('need 9 elements');\n        }\n\n        let res = new Mat3f();\n        for (let i = 0; i < 3; i++) {\n            for (let j = 0; j < 3; j++) {\n                res[i * 3 + j] = flatArr[j * 3 + i];\n            }\n        }\n        return res;\n    }\n\n    static fromColMajor(flatArr: ArrayLike<number>, offset: number = 0) {\n        if (flatArr.length - offset < 9) {\n            console.log('need 9 elements');\n        }\n        let res = new Mat3f();\n        for (let i = 0; i < 9; i++) {\n            res[i] = flatArr[offset + i];\n        }\n        return res;\n    }\n\n    static fromAxisAngle(axis: Vec3, angleRad: number) {\n        let res = new Mat3f();\n        fromAxisAngle(axis, angleRad, res, 3);\n        return res;\n    }\n\n    static fromQuat(q: Vec4) {\n        let res = new Mat3f();\n        fromQuat(q, res, 3);\n        return res;\n    }\n\n    static fromScale(s: Vec3) {\n        let res = new Mat4f();\n        res[0] = s.x;\n        res[4] = s.y;\n        res[8] = s.z;\n        return res;\n    }\n\n    determinant(): number {\n        let A = new Float64Array(this);\n        let P = new Int32Array(4);\n        luDecomp(A, P, 3);\n        return luDeterminant(A, P, 3);\n    }\n\n    invert(): Mat3f {\n        let A = new Float64Array(this);\n        let P = new Int32Array(4);\n        luDecomp(A, P, 3);\n        let res = new Mat3f();\n        luInvert(A, P, 3, res);\n        return res;\n    }\n\n    toString(): string {\n        let s = '\\n';\n        for (let i = 0; i < 3; i++) {\n            s += i === 0 ? '[[' : ' [';\n            for (let j = 0; j < 3; j++) {\n                let v = this.g(i, j);\n                s += (v < 0 ? '' : ' ') + v.toFixed(3) + (j === 2 ? ']' : ', ');\n            }\n            s += i === 2 ? ']' : '\\n';\n        }\n        return s;\n    }\n}\n\nfunction fromQuat(q: Vec4, res: Float32Array, stride: number) {\n    let n = q.lenSq();\n    let s = n === 0.0 ? 0.0 : 2.0 / n;\n    let x = q.x;\n    let y = q.y;\n    let z = q.z;\n    let w = q.w;\n\n    let o = 0;\n    res[o+0] = 1 - s*(y*y + z*z);\n    res[o+1] = s*(x*y + w*z);\n    res[o+2] = s*(x*z - w*y);\n\n    o = stride;\n    res[o+0] = s*(x*y - w*z);\n    res[o+1] = 1 - s*(x*x + z*z);\n    res[o+2] = s*(y*z + w*x);\n\n    o = stride * 2;\n    res[o+0] = s*(x*z + w*y);\n    res[o+1] = s*(y*z - w*x);\n    res[o+2] = 1 - s*(x*x + y*y);\n}\n\nfunction fromAxisAngle(axis: Vec3, angleRad: number, res: Float32Array, stride: number) {\n    let u = axis.normalize();\n    let c = Math.cos(angleRad);\n    let s = Math.sin(angleRad)\n    let x = u.x;\n    let y = u.y;\n    let z = u.z;\n    let c2 = 1 - c;\n\n    let o = 0;\n    res[o+0] = x*x*c2 + c;\n    res[o+1] = y*x*c2 + z*s;\n    res[o+2] = z*x*c2 - y*s;\n\n    o = stride;\n    res[o+0] = x*y*c2 - z*s;\n    res[o+1] = y*y*c2 + c;\n    res[o+2] = z*y*c2 + x*s;\n\n    o = stride * 2;\n    res[o+0] = x*z*c2 + y*s;\n    res[o+1] = y*z*c2 - x*s;\n    res[o+2] = z*z*c2 + c;\n}\n\n/** From https://en.wikipedia.org/wiki/LU_decomposition */\n\n// The col-major n x n matrix A is modified in-place, and P should have n + 1 elements\nexport function luDecomp(A: Float64Array, P: Int32Array, n: number) {\n    for (let i = 0; i <= n; i++) {\n        P[i] = i;\n    }\n\n    for (let i = 0; i < n; i++) {\n        let maxA = 0.0;\n        let imax = i;\n\n        for (let k = i; k < n; k++) {\n            let absA = Math.abs(A[k * n + i]);\n            if (absA > maxA) {\n                maxA = absA;\n                imax = k;\n            }\n        }\n\n        if (maxA < 1e-9) {\n            return false;\n        }\n\n        if (imax !== i) {\n            // pivot p\n            let j = P[i];\n            P[i] = P[imax];\n            P[imax] = j;\n\n            // pivot A rows\n            for (let k = 0; k < n; k++) {\n                let j = A[i * n + k];\n                A[i * n + k] = A[imax * n + k];\n                A[imax * n + k] = j;\n            }\n\n            P[n] += 1;\n        }\n\n        for (let j = i + 1; j < n; j++) {\n            A[j * n + i] /= A[i * n + i];\n\n            for (let k = i + 1; k < n; k++) {\n                A[j * n + k] -= A[j * n + i] * A[i * n + k];\n            }\n        }\n    }\n}\n\nexport function luInvert(A: Float64Array, P: Int32Array, n: number, res: Float32Array | Float64Array) {\n    for (let j = 0; j < n; j++) {\n        for (let i = 0; i < n; i++) {\n            res[i * n + j] = P[i] === j ? 1.0 : 0.0;\n\n            for (let k = 0; k < i; k++) {\n                res[i * n + j] -= A[i * n + k] * res[k * n + j];\n            }\n        }\n\n        for (let i = n - 1; i >= 0; i--) {\n            for (let k = i + 1; k < n; k++) {\n                res[i * n + j] -= A[i * n + k] * res[k * n + j];\n            }\n            res[i * n + j] /= A[i * n + i];\n        }\n    }\n}\n\nexport function luDeterminant(A: Float64Array, P: Int32Array, n: number) {\n    let det = A[0];\n\n    for (let i = 1; i < n; i++) {\n        det *= A[i * n + i];\n    }\n\n    if ((P[n] - n) & 1) {\n        return -det;\n    } else {\n        return det;\n    }\n}\n\nexport function luSolve(A: Float64Array, P: Int32Array, n: number, b: Float64Array) {\n    let x = new Float64Array(n);\n    for (let i = 0; i < n; i++) {\n        x[i] = b[P[i]];\n\n        for (let k = 0; k < i; k++) {\n            x[i] -= A[i * n + k] * x[k];\n        }\n    }\n    for (let i = n - 1; i >= 0; i--) {\n        for (let k = i + 1; k < n; k++) {\n            x[i] -= A[i * n + k] * x[k];\n        }\n        x[i] /= A[i * n + i];\n    }\n    return x;\n}\n\nfunction test() {\n    console.log('Testing:', __filename);\n\n    let m1 = Mat4f.fromRowMajor([\n        -0.746, -0.982, -0.835,  0.752,\n        -0.989,  0.813,  0.142, -0.276,\n         0.553, -0.134, -0.457, -0.515,\n        -0.332,  0.305, -0.131,  0.137]);\n\n    let m2 = Mat4f.fromRowMajor([\n        -0.392, -0.049, -0.413, -0.521,\n         0.679, -0.482,  0.703, -0.223,\n         0.014,  0.485,  0.370, -0.187,\n        -0.294, -0.062, -0.203,  0.345]);\n\n    console.log(`m1: ${m1}`);\n    console.log(`m2: ${m2}`);\n    console.log(`m3: ${m1.mul(m2)}`);\n\n    let persp = Mat4f.fromPersp(30, 1.0, 1, 100);\n\n    console.log('persp:', persp);\n    let vals = [\n        new Vec3(1, 1, -1),\n        new Vec3(1, 1, -1.5),\n        new Vec3(1, 1, -10),\n        new Vec3(1, 1, -40),\n        new Vec3(1, 1, -100)];\n\n    for (let v of vals) {\n        let near = 1;\n        let far = 100;\n        let proj = persp.mulVec3Proj(v);\n        let unprojZ = near * far / ((near - far) * proj.z + far);\n        console.log('proj', v, '=>', proj.z, 'and back? =>', unprojZ);\n    }\n\n    let lookAt = Mat4f.fromLookAt(new Vec3(0, 0, 4), new Vec3(0, 0, 0), new Vec3(0, 1, 0));\n    console.log(`lookAt: ${lookAt}`);\n\n    for (let i = 0; i < 1; i++) {\n        let input = new Vec4(Math.random(), Math.random(), Math.random(), Math.random()).normalize();\n        let m = Mat4f.fromQuat(input);\n        let [T, R, S] = m.decomposeToTRS();\n        console.log(` in = ${input}\\nout = ${R}`);\n        console.log(`T = ${T}, S = ${S}`);\n    }\n}\n\nif (__filename === 'asdf') {\n    test();\n}\n","import { Mat4f } from \"@/src/utils/matrix\";\nimport { IGLContext } from \"@/src/utils/shader\";\n\nexport const UboBindings = {\n    ModelView: 0,\n    Block: 1,\n    BlockAccess: 2,\n    blur: 3,\n};\n\n\nexport enum RenderPhase {\n    Opaque,\n    Arrows,\n    Overlay,\n    Overlay2D,\n}\n\nconst NumRenderPhases = 4;\n\nexport type ISharedRender = {\n    gl: WebGL2RenderingContext;\n    modelViewUbo: WebGLBuffer;\n    modelViewBuf: Float32Array;\n\n    activePhase: RenderPhase;\n    numPhases: number;\n}\n\nexport function initSharedRender(ctx: IGLContext): ISharedRender {\n    let gl = ctx.gl;\n\n    let modelViewUbo = gl.createBuffer()!;\n    gl.bindBuffer(gl.UNIFORM_BUFFER, modelViewUbo);\n    gl.bufferData(gl.UNIFORM_BUFFER, 2 * 16 * 4, gl.DYNAMIC_DRAW);\n    gl.bindBufferBase(gl.UNIFORM_BUFFER, UboBindings.ModelView, modelViewUbo);\n    let modelViewBuf = new Float32Array(2 * 16);\n\n    return { gl, modelViewUbo, modelViewBuf, activePhase: RenderPhase.Opaque, numPhases: NumRenderPhases };\n}\n\nexport function writeModelViewUbo(sharedRender: ISharedRender, modelMtx: Mat4f, viewMtx: Mat4f) {\n    let { gl, modelViewUbo, modelViewBuf } = sharedRender;\n\n    modelViewBuf.set(modelMtx, 0);\n    modelViewBuf.set(viewMtx, 16);\n\n    gl.bindBuffer(gl.UNIFORM_BUFFER, modelViewUbo);\n    gl.bufferSubData(gl.UNIFORM_BUFFER, 0, modelViewBuf);\n}\n\nexport const modelViewUboText = /*glsl*/`\n    layout(std140) uniform ModelViewUbo {\n        uniform mat4 u_model;\n        uniform mat4 u_view;\n    };`;\n","import { base64ToArrayBuffer } from \"@/src/utils/data\";\nimport { Mat4f } from \"@/src/utils/matrix\";\nimport { bindFloatAttribs, createFloatBuffer, createShaderProgram, ensureFloatBufferSize, ensureShadersReady, IFloatBuffer, IGLContext, resetFloatBufferMap, uploadFloatBuffer } from \"@/src/utils/shader\";\nimport { Vec4 } from \"@/src/utils/vector\";\nimport { ISharedRender, modelViewUboText, RenderPhase, UboBindings } from \"./sharedRender\";\n\nexport interface ICharDef {\n    id: number;\n    index: number;\n    char: string;\n    x: number;\n    y: number;\n    width: number;\n    height: number;\n    xoffset: number;\n    yoffset: number;\n    xadvance: number;\n    page: number;\n    chnl: number;\n}\n\nexport interface IKerningDef {\n    first: number;\n    second: number;\n    amount: number;\n}\n\nexport interface IFontCommonDef {\n    lineHeight: number;\n    base: number;\n    scaleW: number;\n    scaleH: number;\n    pages: number;\n    // assume multi-color msdf font\n}\n\nconst floatsPerSegment = 16 + 4;\n\nconst floatsPerVert = 5;\nconst bytesPerVert = floatsPerVert * 4;\n\nconst texWidth = 1024;\n\nexport interface IFontBuffers {\n    atlas: IFontAtlas;\n    vao: WebGLVertexArrayObject;\n    transformTex: WebGLTexture;\n    localTexBuffer: Float32Array;\n    vertBuffer: IFloatBuffer;\n    sharedRender: ISharedRender;\n\n    segmentsUsed: number;\n    segmentCapacity: number;\n    glSegmentCapacity: number;\n}\n\nexport type IFontAtlas = ReturnType<typeof setupFontAtlas>;\n\nexport interface IFontAtlasData {\n    fontAtlasImage: HTMLImageElement;\n    fontDef: any;\n}\n\nexport async function fetchFontAtlasData(): Promise<IFontAtlasData> {\n    let imgEl = document.createElement('img');\n    let imgP = new Promise<HTMLImageElement>((resolve, reject) => {\n        imgEl.onload = () => resolve(imgEl);\n        imgEl.onerror = () => reject();\n    });\n    imgEl.src = 'fonts/font-atlas.png';\n\n    let fontDefP = fetch('fonts/font-def.json', { credentials: 'include', mode: 'no-cors' }).then(r => r.json());\n\n    let [fontAtlasImage, fontDef] = await Promise.all([imgP, fontDefP]);\n\n    return {\n        fontAtlasImage,\n        fontDef,\n    };\n}\n\nexport function setupFontAtlas(ctx: IGLContext, data: IFontAtlasData) {\n    let gl = ctx.gl;\n\n    // With the fontDef, create a char -> glyph lookup\n    // Create a kerning lookup (could use x1 * b + x2 for the keys)\n    let fontDef = data.fontDef;\n\n    let atlasTex = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, atlasTex);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, data.fontAtlasImage);\n\n\n    // See https://github.com/Chlumsky/msdfgen for information on how to implement (this is the format the font atlas is in)\n\n    let program = createShaderProgram(ctx.shaderManager, 'font', /*glsl*/`#version 300 es\n        precision highp float;\n        ${modelViewUboText}\n        uniform sampler2D u_transformTex;\n        layout (location = 0) in vec2 a_position;\n        layout (location = 1) in vec2 a_uv;\n        layout (location = 2) in float a_textId;\n        out vec2 v_uv;\n        out vec4 v_fgColor;\n        out vec4 v_bgColor;\n\n        void main() {\n            int texWidth = textureSize(u_transformTex, 0).x;\n            int texOffset = int(a_textId) * ${floatsPerSegment / 4};\n            int y = texOffset / texWidth;\n            int x = texOffset % texWidth;\n            vec4 t0 = texelFetch(u_transformTex, ivec2(x + 0, y), 0);\n            vec4 t1 = texelFetch(u_transformTex, ivec2(x + 1, y), 0);\n            vec4 t2 = texelFetch(u_transformTex, ivec2(x + 2, y), 0);\n            vec4 t3 = texelFetch(u_transformTex, ivec2(x + 3, y), 0);\n            vec4 c = texelFetch(u_transformTex, ivec2(x + 4, y), 0);\n            mat4 transform = mat4(t0, t1, t2, t3);\n\n            gl_Position = u_view * u_model * transform * vec4(a_position, 0.0, 1.0);\n            v_uv = a_uv;\n            v_fgColor = c;\n            v_bgColor = vec4(0, 0, 0, 0);\n        }\n\n    `, /*glsl*/`#version 300 es\n        precision highp float;\n        uniform sampler2D u_tex;\n        uniform float pxRange; // set to distance field's pixel range\n        in vec2 v_uv;\n        in vec4 v_fgColor;\n        in vec4 v_bgColor;\n        out vec4 color;\n\n        float median(float r, float g, float b) {\n            return max(min(r, g), min(max(r, g), b));\n        }\n\n        float screenPxRange() {\n            vec2 unitRange = vec2(pxRange) / vec2(textureSize(u_tex, 0));\n            vec2 screenTexSize = vec2(1.0) / fwidth(v_uv);\n            return max(0.5*dot(unitRange, screenTexSize), 1.0);\n        }\n\n        void main() {\n            vec3 msd = texture(u_tex, v_uv).rgb;\n            float sd = median(msd.r, msd.g, msd.b);\n            float screenRange = screenPxRange();\n            float screenPxDistance = screenRange*(sd - 0.5);\n            float opacity = clamp(screenPxDistance + 0.5, 0.0, 1.0);\n\n            float blurOpacity = 0.0; //smoothstep(0.5 - 0.4, 0.5, sd);\n\n            if (opacity == 0.0 && blurOpacity == 0.0) {\n                discard;\n            }\n            color = mix(vec4(0,0,0,1.0) * blurOpacity, v_fgColor, opacity);\n        }\n    `, ['u_tex', 'u_transformTex', 'pxRange'], { uboBindings: { 'ModelViewUbo': UboBindings.ModelView } })!;\n\n    ensureShadersReady(ctx.shaderManager);\n\n    let locs = program.locs;\n    gl.useProgram(program.program);\n    gl.uniform1i(locs.u_tex, 0);\n    gl.uniform1i(locs.u_transformTex, 1);\n\n    let faceInfos = [];\n\n    for (let face of fontDef.faces) {\n        let charArr = new Int16Array(base64ToArrayBuffer(face.chars));\n\n        let perCharSize = 12;\n        let numChars = charArr.length / perCharSize;\n\n        let charMap = new Map<string, ICharDef>();\n        let charCodeMap = new Map<number, ICharDef>();\n        let chars: ICharDef[] = [];\n        for (let i = 0; i < numChars; i++) {\n            let offset = i * perCharSize;\n            let char: ICharDef = {\n                id: charArr[offset + 0],\n                index: charArr[offset + 1],\n                char: String.fromCharCode(charArr[offset + 2]),\n                x: charArr[offset + 3],\n                y: charArr[offset + 4],\n                width: charArr[offset + 5],\n                height: charArr[offset + 6],\n                xoffset: charArr[offset + 7],\n                yoffset: charArr[offset + 8],\n                xadvance: charArr[offset + 9],\n                page: charArr[offset + 10],\n                chnl: charArr[offset + 11],\n            };\n            charMap.set(char.char, char);\n            charCodeMap.set(char.id, char);\n            chars.push(char);\n        }\n\n        let kernArr = new Int16Array(base64ToArrayBuffer(face.kernings));\n\n        let perKernSize = 3;\n        let numKerns = kernArr.length / perKernSize;\n\n        let kernMap = new Map<string, number>();\n\n        for (let i = 0; i < numKerns; i++) {\n            let offset = i * perKernSize;\n            let kern = {\n                first: kernArr[offset + 0],\n                second: kernArr[offset + 1],\n                amount: kernArr[offset + 2],\n            };\n            let firstChar = charCodeMap.get(kern.first)!.char;\n            let secondChar = charCodeMap.get(kern.second)!.char;\n            kernMap.set(`${firstChar}${secondChar}`, kern.amount);\n        }\n\n        faceInfos.push({\n            name: face.name,\n            common: face.common as IFontCommonDef,\n            charMap,\n            kernMap,\n        });\n    }\n\n    return {\n        gl,\n        faceInfos,\n        program,\n        atlasTex,\n    };\n}\n\nexport function createFontBuffers(atlas: IFontAtlas, sharedRender: ISharedRender): IFontBuffers {\n    let gl = atlas.gl;\n\n    let segmentCapacity = 1024;\n    let glyphCapacity = 1024;\n\n    let transformTex = gl.createTexture()!;\n    gl.bindTexture(gl.TEXTURE_2D, transformTex);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n\n    // we'll fill it in later\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, texWidth, computeTexHeight(segmentCapacity), 0, gl.RGBA, gl.FLOAT, null);\n\n    let vao = gl.createVertexArray()!;\n    gl.bindVertexArray(vao);\n\n    // Just using 1 buffer for all text for now\n    let vertVbo = gl.createBuffer()!;\n    bindFloatAttribs(gl, vertVbo, {}, [\n        { name: 'a_pos', size: 2 },\n        { name: 'a_uv', size: 2 },\n        { name: 'a_texIndex', size: 1 },\n    ]);\n    let vertBuffer = createFloatBuffer(gl, gl.ARRAY_BUFFER, vertVbo, glyphCapacity, bytesPerVert, sharedRender);\n\n    let localTexBuffer = new Float32Array(segmentCapacity * floatsPerSegment);\n\n    return {\n        atlas,\n        vao,\n        transformTex,\n        vertBuffer,\n        localTexBuffer,\n        segmentsUsed: 0,\n        segmentCapacity: 1024,\n        glSegmentCapacity: 1024,\n        sharedRender,\n    };\n}\n\nexport function computeTexHeight(numSegments: number) {\n    return Math.ceil(numSegments * floatsPerSegment / 4 / texWidth);\n}\n\n // Fudge factor to get it the same as HTML/CSS at the same px size\nlet scaleFudgeFactor = 1.04;\n\nexport function measureTextWidth(fontBuf: IFontBuffers, text: string, scale: number = 1.0, faceName?: string) {\n    let face = faceName ? fontBuf.atlas.faceInfos.find(a => a.name === faceName)! : fontBuf.atlas.faceInfos[0];\n    let x = 0;\n    let prevCodePoint = '';\n    for (let codePoint of text) {\n        let charDef = face.charMap.get(codePoint);\n        if (!charDef) {\n            continue;\n        }\n        let kernKey = `${prevCodePoint}${codePoint}`;\n        let kernAmount = face.kernMap.get(kernKey) || 0;\n        x += kernAmount + charDef.xadvance;\n        prevCodePoint = codePoint;\n    }\n    return x * scale / face.common.lineHeight * scaleFudgeFactor;\n}\n\nexport interface IFontOpts {\n    color: Vec4;\n    size: number;\n    mtx?: Mat4f;\n    faceName?: string;\n}\n\nexport function measureText(fontBuf: IFontBuffers, text: string, opts: IFontOpts) {\n    return measureTextWidth(fontBuf, text, opts.size, opts.faceName);\n}\n\nexport function drawText(fontBuf: IFontBuffers, text: string, dx: number, dy: number, opts: IFontOpts) {\n    writeTextToBuffer(fontBuf, text, opts.color, dx, dy, opts.size, opts.mtx, opts.faceName);\n}\n\nexport function writeTextToBuffer(fontBuf: IFontBuffers, text: string, color: Vec4, dx?: number, dy?: number, scale?: number, mtx?: Mat4f, faceName?: string) {\n    let face = faceName ? fontBuf.atlas.faceInfos.find(a => a.name === faceName)! : fontBuf.atlas.faceInfos[0];\n    if (!face) {\n        face = fontBuf.atlas.faceInfos[0];\n    }\n\n    let phase = fontBuf.sharedRender.activePhase;\n    let vertBuf = fontBuf.vertBuffer.localBufs[phase];\n    ensureFloatBufferSize(vertBuf, text.length * floatsPerVert);\n    if (fontBuf.segmentsUsed === Math.floor(texWidth * 4 / floatsPerSegment)) {\n        // the last segment on each texel row would overflow (it takes 5 texels), so we skip it\n        fontBuf.segmentsUsed += 1;\n    }\n    let segmentId = fontBuf.segmentsUsed;\n    let buf = vertBuf.buf;\n    let bufIdx = vertBuf.usedEls * fontBuf.vertBuffer.strideFloats;\n    let atlasWInv = 1.0 / face.common.scaleW;\n    let atlasHInv = 1.0 / face.common.scaleH;\n    let numGlyphs = 0;\n    let x = dx ?? 0;\n    let y = dy ?? 0;\n    let prevCodePoint = '';\n    scale = scale ?? 1.0;\n    let localScale = scale / face.common.lineHeight * scaleFudgeFactor;\n    for (let codePoint of text) {\n        let charDef = face.charMap.get(codePoint);\n        if (!charDef) {\n            // TODO: Handle missing characters e.g. use a default character\n            continue;\n        }\n        let kernKey = `${prevCodePoint}${codePoint}`;\n        let kernAmount = face.kernMap.get(kernKey) || 0;\n        x += kernAmount * localScale;\n\n        let ux = [charDef.x * atlasWInv, (charDef.x + charDef.width) * atlasWInv];\n        let uy = [charDef.y * atlasHInv, (charDef.y + charDef.height) * atlasHInv];\n\n        let px = [x + charDef.xoffset * localScale, x + (charDef.xoffset + charDef.width) * localScale];\n        let py = [y + charDef.yoffset * localScale, y + (charDef.yoffset + charDef.height) * localScale];\n\n        let tri = [0, 1,  0, 0,  1, 1,  1, 1,  0, 0,  1, 0];\n        for (let i = 0; i < 6; i++) {\n            let ix = tri[i * 2];\n            let iy = tri[i * 2 + 1];\n            buf[bufIdx++] = px[ix];\n            buf[bufIdx++] = py[iy];\n            buf[bufIdx++] = ux[ix];\n            buf[bufIdx++] = uy[iy];\n            buf[bufIdx++] = segmentId;\n        }\n\n        x += charDef.xadvance * localScale;\n\n        prevCodePoint = codePoint;\n        numGlyphs += 1;\n    }\n\n    vertBuf.usedEls += numGlyphs * 6;\n\n    // TODO: Do realloc stuff\n    mtx = mtx ?? new Mat4f();\n    color = color ?? new Vec4(1, 1, 1, 1);\n\n    if (fontBuf.segmentsUsed >= fontBuf.segmentCapacity) {\n        let newCapacity = fontBuf.segmentCapacity * 2;\n        let newBuf = new Float32Array(newCapacity * floatsPerSegment);\n        newBuf.set(fontBuf.localTexBuffer);\n        fontBuf.localTexBuffer = newBuf;\n    }\n\n    fontBuf.localTexBuffer.set(mtx, fontBuf.segmentsUsed * floatsPerSegment + 0);\n    fontBuf.localTexBuffer.set(color.toArray(), fontBuf.segmentsUsed * floatsPerSegment + 16);\n    fontBuf.segmentsUsed += 1;\n}\n\nexport function uploadAllText(fontBuf: IFontBuffers) {\n    let atlas = fontBuf.atlas;\n    let gl = atlas.gl;\n\n    // resize texture if needed\n    gl.bindTexture(gl.TEXTURE_2D, fontBuf.transformTex);\n\n    if (fontBuf.segmentCapacity > fontBuf.glSegmentCapacity) {\n        let w = 1024;\n        let h = Math.ceil(fontBuf.segmentCapacity * floatsPerSegment / 4 / w);\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, w, h, 0, gl.RGBA, gl.FLOAT, null);\n        fontBuf.glSegmentCapacity = w * h / 4;\n    }\n\n    {\n        let w = 1024;\n        let h = Math.ceil(fontBuf.segmentsUsed * floatsPerSegment / 4 / w);\n        gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, w, h, gl.RGBA, gl.FLOAT, fontBuf.localTexBuffer);\n    }\n\n    uploadFloatBuffer(gl, fontBuf.vertBuffer);\n}\n\nexport function renderAllText(fontBuf: IFontBuffers, renderPhase: RenderPhase) {\n    let atlas = fontBuf.atlas;\n    let gl = atlas.gl;\n\n    gl.disable(gl.CULL_FACE);\n    gl.depthMask(false);\n\n    gl.useProgram(atlas.program.program);\n\n    let locs = atlas.program.locs;\n    gl.uniform1f(locs.pxRange, 4);\n\n    gl.activeTexture(gl.TEXTURE0);\n    gl.bindTexture(gl.TEXTURE_2D, atlas.atlasTex);\n    gl.activeTexture(gl.TEXTURE1);\n    gl.bindTexture(gl.TEXTURE_2D, fontBuf.transformTex);\n\n    gl.bindVertexArray(fontBuf.vao);\n    let localBuf = fontBuf.vertBuffer.localBufs[renderPhase];\n    gl.drawArrays(gl.TRIANGLES, localBuf.glOffsetEls, localBuf.usedEls);\n\n    gl.depthMask(true);\n}\n\nexport function resetFontBuffers(fontBuf: IFontBuffers) {\n    resetFloatBufferMap(fontBuf.vertBuffer);\n    fontBuf.segmentsUsed = 0;\n}\n","import { clamp } from \"./data\";\n\nfunction xmur3(str: string) {\n    for(var i = 0, h = 1779033703 ^ str.length; i < str.length; i++)\n        h = Math.imul(h ^ str.charCodeAt(i), 3432918353),\n        h = h << 13 | h >>> 19;\n    return function() {\n        h = Math.imul(h ^ h >>> 16, 2246822507),\n        h = Math.imul(h ^ h >>> 13, 3266489909);\n        return (h ^= h >>> 16) >>> 0;\n    }\n}\n\nfunction sfc32(a: number, b: number, c: number, d: number) {\n    return function() {\n      a >>>= 0; b >>>= 0; c >>>= 0; d >>>= 0;\n      var t = (a + b) | 0;\n      a = b ^ b >>> 9;\n      b = c + (c << 3) | 0;\n      c = (c << 21 | c >>> 11);\n      d = d + 1 | 0;\n      t = t + d | 0;\n      c = c + t | 0;\n      return (t >>> 0) / 4294967296;\n    }\n}\n\nexport type UniformDistGenerator = () => number;\n\nfunction randomGen(seed?: string): UniformDistGenerator {\n    let seeder = xmur3(seed ?? Math.random().toString());\n    return sfc32(seeder(), seeder(), seeder(), seeder());\n}\n\nexport class Random {\n    constructor(seed?: number) {\n        this.random = randomGen(seed?.toString());\n    }\n\n    random: UniformDistGenerator;\n\n    normal = () => {\n        let x = this.random();\n        let y = this.random();\n        return Math.sqrt(-2 * Math.log(x)) * Math.cos(2 * Math.PI * y);\n    }\n\n    randint(min: number, max: number): number {\n        return clamp(Math.floor(this.random() * (max - min) + min), min, max - 1);\n    }\n}\n\n","import { base64ToArrayBuffer } from \"./data\";\n\nexport interface ITensorJson {\n    shape: number[];\n    dtype: string; // 'torch.float32', 'torch.int32', etc\n    data: string // base64 encoded (using python's base64.b64encode)\n}\n\n// more gpt related than tensor related\nexport type ITensorSet = Record<string, TensorF32> & { 'config': IGptModelConfig };\n\nexport interface IGptModelConfig {\n    model_type: string;\n    n_layer: number;\n    n_head: number;\n    n_embd: number;\n\n    vocab_size: number;\n    block_size: number;\n\n    B?: number;\n}\n\n// Just support float32 for now, cuz we're lazy\nexport class TensorF32 {\n    isContiguous: boolean;\n    constructor(\n        public readonly shape: number[],\n        public readonly buffer: Float32Array,\n        public readonly stride: number[] = [],\n    ) {\n        let totalEls = shape.reduce((a, b) => a * b, 1);\n        if (totalEls > buffer.length) {\n            throw new Error(`Shape ${shape.join(', ')} requires ${totalEls} buffer, but buffer has size ${buffer.length}`);\n        }\n\n        let strideContiguous = new Array(shape.length);\n        let s = 1;\n        for (let i = shape.length - 1; i >= 0; i--) {\n            strideContiguous[i] = s;\n            s *= shape[i];\n        }\n\n        if (stride.length === 0) {\n            this.stride = strideContiguous;\n        } else if (stride.length !== shape.length) {\n            throw new Error(`Stride length ${stride.length} does not match shape length ${shape.length}`);\n        }\n\n        this.isContiguous = true;\n        for (let i = 0; i < stride.length; i++) {\n            if (stride[i] !== strideContiguous[i]) {\n                this.isContiguous = false;\n                break;\n            }\n        }\n    }\n\n    view(shape: number[]) {\n        let size = shape.reduce((a, b) => a * b, 1);\n        let existingSize = this.shape.reduce((a, b) => a * b, 1);\n        if (size !== existingSize) {\n            throw new Error(`Invalid reshape: new size ${size} (${shape.join(', ')}) does not match existing size ${existingSize} (${this.shape.join(', ')})`);\n        }\n        if (!this.isContiguous) {\n            throw new Error(`Cannot view non-contiguous tensor (or at least, there are potential cases where it would work, but we don't support them yet)`);\n        }\n        return new TensorF32(shape, this.buffer);\n    }\n\n    transpose(a: number, b: number) {\n        if (a < 0 || a >= this.shape.length || b < 0 || b >= this.shape.length || a === b) {\n            throw new Error(`Invalid transpose indices: ${a}, ${b} over shape ${this.shape.join(', ')}`);\n        }\n        let shape = [...this.shape];\n        let stride = [...this.stride];\n        let temp = shape[a]; shape[a] = shape[b]; shape[b] = temp;\n        let temp2 = stride[a]; stride[a] = stride[b]; stride[b] = temp2;\n        return new TensorF32(shape, this.buffer, stride);\n    }\n\n    permute(...axes: number[]) {\n        let setItems = new Set(new Array(this.shape.length).fill(0).map((_, i) => i));\n        axes.forEach(a => setItems.delete(a));\n        if (axes.length !== this.shape.length || setItems.size !== 0) {\n            throw new Error(`Invalid permute axes: ${axes.join(', ')} over shape ${this.shape.join(', ')}`);\n        }\n\n        let shape = axes.map(a => this.shape[a]);\n        let stride = axes.map(a => this.stride[a]);\n        return new TensorF32(shape, this.buffer, stride);\n    }\n\n    g(index: number[]) {\n        return this.buffer[this.indexToOffset(index)];\n    }\n\n    s(index: number[], a: number) {\n        this.buffer[this.indexToOffset(index)] = a;\n    }\n\n    indexToOffset(index: number[]) {\n        if (index.length !== this.shape.length) {\n            throw new Error(`Index length ${index.length} does not match shape length ${this.shape.length}`);\n        }\n        let offset = 0;\n        for (let i = 0; i < index.length; i++) {\n            if (index[i] >= this.shape[i]) {\n                throw new Error(`Index ${index[i]} out of bounds for shape ${this.shape[i]}`);\n            }\n            offset += index[i] * this.stride[i];\n        }\n        return offset;\n    }\n\n    *indexIterator(): Generator<number[]> {\n        // returns an iterator that returns the index of each element, where the index is an array\n        let index = new Array(this.shape.length).fill(0);\n        while (true) {\n            yield index;\n            let i = this.shape.length - 1;\n            while (i >= 0) {\n                index[i]++;\n                if (index[i] < this.shape[i]) {\n                    break;\n                }\n                index[i] = 0;\n                i--;\n            }\n            if (i < 0) {\n                break;\n            }\n        }\n    }\n\n    contiguous() {\n        if (this.isContiguous) {\n            return this;\n        }\n        return new TensorF32(this.shape, this.toFloat32Array());\n    }\n\n    // always returns a copy of a contiguous array\n    toFloat32Array() {\n        let size = this.shape.reduce((a, b) => a * b, 1);\n        let array = new Float32Array(size);\n\n        if (this.isContiguous) {\n            array.set(this.buffer);\n        } else {\n            let index = new Array(this.shape.length).fill(0);\n            let destIdx = 0;\n            let offset = 0;\n            while (true) {\n                array[destIdx++] = this.buffer[offset];\n                let i = this.shape.length - 1;\n                while (i >= 0) {\n                    index[i]++;\n                    offset += this.stride[i];\n                    if (index[i] < this.shape[i]) {\n                        break;\n                    }\n                    offset -= index[i] * this.stride[i];\n                    index[i] = 0;\n                    i--;\n                }\n                if (i < 0) {\n                    break;\n                }\n            }\n        }\n        return array;\n    }\n\n    static fromJson(obj: ITensorJson) {\n        if (!obj.shape || !obj.dtype || !obj.data) {\n            console.error('Invalid tensor json', obj);\n            throw new Error('Invalid tensor json');\n        }\n        if (obj.dtype !== 'torch.float32') {\n            console.error('Invalid tensor dtype', obj);\n            throw new Error('Invalid tensor dtype');\n        }\n        let buf = base64ToArrayBuffer(obj.data);\n        let array = new Float32Array(buf);\n        return new TensorF32(obj.shape, array);\n    }\n\n    copyFrom(source: TensorF32) {\n        if (source.shape.length !== this.shape.length || !source.contiguous || !this.contiguous) {\n            throw new Error(`Invalid copy: source shape length ${source.shape.length} does not match target shape length ${this.shape.length}`);\n        }\n        for (let i = 0; i < this.shape.length; i++) {\n            if (source.shape[i] !== this.shape[i]) {\n                throw new Error(`Invalid copy: source shape ${source.shape[i]} does not match target shape ${this.shape[i]}`);\n            }\n        }\n        this.buffer.set(source.buffer);\n    }\n}\n\nfunction test() {\n    let tensor = new TensorF32([2, 3], new Float32Array([1, 2, 3, 4, 5, 6]));\n\n    // expected output: [0, 0], [0, 1], [0, 2], [1, 0], [1, 1], [1, 2]\n    for (let index of tensor.indexIterator()) {\n        console.log(index, tensor.g(index));\n    }\n}\n\n// test();\n","import { useEffect, useReducer, useRef, useState } from \"react\";\n\nexport function useFunctionRef<T extends ((...args: any[]) => any) | undefined>(fn: T): React.MutableRefObject<T> {\n    let ref = useRef<T>(fn);\n    useEffect(() => {\n        ref.current = fn;\n    }, [fn]);\n    return ref;\n}\n\nexport function useRequestAnimationFrame(active: boolean, cb: (dt: number) => void) {\n    let cbRef = useFunctionRef(cb);\n    useEffect(() => {\n        let stale = false;\n        let handle: number;\n        let prevTime: number | undefined;\n\n        function loop(time: number) {\n            let dt = (prevTime === undefined ? 16 : (time - prevTime)) / 1000;\n            prevTime = time;\n            cbRef.current(dt);\n            if (!stale) {\n                handle = requestAnimationFrame(loop);\n            }\n        }\n\n        if (active) {\n            handle = requestAnimationFrame(loop);\n            return () => {\n                stale = true;\n                cancelAnimationFrame(handle);\n            };\n        }\n    }, [active, cbRef]);\n}\n\nexport interface IIntervalOptions {\n    // run the callback immediately on mount\n    runImmediately?: boolean;\n}\n\nexport function useInterval(active: boolean, delay: number, cb: () => void, opts?: IIntervalOptions) {\n    let cbRef = useFunctionRef(cb);\n    let runImmediately = opts?.runImmediately ?? false;\n    useEffect(() => {\n        if (active) {\n            let handle = setInterval(cbRef.current, delay);\n            if (runImmediately) {\n                cbRef.current();\n            }\n            return () => clearInterval(handle);\n        }\n    }, [active, delay, cbRef, runImmediately]);\n}\n\nexport function logChangesFn(name: string) {\n    let prevValue: any = null;\n    return (currValue: any) => {\n        let changes = getChanges(prevValue, currValue);\n        prevValue = currValue;\n        changes && console.log(`${name} changed to`, changes);\n        return !!changes;\n    };\n\n    function getChanges(a: any, b: any) {\n        a = a || {};\n        b = b || {};\n        let keys = new Set<string>();\n        for (let k of [...Object.keys(a), ...Object.keys(b)]) {\n            a[k] !== b[k] && keys.add(k);\n        }\n        if (keys.size === 0) {\n            return null;\n        }\n        let changed: any = {};\n        for (let k of [...keys]) {\n            changed[k] = b[k];\n        }\n        return changed;\n    }\n}\n\nexport function useLogChanges(name: string, values: any) {\n    let [changesFn] = useState(() => logChangesFn(name));\n    return changesFn(values);\n}\n\n\nexport class Subscriptions {\n    subs = new Set<() => void>();\n    subscribe = (fn: () => void): (() => void) => {\n        this.subs.add(fn);\n        return () => this.subs.delete(fn);\n    }\n    notify = () => {\n        for (let sub of this.subs) {\n            sub();\n        }\n    }\n}\n\nexport function useSubscriptions(subscription: Subscriptions | null) {\n    let [, refresh] = useReducer(a => a + 1, 0);\n    useEffect(() => subscription?.subscribe(refresh), [subscription]);\n}\n","import { useCallback, useEffect, useRef, useState } from \"react\";\nimport { useFunctionRef } from \"./hooks\";\n\nexport interface IDragStart<T> {\n    clientX: number;\n    clientY: number;\n    data: T;\n    button: number;\n    buttons: number;\n    shiftKey: boolean;\n    altKey: boolean;\n    metaKey: boolean;\n    ctrlKey: boolean;\n}\n\nexport function useGlobalDrag<T>(\n    handleMove: (ev: MouseEvent, ds: IDragStart<T>, end: boolean) => void,\n    handleClick?: (ev: MouseEvent, ds: IDragStart<T>) => void,\n    handleMoveEnd?: (ev: MouseEvent, ds: IDragStart<T>, end: boolean) => void,\n): [IDragStart<T> | null, (ev: IMouseEvent, data: T) => void] {\n    let [dragStart, setDragStart] = useState<IDragStart<T> | null>(null);\n    let isDragging = useRef(false);\n    let handleMoveRef = useFunctionRef(handleMove);\n    let handleClickRef = useFunctionRef(handleClick);\n    let handleMoveEndRef = useFunctionRef(handleMoveEnd);\n\n    useEffect(() => {\n        if (!dragStart) {\n            isDragging.current = false;\n            return;\n        }\n\n        function dist(ev1: { clientX: number, clientY: number }, ev2: { clientX: number, clientY: number }) {\n            let dx = ev2.clientX - ev1.clientX;\n            let dy = ev2.clientY - ev1.clientY;\n            return dx * dx + dy * dy;\n        }\n\n        function handleMouseMove(ev: MouseEvent) {\n            if (!isDragging.current && (dist(ev, dragStart!) > 10.0 || !handleClickRef.current)) {\n                isDragging.current = true;\n            }\n            if (isDragging.current) {\n                handleMoveRef.current(ev, dragStart!, false);\n            }\n        }\n\n        function handleMouseUp(ev: MouseEvent) {\n            if (isDragging.current || !handleClickRef.current) {\n                handleMoveRef.current(ev, dragStart!, true);\n                handleMoveEndRef.current?.(ev, dragStart!, true);\n            } else {\n                handleClickRef.current?.(ev, dragStart!);\n            }\n            setDragStart(null);\n        }\n\n        document.addEventListener('mousemove', handleMouseMove, { capture: true });\n        document.addEventListener('mouseup', handleMouseUp, { capture: true });\n        return () => {\n            document.removeEventListener('mousemove', handleMouseMove, { capture: true });\n            document.removeEventListener('mouseup', handleMouseUp, { capture: true });\n        };\n    }, [dragStart, handleMoveRef, handleClickRef, handleMoveEndRef]);\n\n    let setDragStartTarget = useCallback((ev: IMouseEvent, data: T) => {\n        setDragStart({\n            clientX: ev.clientX,\n            clientY: ev.clientY,\n            data,\n            button: ev.button,\n            buttons: ev.buttons,\n            shiftKey: ev.shiftKey,\n            altKey: ev.altKey,\n            ctrlKey: ev.ctrlKey,\n            metaKey: ev.metaKey,\n        });\n    }, [setDragStart]);\n\n    return [dragStart, setDragStartTarget];\n}\n\nexport interface IMouseLocation {\n    clientX: number;\n    clientY: number;\n}\n\nexport interface IPointerEvent {\n    clientX: number;\n    clientY: number;\n}\n\nexport interface IMouseEvent extends IPointerEvent {\n    type: string;\n    readonly button: number;\n    readonly buttons: number;\n    readonly shiftKey: boolean;\n    readonly altKey: boolean;\n    readonly ctrlKey: boolean;\n    readonly metaKey: boolean;\n    stopPropagation(): void;\n    preventDefault(): void;\n}\n\nexport interface IWheelEvent extends IMouseEvent {\n    deltaMode: number;\n    deltaY: number;\n}\n\nexport interface IBaseEvent {\n    type: string;\n    stopPropagation(): void;\n    preventDefault(): void;\n}\n\nexport function getWheelDelta(ev: IWheelEvent): number {\n    let mode = ev.deltaMode;\n    let scale = 1.0;\n    if (mode === 0) { // pixel\n        scale = 125;\n    } else if (mode === 1) { // line\n        scale = 3;\n    } else if (mode === 2) { // page\n        scale = 0.1;\n    }\n\n    return ev.deltaY / scale;\n}\n\nexport interface TouchSimple {\n    clientX: number;\n    clientY: number;\n}\n\nexport interface TouchEventStart<T> {\n    data: T;\n    touches: TouchSimple[];\n}\n\nexport interface TouchEventStart1PointDrag<T> extends TouchEventStart<T> {\n    isDragging: boolean;\n}\n\nexport interface ITouchEventOptions {\n    alwaysSendDragEvent?: boolean;\n    sendDragEnd?: boolean;\n}\n\nexport function useTouchEvents<T>(\n    el: GlobalEventHandlers | null,\n    data: T,\n    options: ITouchEventOptions,\n    handle1PointDrag?: (ev: TouchEvent, start: TouchEventStart1PointDrag<T>, end: boolean) => void,\n    handle2PointDrag?: (ev: TouchEvent, start: TouchEventStart<T>) => void,\n    handle1PointClick?: (ev: TouchEvent, start: TouchEventStart<T>) => void,\n) {\n    let alwaysSendDragEvent = options.alwaysSendDragEvent ?? false;\n    let sendDragEnd = options.sendDragEnd ?? false;\n    let initialData = useRef<T>(data);\n    let initialTouches = useRef<TouchSimple[]>();\n    let lastTouch = useRef<{ time: number, velocity: number, touch: TouchSimple } | null>(null);\n    let isDrag = useRef<boolean>(false);\n    let latestData = useRef<T>(data);\n    let lastPressTime = useRef<number>(0);\n    latestData.current = data;\n    let handle1PointDragRef = useFunctionRef(handle1PointDrag);\n    let handle2PointDragRef = useFunctionRef(handle2PointDrag);\n    let handle1PointClickRef = useFunctionRef(handle1PointClick);\n\n    useEffect(() => {\n        if (!el) {\n            return;\n        }\n\n        function sendEvent(ev: TouchEvent) {\n            let initial = {data: initialData.current, touches: initialTouches.current!};\n            if (!ev.touches || !initial.touches || ev.touches.length !== initial.touches.length) {\n                return;\n            }\n\n            if (!isDrag.current) {\n                if (ev.touches.length > 1 || (ev.touches.length === 1 && touchPixelDist(ev.touches[0], initial.touches[0]) >= 10)) {\n                    isDrag.current = true;\n                }\n            }\n\n            if (ev.touches.length === 1 && handle1PointDragRef.current && (alwaysSendDragEvent || isDrag.current)) {\n                handle1PointDragRef.current(ev, { ...initial, isDragging: isDrag.current }, false);\n            }\n            if (ev.touches.length === 2 && handle2PointDragRef.current) {\n                handle2PointDragRef.current(ev, initial);\n            }\n\n            if (ev.touches.length === 1) {\n                lastTouch.current = {\n                    time: 0,\n                    velocity: 0,\n                    touch: copyTouchList(ev.touches)[0],\n                };\n\n            } else {\n                lastTouch.current = null;\n            }\n        }\n\n        function captureInitialAndSend(ev: TouchEvent) {\n            let prevTouches = initialTouches.current;\n            let prevData = initialData.current;\n            initialData.current = latestData.current;\n            initialTouches.current = copyTouchList(ev.touches as any);\n\n            if (!prevTouches || !prevTouches.length) {\n                lastPressTime.current = performance.now();\n            }\n\n            let lastTouchTouch = lastTouch.current?.touch;\n\n            sendEvent(ev);\n\n            if (ev.touches.length === 0) {\n                if (sendDragEnd && handle1PointDragRef.current && lastTouchTouch && (isDrag.current || alwaysSendDragEvent)) {\n                    ev = cloneTouchEvent(ev, { touches: [lastTouchTouch] as any });\n                    handle1PointDragRef.current(ev, { data: prevData, touches: prevTouches!, isDragging: isDrag.current }, true);\n                }\n                if (!isDrag.current && handle1PointClickRef.current && prevTouches?.length === 1) {\n                    handle1PointClickRef.current(ev, {data: prevData, touches: prevTouches!});\n                }\n                isDrag.current = false;\n                lastTouch.current = null;\n            }\n        }\n\n        el.addEventListener('touchstart', captureInitialAndSend, { passive: false });\n        el.addEventListener('touchend', captureInitialAndSend, { passive: false });\n        el.addEventListener('touchcancel', captureInitialAndSend, { passive: false });\n        el.addEventListener('touchmove', sendEvent, { passive: false });\n        return () => {\n            el.removeEventListener('touchstart', captureInitialAndSend);\n            el.removeEventListener('touchend', captureInitialAndSend);\n            el.removeEventListener('touchcancel', captureInitialAndSend);\n            el.removeEventListener('touchmove', sendEvent);\n        };\n    }, [el, handle1PointDragRef, handle2PointDragRef, handle1PointClickRef, alwaysSendDragEvent, sendDragEnd]);\n}\n\nexport function copyTouchList(tl: TouchList) {\n    let res: TouchSimple[] = [];\n    for (let i = 0; i < tl.length; i++) {\n        let touch = tl[i];\n        res.push({ clientX: touch.clientX, clientY: touch.clientY });\n    }\n    return res;\n}\n\nfunction touchPixelDist(a: TouchSimple, b: TouchSimple) {\n    let dx = b.clientX - a.clientX;\n    let dy = b.clientY - a.clientY;\n    return Math.sqrt(dx * dx + dy * dy);\n}\n\n\nexport function useCombinedMouseTouchDrag<T>(\n    el: GlobalEventHandlers | null,\n    captureDragStart: (ev: IMouseEvent) => T,\n    handleDrag: (ev: IMouseEvent, start: IDragStart<T>, end: boolean) => void,\n    handleClick?: (ev: IMouseEvent, start: IDragStart<T>) => void,\n): [dragStart: IDragStart<T> | null, setDragStart: (ev: IMouseEvent) => void] {\n    let [touchDragStart, setTouchDragStart] = useState<IDragStart<T> | null>(null);\n\n    let captureDragStartRef = useFunctionRef(captureDragStart);\n    function handleMouseDrag(ev: MouseEvent, ds: IDragStart<T>, end: boolean) {\n        handleDrag(ev, ds, end);\n    }\n\n    function handleMouseClick(ev: MouseEvent, ds: IDragStart<T>) {\n        handleClick?.(ev, ds);\n    }\n\n    useTouchEvents(el, 0, { alwaysSendDragEvent: true, sendDragEnd: true }, function handle1PointDrag(ev, ds, end) {\n        let mouseEvent = mouseEventFromEventAndSingleTouch(ev, ev.touches[0]);\n        let dragStart = touchDragStart;\n        if (!dragStart) {\n            let dragStartData = captureDragStart(mouseEvent);\n            dragStart = { ...extractClientPosFromTouch(ds.touches[0]), data: dragStartData };\n            setTouchDragStart(dragStart);\n        }\n\n        if (!ds.isDragging) {\n            return;\n        }\n\n        handleDrag(mouseEvent, dragStart, end);\n\n        if (end) {\n            setTouchDragStart(null);\n        }\n\n    }, undefined, function handle1PointClick(ev, ds) {\n        if (touchDragStart) {\n            handleClick?.(mouseEventFromEventAndSingleTouch(ev, ev.touches[0]), touchDragStart);\n        }\n        setTouchDragStart(null);\n    });\n\n    let [dragStart, setDragStartLocal] = useGlobalDrag<T>(handleMouseDrag, handleClick ? handleMouseClick : undefined);\n\n    let setDragStart = useCallback((ev: IMouseEvent) => {\n        let data = captureDragStartRef.current(ev);\n        setDragStartLocal(ev, data);\n    }, [setDragStartLocal, captureDragStartRef]);\n\n    return [dragStart ?? touchDragStart, setDragStart];\n}\n\nfunction cloneTouchEvent<T extends {}>(ev: TouchEvent, extra: T): TouchEvent & T & { button: -1, buttons: 0 } {\n    return {\n        ...ev,\n        preventDefault: () => ev.preventDefault(),\n        stopPropagation: () => ev.stopPropagation(),\n        ...extra,\n        button: -1,\n        buttons: 0,\n    };\n}\n\nfunction mouseEventFromEventAndSingleTouch(ev: TouchEvent, touch: TouchSimple): TouchEvent & IMouseEvent {\n    return cloneTouchEvent(ev, extractClientPosFromTouch(touch));\n}\n\nfunction extractClientPosFromTouch(touch: TouchSimple) {\n    // creates a mouse event compatible with mouse drags\n    return {\n        clientX: touch.clientX,\n        clientY: touch.clientY,\n        shiftKey: false,\n        altKey: false,\n        ctrlKey: false,\n        metaKey: false,\n        button: -1,\n        buttons: 0,\n     };\n}\n","import { IBlkDef, IGptModelLayout } from \"../GptModelLayout\";\nimport { IRenderState } from \"../render/modelRender\";\nimport { clamp } from \"@/src/utils/data\";\nimport { measureTextWidth } from \"../render/fontRender\";\nimport { Vec3, Vec4 } from \"@/src/utils/vector\";\nimport { IWalkthrough, Phase, PhaseGroup } from \"./Walkthrough\";\nimport { IProgramState } from \"../Program\";\nimport { ICameraPos } from \"../Camera\";\n\nexport interface IWalkthroughArgs {\n    state: IProgramState;\n    layout: IGptModelLayout;\n    walkthrough: IWalkthrough;\n    tools: ReturnType<typeof phaseTools>;\n}\n\nexport function embed(fc: React.FC) {\n    return { insert: () => fc };\n}\n\nexport function phaseTools(state: IProgramState) {\n    let phaseState = state.walkthrough;\n\n    function c_str(str: string, duration: number = 0.3, style: DimStyle = DimStyle.T) {\n        return { str, duration, start: 0, t: 0.0, color: dimStyleColor(style) };\n    }\n\n    function c_blockRef(str: string, blk: IBlkDef | IBlkDef[], style?: DimStyle) {\n        let firstBlk = Array.isArray(blk) ? blk[0] : blk;\n        style ??= firstBlk.t === 'i' ? DimStyle.Intermediates : firstBlk.t === \"w\" ? DimStyle.Weights : DimStyle.Aggregates;\n        return { str, duration: 0, start: 0, t: 0.0, color: dimStyleColor(style), blk };\n    }\n\n    function c_dimRef(str: string, style: DimStyle) {\n        return { str, duration: 0, start: 0, t: 0.0, color: dimStyleColor(style), dim: style };\n    }\n\n    function atTime(start: number, duration?: number, wait?: number): ITimeInfo {\n        return createAtTime(phaseState, start, duration, wait);\n    }\n\n    function atEvent(evt: { str: string, duration: number, t: number, start: number }): ITimeInfo {\n        return atTime(evt.start, evt.duration);\n    }\n\n    function afterTime(prev: ITimeInfo | null, duration: number, wait?: number): ITimeInfo {\n        prev = prev ?? phaseState.times[phaseState.times.length - 1];\n        return atTime(prev.start + prev.duration + prev.wait, duration, wait);\n    }\n\n    function cleanup(t: ITimeInfo, times: ITimeInfo[] = phaseState.times) {\n        if (t.t > 0.0) {\n            for (let prevTime of times) {\n                prevTime.t = 1.0 - t.t;\n                if (t.t >= 1.0) {\n                    prevTime.active = false;\n                }\n            }\n        }\n    }\n\n    function breakAfter(evt?: ITimeInfo) {\n        evt = evt ?? phaseState.times[phaseState.times.length - 1];\n        if (!evt) {\n            return;\n        }\n        let breakEvt = afterTime(evt, 0.001);\n        if (phaseState.running && phaseState.time - phaseState.dt < breakEvt.start && phaseState.time >= breakEvt.start) {\n            phaseState.running = false;\n            phaseState.speed = 1.0;\n            phaseState.time = breakEvt.start + breakEvt.duration;\n        }\n        breakEvt.isBreak = true;\n    }\n\n    function commentary(stringsArr: TemplateStringsArray, ...values: any[]) {\n        return writeCommentary(state, null, stringsArr, ...values);\n    }\n\n    function commentaryPara(c: ICommentaryRes) {\n        return (stringsArr: TemplateStringsArray, ...values: any[]) => {\n            return writeCommentary(state, c, stringsArr, ...values);\n        };\n    }\n\n    return { atTime, atEvent, afterTime, cleanup, commentary, commentaryPara, c_str, c_blockRef, c_dimRef, breakAfter };\n}\n\nfunction createAtTime(wt: IWalkthrough, start: number, duration?: number, wait?: number): ITimeInfo {\n    duration = duration ?? 0;\n    wait = wait ?? 0;\n    let info: ITimeInfo = {\n        name: '',\n        start,\n        duration,\n        wait,\n        t: duration === 0 ? (wt.time > start ? 1 : 0) : clamp((wt.time - start) / duration, 0, 1),\n        active: wt.time > start,\n    };\n    wt.times.push(info);\n    wt.phaseLength = Math.max(wt.phaseLength, start + duration + wait);\n    return info;\n}\n\nexport function eventEndTime(evt: ITimeInfo) {\n    return evt.start + evt.duration + evt.wait;\n}\n\nexport interface ICommentary extends ITimeInfo {\n    strings: TemplateStringsArray;\n    values: any[];\n}\n\nexport function isCommentary(evt: ITimeInfo): evt is ICommentary {\n    return 'strings' in evt;\n}\n\nexport function commentary(wt: IWalkthrough, prev?: ITimeInfo | null, duration?: number) {\n    return (stringsArr: TemplateStringsArray, ...values: any[]): ICommentary => {\n        let t = 0;\n        prev = prev ?? wt.times[wt.times.length - 1];\n\n        if (prev) {\n            t = prev.start + prev.duration + prev.wait;\n        }\n\n        let commentaryT = createAtTime(wt, prev ? eventEndTime(prev) : 0, duration ?? 0.2);\n\n        let res: ICommentary = {\n            ...commentaryT,\n            strings: stringsArr,\n            values,\n        };\n\n        wt.times[wt.times.length - 1] = res; // replace the time info with the commentary\n\n        return res;\n    }\n}\n\nexport function writeCommentary(state: IProgramState, prev: ICommentaryRes | null, stringsArrRaw: TemplateStringsArray, ...values: any[]): ICommentaryRes {\n    let t = prev?.duration ?? 0;\n    let colNum = 0;\n    let fontSize = 17;\n    let maxWidth = 500;\n    let charsPerSecond = 400;\n    let lineHeight = fontSize * 1.2;\n\n    let lineOffset = prev ? prev.lineOffset + lineHeight * 1.5 : 10;\n    let stringsArr = stringsArrRaw.map(s => s.replace(/([ \\n])+/g, ' '));\n\n    for (let i = 0; i < values.length + 1; i++) {\n        let str = stringsArr[i];\n\n        t += str.length / charsPerSecond;\n\n        if (i < values.length && 't' in values[i]) {\n            // calculate the t value of this point\n            values[i].start = t;\n            t += values[i].duration;\n        }\n    }\n\n    let targetT = state.walkthrough.time;\n\n    function writeWord(str: string, tStart: number, tEnd: number, colOverride?: Vec4, fontOverride?: string) {\n\n        while (str.startsWith('\\n\\n')) {\n            lineOffset += lineHeight;\n            colNum = 0;\n            str = str.substring(2);\n        }\n        str = str.replace(/([ \\n])+/g, ' ');\n\n        let strToDraw = str;\n        let nextOff = 0;\n        let w = measureTextWidth(state.render.modelFontBuf, str, fontSize);\n        if (colNum + w > maxWidth) {\n            lineOffset += lineHeight;\n            colNum = 0;\n            strToDraw = str.trimStart();\n            w = measureTextWidth(state.render.modelFontBuf, strToDraw, fontSize);\n            if (w > maxWidth) {\n                // ignore for now; single word longer than line: should break at the character level\n            }\n            nextOff = w;\n        } else {\n            nextOff = colNum + w;\n        }\n\n        let color = new Vec4(0.5, 0.5, 0.5, 1).mul(0.5);\n        if (targetT > tStart) {\n            let targetColor = colOverride ?? new Vec4(0.1, 0.1, 0.1, 1);\n            // lerp is 0 at tStart, 1 at tEnd\n            let x = clamp((targetT - tStart) / (tEnd - tStart), 0, 1);\n            color = Vec4.lerp(color, targetColor, x);\n        }\n        // writeTextToBuffer(state.overlayFontBuf, strToDraw, color, 10 + colNum, lineOffset, fontSize, undefined, fontOverride);\n\n        colNum = nextOff;\n    }\n\n    t = prev?.duration ?? 0;\n    for (let i = 0; i < values.length + 1; i++) {\n        let words = stringsArr[i].split(/(?=[ \\n]+)/).filter(a => a !== ' ');\n\n        for (let word of words) {\n            let tEnd = t + word.length / charsPerSecond;\n            writeWord(word, t, tEnd);\n            t = tEnd;\n        }\n\n        if (i < values.length && 't' in values[i]) {\n            let val = values[i];\n            // calculate the t value of this point\n            val.start = t;\n            writeWord(values[i].str, t, val.color, val.fontFace);\n            t += val.duration;\n        }\n    }\n\n    let commentryT = createAtTime(state.walkthrough, 0, t, 0);\n\n    let res: ICommentaryRes = {\n        ...commentryT,\n        stringsArr: stringsArrRaw,\n        values,\n        lineOffset,\n        colNum,\n        commentaryList: [],\n    };\n    res.commentaryList = [res];\n\n    if (prev) {\n        prev.lineOffset = lineOffset;\n        prev.colNum = colNum;\n        prev.duration = t;\n        prev.commentaryList = [...prev.commentaryList, res];\n    } else {\n        state.walkthrough.commentary = res;\n    }\n\n    return res;\n}\n\nexport interface ICommentaryRes extends ITimeInfo {\n    stringsArr: TemplateStringsArray;\n    values: any[];\n    commentaryList: ICommentaryRes[];\n    duration: number;\n    lineOffset: number;\n    colNum: number;\n}\n\nexport interface ITimeInfo {\n    name: string;\n    start: number;\n    duration: number;\n    wait: number;\n\n    // will change over the course of a phase: used to lerp\n    t: number; // 0 - 1\n    active: boolean;\n\n    isBreak?: boolean;\n}\n\nfunction getPhaseTransitiveData(wt: IWalkthrough) {\n    wt.phaseTransitiveData ??= {};\n    return wt.phaseTransitiveData;\n}\n\nexport function setInitialCamera(state: IProgramState, target: Vec3, rot: Vec3) {\n    let wt = state.walkthrough;\n    wt.cameraInitial = { angle: rot, center: target };\n\n    let data = getPhaseTransitiveData(wt);\n\n    if (wt.time === 0) {\n        data.cameraSrc ??= { angle: state.camera.angle, center: state.camera.center };\n        data.cameraT ??= 0;\n\n        if (data.cameraT < 1) {\n            let src = data.cameraSrc;\n            let dest = wt.cameraInitial;\n            let t = data.cameraT;\n            state.camera.angle = src.angle.lerp(dest.angle, t);\n            state.camera.center = src.center.lerp(dest.center, t);\n\n            data.cameraT = t + wt.viewDt / 1000 * 1.5;\n            wt.markDirty();\n        }\n    }\n}\n\nexport function moveCameraTo(state: IProgramState, time: ITimeInfo, target: Vec3, rot: Vec3) {\n\n    let wt = state.walkthrough;\n    let phaseData = wt.phaseData.get(wt.phase);\n    if (!phaseData) {\n        wt.phaseData.set(wt.phase, phaseData = { cameraData: null });\n    }\n    if (!phaseData.cameraData) {\n        phaseData.cameraData = new Map<number, ICameraPos>();\n    }\n\n    let prevTime = [...phaseData.cameraData.entries()].filter(([t, _]) => t < time.start).pop()?.[1];\n\n    let camData = phaseData.cameraData.get(time.start);\n    if (!camData) {\n         phaseData.cameraData.set(time.start, camData = {\n            initialCaptured: prevTime ? undefined : wt.cameraInitial ?? {\n                angle: state.camera.angle,\n                center: state.camera.center,\n            },\n            target: { angle: rot, center: target },\n        });\n    }\n\n    // if we transition from before the ITimeInfo to the start of it, we capture the camera position\n    // we store the camera position in a map, keyed by the ITimeInfo name\n    // then we can use that position to lerp from its initial value to the target values\n\n\n    // if we don't get to the start via running (e.g. clicking on a link), we use the camera position\n    // of the last moveCameraTo call (so need to keep track of that!)\n\n    // if (wt.running && wt.time - wt.dt < time.start && wt.time >= time.start && !prevTime && !camData.initialCaptured) {\n    //     camData.initialCaptured = {\n    //         angle: state.camera.angle,\n    //         center: state.camera.center,\n    //     };\n    // }\n\n    let src = prevTime?.target ?? wt.cameraInitial ?? camData.initialCaptured;\n\n    let dest: ICameraPos = {\n        center: target,\n        angle: rot,\n    };\n\n    let isMoving = wt.running || wt.time !== wt.prevTime;\n    let prevWasActive = wt.prevTime >= time.start && wt.prevTime <= time.start + time.duration;\n\n    if (src && isMoving && (time.active || prevWasActive)) {\n        let t = time.t;\n        state.camera.angle = src.angle.lerp(dest.angle, t);\n        state.camera.center = src.center.lerp(dest.center, t);\n    }\n}\n\n\n\n\nexport enum DimStyle {\n    None,\n    t,\n    T,\n    C,\n    B,\n    A,\n    n_vocab,\n    n_heads,\n    n_layers,\n    Token,\n    TokenIdx,\n    C4,\n    Intermediates,\n    Weights,\n    Aggregates,\n}\n\nexport function dimStyleColor(style: DimStyle) {\n     switch (style) {\n        case DimStyle.t:\n        case DimStyle.T:\n            return Vec4.fromHexColor('#359da8');\n        case DimStyle.A:\n            return Vec4.fromHexColor('#d368a4');\n        case DimStyle.C:\n        case DimStyle.C4:\n            return Vec4.fromHexColor('#ce2983');\n        case DimStyle.Token:\n            return new Vec4(0.3, 0.7, 0.3, 1);\n        case DimStyle.TokenIdx:\n            return Vec4.fromHexColor('#1b495d');\n        case DimStyle.n_vocab:\n            return Vec4.fromHexColor('#7c3c8d'); // new Vec4(0.8, 0.6, 0.3, 1);\n        case DimStyle.Intermediates:\n            return Vec4.fromHexColor('#00ad00');\n        case DimStyle.Weights:\n            return Colors.Weights;\n        case DimStyle.Aggregates:\n            return Vec4.fromHexColor('#e3a300');\n    }\n    return new Vec4(0,0,0);\n}\n\nexport function dimStyleText(style: DimStyle) {\n    switch (style) {\n        case DimStyle.TokenIdx: return 'Token Index';\n        case DimStyle.C4: return 'C * 4';\n        default: return DimStyle[style];\n    }\n}\n\nexport function dimStyleTextShort(style: DimStyle) {\n    switch (style) {\n        case DimStyle.B: return 'b';\n        case DimStyle.T: return 't';\n        case DimStyle.A: return 'a';\n        case DimStyle.C: return 'c';\n        case DimStyle.C4: return 'c';\n        default: return DimStyle[style];\n    }\n}\n\nexport const Colors = {\n    Weights: new Vec4(0.3, 0.3, 1.0),\n    Intermediates: new Vec4(0.4, 0.8, 0.4),\n    Aggregates: new Vec4(1.0, 0.8, 0.3), // a yellowish color\n\n    Black: new Vec4(0, 0, 0),\n}\n\nexport function hideFromBlock(state: IRenderState, layout: IGptModelLayout, targetBlk: IBlkDef) {\n    let seen = false;\n    for (let blk of layout.cubes) {\n        if (!seen && blk === targetBlk) {\n            seen = true;\n        }\n        seen && blk.t === 'i' && hideBlock(blk);\n    }\n    function hideBlock(b: IBlkDef) {\n        if (b.access) {\n            b.access.disable = true;\n        }\n        b.subs?.forEach(hideBlock);\n    }\n}\n\nexport interface IPhaseGroup {\n    groupId: PhaseGroup;\n    title: string;\n    phases: IPhaseDef[];\n}\n\nexport interface IPhaseDef {\n    id: Phase;\n    title: string;\n}\n","import React, { useReducer, useState } from 'react';\nimport s from './PhaseTimeline.module.scss';\nimport { useProgramState } from './Sidebar';\nimport { clamp } from '@/src/utils/data';\nimport { useCombinedMouseTouchDrag } from '@/src/utils/pointer';\nimport { eventEndTime, ITimeInfo } from './walkthrough/WalkthroughTools';\n\nexport const PhaseTimeline: React.FC = () => {\n    let progState = useProgramState();\n    let walkthrough = progState.walkthrough;\n    let [baseEl, setBaseEl] = useState<HTMLDivElement | null>(null);\n    let [caretHitEl, setCaretHitEl] = useState<HTMLDivElement | null>(null);\n    let [, refresh] = useReducer((a: any) => a + 1, 0);\n\n    let camera = progState.camera;\n    let totalTime = walkthrough.phaseLength;\n\n    let toFract = (v: number) => clamp(v / totalTime, 0, 1);\n\n    let [dragStart, setDragStart] = useCombinedMouseTouchDrag<number>(caretHitEl, () => walkthrough.time, function handleMove(ev, ds) {\n        let dy = ev.clientY - ds.clientY;\n        let len = baseEl!.clientHeight;\n        walkthrough.time = clamp(ds.data + dy / len * totalTime, 0, totalTime);\n        walkthrough.running = false;\n        ev.preventDefault();\n        ev.stopPropagation();\n        walkthrough.markDirty();\n        refresh();\n    });\n\n    return <div className={s.timelineBase} ref={setBaseEl}>\n        <div className={s.timelineLine} />\n        {walkthrough.times.map((t, i) => {\n            return <div\n                key={i}\n                className={s.timelineEvt}\n                style={{ top: `${toFract(t.start) * 100}%`, height: `${toFract(t.duration) * 100}%` }}>\n                <div className={s.timelineEvtStart} />\n                <div className={s.timelineEvtEnd} />\n            </div>;\n        })}\n        <div className={s.timelineCaret} style={{ top: `${toFract(walkthrough.time) * 100}%` }} />\n        <div ref={setCaretHitEl} className={s.timelineCaretHit} style={{ top: `${toFract(walkthrough.time) * 100}%` }} onMouseDown={(ev) => {\n            ev.preventDefault();\n            ev.stopPropagation();\n            setDragStart(ev);\n        }}/>\n    </div>;\n}\n\n\nexport const PhaseTimelineHoriz: React.FC<{ times: ITimeInfo[] }> = ({ times }) => {\n    let progState = useProgramState();\n    let wt = progState.walkthrough;\n    let [baseEl, setBaseEl] = useState<HTMLDivElement | null>(null);\n    let [caretHitEl, setCaretHitEl] = useState<HTMLDivElement | null>(null);\n    let [, refresh] = useReducer((a: any) => a + 1, 0);\n\n    let timeOffset = times[0].start;\n    let totalTime = eventEndTime(times[times.length - 1]) - times[0].start;\n\n    let inZone = wt.time >= timeOffset && wt.time <= timeOffset + totalTime;\n\n    let toFract = (v: number) => clamp((v - timeOffset) / totalTime, 0, 1);\n\n    let [dragStart, setDragStart] = useCombinedMouseTouchDrag<number>(caretHitEl, () => wt.time, function handleMove(ev, ds) {\n        let dx = ev.clientX - ds.clientX;\n        let len = baseEl!.clientWidth;\n        wt.time = clamp(ds.data + dx / len * totalTime, timeOffset, timeOffset + totalTime);\n        wt.running = false;\n        ev.preventDefault();\n        ev.stopPropagation();\n        wt.markDirty();\n        refresh();\n    });\n\n    let [, setBaseDragStart] = useCombinedMouseTouchDrag<number>(baseEl, () => wt.time, function handleMove(ev, ds) {\n        let len = baseEl!.clientWidth;\n        let xPos = ev.clientX - baseEl!.getBoundingClientRect().left;\n        wt.time = clamp(timeOffset + xPos / len * totalTime, timeOffset, timeOffset + totalTime);\n        wt.running = false;\n        ev.preventDefault();\n        ev.stopPropagation();\n        wt.markDirty();\n        refresh();\n    });\n\n    return <div className={s.timelineBaseHoriz} ref={setBaseEl} onMouseDown={(ev) => {\n        ev.preventDefault();\n        ev.stopPropagation();\n        setBaseDragStart(ev);\n    }}>\n        <div className={s.timelineLineHoriz} />\n        {times.map((t, i) => {\n            return <div\n                key={i}\n                className={s.timelineEvtHoriz}\n                style={{ left: `${toFract(t.start) * 100}%`, width: `${toFract(t.duration) * 100}%` }}>\n                <div className={s.timelineEvtStartHoriz} />\n                <div className={s.timelineEvtEndHoriz} />\n            </div>;\n        })}\n        {inZone && <>\n            <div className={s.timelineCaretHoriz} style={{ left: `${toFract(wt.time) * 100}%` }} />\n            <div className={s.timelineCaretHitHoriz} ref={setCaretHitEl} style={{ left: `${toFract(wt.time) * 100}%` }} onMouseDown={(ev) => {\n                ev.preventDefault();\n                ev.stopPropagation();\n                setDragStart(ev);\n            }}/>\n        </>}\n    </div>;\n}\n","import { IBlockLayerLink, IGptModelLink, ILayerNormLayerLink, IModelShape } from \"./GptModel\";\nimport { isNil } from \"@/src/utils/data\";\nimport { Mat4f } from \"@/src/utils/matrix\";\nimport { Dim, Vec3 } from \"@/src/utils/vector\";\nimport { IBufferTex } from \"@/src/utils/renderPhases\";\nimport { dimProps } from \"./Annotations\";\nimport { DimStyle } from \"./walkthrough/WalkthroughTools\";\n\nexport interface IBlkDef {\n    idx: number; // index in the layout.cubes array\n    t: 'w' | 'i' | 'a', // weights; intermediate value; aggregate (just LN & softmax)\n    x: number;\n    y: number;\n    z: number;\n    dx: number; // units: model-space\n    dy: number;\n    dz: number;\n    cx: number; // units: number of cells\n    cy: number;\n    cz: number;\n    access?: IBlkAccess;\n    deps?: IBlkDeps;\n    dimX: DimStyle;\n    dimY: DimStyle;\n    name: string;\n    small: boolean; // small enough to not be worth rendering in large models\n    // implicit dimZ = DimStyle.Batch for t === 'i'\n\n    // fields that are post-added by the walk-through for various rendering configurations\n\n    localMtx?: Mat4f; // for creating blocks that are sub-parts of a block\n    // what to do for different axes?\n    rangeOffsetsX?: [number, number][]; // if this block has been split, map from [[s0, xOff], [s1, xOff], ...] to the original block\n    rangeOffsetsY?: [number, number][];\n    rangeOffsetsZ?: [number, number][];\n    highlight: number; // 0 - 1 (0 = no highlight, 1 = full highlight)\n    opacity: number; // 0 - 1 (0 = transparent, 1 = opaque)\n    special: BlkSpecial;\n    transpose?: boolean; // transpose the process direction\n    subs?: IBlkDef[]; // substitutes for this block (i.e. render these instead)\n    offX?: number; // offset from the original block\n    offY?: number;\n    offZ?: number;\n    sizeX?: number; // size of the sub block\n    sizeY?: number;\n    sizeZ?: number;\n}\n\nexport enum BlkSpecial {\n    None,\n    Attention,\n}\n\n// define how a cell is computed from other blocks\n// matrix-mulplication: cell(x, y, b) = sum_i(A[i, y] * B[x, i, b]) + C[0, y]\nexport interface IBlkDeps {\n    src(src: any, idx: Vec3): unknown;\n    dot?: [IBlkCellDep, IBlkCellDep];\n    dotLen?: number;\n    add?: IBlkCellDep[];\n    special: BlKDepSpecial;\n    lowerTri?: boolean;\n}\n\nexport interface IBlkCellDep {\n    src: IBlkDef;\n    srcIdxMtx: Mat4f; // inputs: [x, y, b, [i]], outputs: [x, y, b]\n}\n\ninterface IBlkDepArgs {\n    dot?: [[IBlkDef, string], [IBlkDef, string]];\n    dotLen?: number;\n    add?: [IBlkDef, string][];\n    lowerTri?: boolean; // only use the lower triangle of the matrix (causal attention matrices)\n    special?: BlKDepSpecial;\n}\n\nexport enum BlKDepSpecial {\n    None,\n    Softmax,\n    Gelu,\n    LayerNorm,\n    InputEmbed,\n    LayerNormMu,\n    LayerNormSigma,\n    SoftmaxAggMax,\n    SoftmaxAggExp,\n    Attention,\n}\n\nlet depIdxVars = '0xybi';\nfunction parseDepIdxStr(str: string): Mat4f {\n    let mtx = Mat4f.zeros();\n    for (let destI = 0; destI < str.length; destI++) {\n        let srcIdx = depIdxVars.indexOf(str[destI]);\n        if (srcIdx > 0) {\n            mtx.s(destI, srcIdx - 1, 1.0);\n        }\n    }\n    return mtx;\n}\n\nfunction depArgsToDeps(args: IBlkDepArgs): IBlkDeps {\n    let makeBlkDeps = (src: IBlkDef, depStr: string) => ({ src, srcIdxMtx: parseDepIdxStr(depStr) });\n    return {\n        dot: args.dot && args.dot.map(([src, depStr]) => makeBlkDeps(src, depStr)) as [IBlkCellDep, IBlkCellDep],\n        dotLen: args.dotLen,\n        add: args.add && args.add.map(([src, depStr]) => makeBlkDeps(src, depStr)),\n        special: args.special ?? BlKDepSpecial.None,\n        lowerTri: args.lowerTri,\n    };\n}\n\nexport function getBlkDimensions(blk: IBlkDef) {\n    let { x, y, z, dx, dy, dz } = blk;\n    return {\n        tl: new Vec3(x, y, z),\n        br: new Vec3(x + dx, y + dy, z + dz),\n    };\n}\n\nexport function setBlkPosition(blk: IBlkDef, pos: Vec3) {\n    blk.x = pos.x;\n    blk.y = pos.y;\n    blk.z = pos.z;\n}\n\nexport interface IBlkAccess {\n    src: IBufferTex;\n    channel: 'r' | 'g' | 'b';\n    scale: number;\n    mat: Mat4f; // actually using the first two columns for a 3x2 matrix: mapping (x, y, z) integer cell coord to (x, y) src tex coord\n    disable?: boolean;\n}\n\ninterface IBlkAccessDefArgs {\n    src?: IBufferTex;\n    channel?: 'r' | 'g' | 'b';\n    scale?: number;\n    x: number[];\n    y: number[];\n}\n\ninterface IBlkDefArgs {\n    t: 'w' | 'i' | 'a', // weights; intermediate value\n    xL?: number; // pos of Left edge\n    xR?: number; // Right\n    xM?: number; // Middle\n    zF?: number; // Front\n    zB?: number; // Back\n    zM?: number; // Middle\n    name?: string;\n    y: number;\n    cx: number; // units: number of cells\n    cz: number;\n    cy: number;\n    dimX: DimStyle;\n    dimY: DimStyle;\n    special?: BlkSpecial;\n    access?: IBlkAccessDefArgs;\n    deps?: IBlkDepArgs;\n    small?: boolean;\n    hidden?: boolean;\n    transpose?: boolean;\n}\n\nexport interface IBlkLabel {\n    visible: number;\n    cubes: IBlkDef[];\n}\n\nexport interface IModelLayout {\n    cell: number;\n    height: number;\n    margin: number;\n    cubes: IBlkDef[];\n}\n\nexport function cellPosition(layout: IModelLayout, blk: IBlkDef, dim: Dim, index: number) {\n    let { x, rangeOffsets } = dimProps(blk, dim);\n    let base = x + layout.cell * index;\n    if (!rangeOffsets) {\n        return base;\n    }\n    for (let [s, xOff] of rangeOffsets!) {\n        if (index < s) {\n            return base + xOff;\n        }\n    }\n    return base;\n}\n\nexport type IGptModelLayout = ReturnType<typeof genGptModelLayout>;\nexport type IGptLayerNormLayout = IGptModelLayout['ln_f'];\n\nexport function genGptModelLayout(shape: IModelShape, gptGpuModel: IGptModelLink | null = null, offset: Vec3 = new Vec3(0, 0, 0)) {\n    let { B, T, C, vocabSize, nHeads, A, nBlocks } = shape;\n    faArrowsUpDownLeftRight()\n    // work our way downwards from the top\n    // x is to the left and right\n    // y is positive going down, and the stack advances down from the top (at (0, 0, 0))\n    // z is coming out of the page\n\n    // a single batch of the residual pathway goes down the x-z plane\n    // weights & off-residual pathways are left & right of the residual pathway (i.e. along x)\n    // those blocks might have y-depth but that's OK: still have space to add batches\n    // x = 0 is just to the left of time-cell t=0\n\n    let isLargeModel = shape.nBlocks > 12;\n\n    let y = 0;\n\n    let cell = 1.5;\n    let margin = Math.max(12, C / 10);\n\n    function mk(args: IBlkDefArgs): IBlkDef {\n        let xDef = [args.xL, args.xR, args.xM].map(a => +!isNil(a)).reduce((a, b) => a + b, 0);\n        let yDef = [args.zF, args.zB, args.zM].map(a => +!isNil(a)).reduce((a, b) => a + b, 0);\n        if (xDef !== 1 || yDef !== 1) {\n            throw new Error(`Must supply exactly 1 x arg & 1 y arg: ${JSON.stringify(args)}`);\n        }\n        let dx = args.cx * cell;\n        let dy = args.cz * cell;\n        let x = !isNil(args.xL) ? args.xL : !isNil(args.xR) ? args.xR - dx : args.xM! - dx / 2;\n        let z = !isNil(args.zB) ? args.zB : !isNil(args.zF) ? args.zF - dy : args.zM! - dy / 2;\n\n        function ensure4(a: number[]) {\n            return a.length === 4 ? a : [...a, 0];\n        }\n\n        return {\n            dx: args.cx * cell,\n            dy: args.cy * cell,\n            dz: args.cz * cell,\n            t: args.t,\n            x: x,\n            y: args.y,\n            z: z,\n            cx: args.cx,\n            cy: args.cy,\n            cz: args.cz,\n            dimX: args.dimX,\n            dimY: args.dimY,\n            name: args.name ?? \"<unknown>\",\n            access: args.access?.src ? {\n                channel: args.access.channel ?? 'r',\n                src: args.access.src,\n                scale: args.access.scale ?? 1.0,\n                mat: Mat4f.fromColMajor([...ensure4(args.access.x), ...ensure4(args.access.y), 0, 0, 0, 0, 0, 0, 0, 0]),\n            } : undefined,\n            deps: args.deps ? depArgsToDeps(args.deps) : undefined,\n            opacity: args.hidden ? 0.0 : 1.0,\n            highlight: 0.0,\n            small: args.small ?? false,\n            special: args.special ?? BlkSpecial.None,\n            transpose: args.transpose,\n            idx: -1,\n        };\n    }\n\n    function mkLabel(init: number, cubes?: IBlkDef[]): IBlkLabel {\n        return { visible: 0, cubes: cubes ?? [] };\n    }\n\n    let cubes: IBlkDef[] = [];\n\n    let idxObj = mk({\n        t: 'i', cx: T, cz: B, cy: 1, y: y,\n        xM: 0, zM: 0,\n        access: { src: gptGpuModel?.inputTokens, x: [0, 1, 0], y: [1, 0, T], scale: 1 / vocabSize },\n        dimX: DimStyle.T, dimY: DimStyle.None,\n        name: 'Tokens',\n    });\n\n    let leftX = -T * cell / 2 - margin;\n    let rightX = T * cell / 2 + margin;\n\n    y += cell + margin;\n\n    let tokEmbedObj = mk({\n        t: 'w',\n        xR: leftX, zM: 0, y: y,\n        cx: vocabSize, cz: 1, cy: C, // src has shape [vocabSize, C]\n        access: { src: gptGpuModel?.vocabEmbed.weight, x: [0, 1, 0], y: [1, 0, 0], scale: 10 },\n        dimX: DimStyle.n_vocab, dimY: DimStyle.C,\n        name: 'Token Embed',\n    });\n\n    let posEmbedObj = mk({\n        t: 'w',\n        xL: rightX, zM: 0, y: y,\n        cx: T, cz: 1, cy: C,\n        access: { src: gptGpuModel?.posEmbed.weight, x: [0, 1, 0], y: [1, 0, 0], scale: 10 },\n        dimX: DimStyle.T, dimY: DimStyle.C,\n        name: 'Position Embed',\n    });\n\n    let residual0 = mk({\n        t: 'i',\n        xM: 0, zM: 0, y: y,\n        cx: T, cz: B, cy: C,\n        access: { src: gptGpuModel?.add.output, x: [0, 1, 0], y: [1, 0, T], scale: 10 },\n        deps: { add: [[tokEmbedObj, 'iy'], [posEmbedObj, 'xy'], [idxObj, 'x0']], special: BlKDepSpecial.InputEmbed }, // the i comes from the idxObj lookup\n        dimX: DimStyle.T, dimY: DimStyle.C,\n        name: 'Input Embed',\n    });\n    cubes.push(idxObj, tokEmbedObj, posEmbedObj, residual0);\n\n    let embedLabel = mkLabel(y, [idxObj, tokEmbedObj, posEmbedObj, residual0]);\n\n    y += C * cell + margin;\n\n    function createLn(x: number, src: IBlkDef, target?: ILayerNormLayerLink) {\n        let lnLeftX = leftX + x;\n        let resLeftX = lnLeftX - T * cell - margin;\n\n        let lnAgg1 = mk({\n            t: 'a', cx: T, cz: B, cy: 1, y: y,\n            xR: lnLeftX, zM: 0,\n            access: { src: target?.normAgg, x: [0, 1, 0], y: [1, 0, T], scale: 10.0, channel: 'r' },\n            deps: { add: [[src, 'xi']], special: BlKDepSpecial.LayerNormMu },\n            dimX: DimStyle.T, dimY: DimStyle.None, small: true,\n            name: 'LN Agg: μ, σ',\n        });\n        let lnAgg2 = mk({\n            t: 'a', cx: T, cz: B, cy: 1, y: y + cell,\n            xR: lnLeftX, zM: 0,\n            access: { src: target?.normAgg, x: [0, 1, 0], y: [1, 0, T], scale: 10.0, channel: 'g' },\n            deps: { add: [[src, 'xi']], special: BlKDepSpecial.LayerNormSigma },\n            dimX: DimStyle.T, dimY: DimStyle.None, small: true,\n            name: '',\n        });\n\n        y += 2 * cell + margin;\n\n        let lnSigma = mk({\n            t: 'w', cx: 1, cz: 1, cy: C, y: y,\n            xR: resLeftX, zM: 0,\n            access: { src: target?.normWeight, x: [1, 0, 0], y: [0, 1, 0], scale: 0.5 }, // mostly around 1.0\n            dimX: DimStyle.None, dimY: DimStyle.C,\n            name: 'γ', small: true,\n        });\n        let lnMu = mk({\n            t: 'w', cx: 1, cz: 1, cy: C, y: y,\n            xR: resLeftX - cell * 1 - margin, zM: 0,\n            access: { src: target?.normBias, x: [1, 0, 0], y: [0, 1, 0] },\n            dimX: DimStyle.None, dimY: DimStyle.C,\n            name: 'β', small: true,\n        });\n        let lnResid = mk({\n            t: 'i', cx: T, cz: B, cy: C, y: y,\n            xR: lnLeftX, zM: 0,\n            access: { src: target?.output, x: [0, 1, 0], y: [1, 0, T], scale: 1.0 },\n            deps: { add: [[src, 'xy'], [lnAgg1, 'xi'], [lnAgg2, 'xi'], [lnSigma, '0y'], [lnMu, '0y']], special: BlKDepSpecial.LayerNorm }, // lnSigma is really mul rather than add\n            dimX: DimStyle.T, dimY: DimStyle.C,\n            name: 'Layer Norm',\n        });\n        let lnCubes = [lnAgg1, lnAgg2, lnSigma, lnMu, lnResid];\n        return { lnAgg1, lnAgg2, lnResid, lnSigma, lnMu, cubes: lnCubes };\n    }\n\n    let lnLeftX = leftX - (T + 2) * cell - 3 * margin;\n\n    function createLayer(src: IBlkDef, target: IBlockLayerLink | undefined) {\n        let ln1 = createLn(0, src, target?.ln_1);\n\n        let interHeadMargin = 3 * margin + (C * cell) / 16;\n        let qkvMargin = 1 * margin + (C * cell) / 16;\n\n        let headWidth = 3 * B * cell + qkvMargin * 2 + (isLargeModel ? 0 : interHeadMargin);\n\n        let attn1Y = y + A * cell + margin + (isLargeModel ? 2 * A * cell : 0);\n        let attn2Y = attn1Y; // + T * cell + margin;\n        let vOutY = attn2Y + T * cell + margin;\n\n        let attnLeftX = lnLeftX; // leftX - ((T + 2) * cell + 3 * margin);\n        let qkvValLeftX = attnLeftX - T * cell - margin;\n        let qkvBiasLeftX = qkvValLeftX - C * cell - margin;\n        let stepPerHeadY = 0; // A * cell;\n\n        let attnTarget = target?.attn;\n\n        let heads = [];\n        for (let i = 0; i < nHeads; i++) {\n            let headZMid = headWidth * i - (nHeads - 1) * headWidth / 2;\n            let qMid = headZMid + B * cell + qkvMargin;\n            let kMid = headZMid;\n            let vMid = headZMid - B * cell - qkvMargin;\n\n            // x: C, y: A\n            let qWeightBlock = mk({\n                t: 'w', cx: C, cz: 1, cy: A, y: y,\n                xR: qkvValLeftX, zM: qMid,\n                access: { src: attnTarget?.qkvWeight, x: [1, 0, 0], y: [0, 1, 0, 0 * C + A * i], scale: C * 0.25 },\n                dimX: DimStyle.C, dimY: DimStyle.A,\n                name: 'Q Weights',\n            });\n\n            let kWeightBlock = mk({\n                t: 'w', cx: C, cz: 1, cy: A, y: y,\n                xR: qkvValLeftX, zM: kMid,\n                access: { src: attnTarget?.qkvWeight, x: [1, 0, 0], y: [0, 1, 0, 1 * C + A * i], scale: C * 0.25 },\n                dimX: DimStyle.C, dimY: DimStyle.A,\n                name: 'K Weights',\n            });\n\n            let vWeightBlock = mk({\n                t: 'w', cx: C, cz: 1, cy: A, y: y,\n                xR: qkvValLeftX, zM: vMid,\n                access: { src: attnTarget?.qkvWeight, x: [1, 0, 0], y: [0, 1, 0, 2 * C + A * i], scale: C * 0.25 },\n                dimX: DimStyle.C, dimY: DimStyle.A,\n                name: 'V Weights',\n            });\n\n            let qkvWeightBlock = mk({\n                t: 'w', cx: C, cz: 1, cy: A * 3, y: y,\n                xR: qkvValLeftX, zM: kMid,\n                dimX: DimStyle.C, dimY: DimStyle.C,\n                name: 'QKV Weights',\n            });\n\n            let qBiasBlock = mk({\n                t: 'w', cx: 1, cz: 1, cy: A, y: y,\n                xR: qkvBiasLeftX, zM: qMid,\n                access: { src: attnTarget?.qkvBias, x: [1, 0, 0], y: [0, 1, 0, 0 * C + A * i] },\n                dimX: DimStyle.None, dimY: DimStyle.A, small: true,\n                name: 'Q Bias',\n            });\n\n            let kBiasBlock = mk({\n                t: 'w', cx: 1, cz: 1, cy: A, y: y,\n                xR: qkvBiasLeftX, zM: kMid,\n                access: { src: attnTarget?.qkvBias, x: [1, 0, 0], y: [0, 1, 0, 1 * C + A * i] },\n                dimX: DimStyle.None, dimY: DimStyle.A, small: true,\n                name: 'K Bias',\n            });\n\n            let vBiasBlock = mk({\n                t: 'w', cx: 1, cz: 1, cy: A, y: y,\n                xR: qkvBiasLeftX, zM: vMid,\n                access: { src: attnTarget?.qkvBias, x: [1, 0, 0], y: [0, 1, 0, 2 * C + A * i] },\n                dimX: DimStyle.None, dimY: DimStyle.A, small: true,\n                name: 'V Bias',\n            });\n\n            let qBlock = mk({\n                t: 'i', cx: T, cz: B, cy: A, y: y,\n                xR: attnLeftX, zM: qMid,\n                access: { src: attnTarget?.qkvOutput, x: [0, 1, 0, 0 * C + A * i], y: [1, 0, T], scale: 1.0 },\n                deps: { dot: [[qWeightBlock, 'iy'], [ln1.lnResid, 'xi']], add: [[qBiasBlock, '0y']], dotLen: C },\n                dimX: DimStyle.T, dimY: DimStyle.A,\n                name: 'Q vectors',\n            });\n\n            let kBlock = mk({\n                t: 'i', cx: T, cz: B, cy: A, y: y,\n                xR: attnLeftX, zM: kMid,\n                access: { src: attnTarget?.qkvOutput, x: [0, 1, 0, 1 * C + A * i], y: [1, 0, T], scale: 1.0 },\n                deps: { dot: [[kWeightBlock, 'iy'], [ln1.lnResid, 'xi']], add: [[kBiasBlock, '0y']], dotLen: C },\n                dimX: DimStyle.T, dimY: DimStyle.A,\n                name: 'K vectors',\n            });\n\n            let vBlock = mk({\n                t: 'i', cx: T, cz: B, cy: A, y: y,\n                xR: attnLeftX, zM: vMid,\n                access: { src: attnTarget?.qkvOutput, x: [0, 1, 0, 2 * C + A * i], y: [1, 0, T], scale: 1.0 },\n                deps: { dot: [[vWeightBlock, 'iy'], [ln1.lnResid, 'xi']], add: [[vBiasBlock, '0y']], dotLen: C },\n                dimX: DimStyle.T, dimY: DimStyle.A,\n                name: 'V vectors',\n            });\n\n            let qkvBlock = mk({\n                t: 'i', cx: T, cz: B, cy: A * 3, y: y,\n                xR: attnLeftX, zM: kMid,\n                dimX: DimStyle.T, dimY: DimStyle.C,\n                name: 'QKV vectors',\n            });\n\n            let attn2LeftX = attnLeftX - (T + 2) * cell - 2 * margin;\n\n            let attnMtx = mk({\n                t: 'i', cx: T, cz: B, cy: T, y: attn1Y,\n                xR: attnLeftX, zM: headZMid,\n                access: { src: attnTarget?.attnMatrix, x: [1, 0, 0], y: [0, 1, nHeads * T, T * i], scale: 1.0 },\n                deps: { dot: [[qBlock, 'yi'], [kBlock, 'xi']], lowerTri: true, dotLen: A, special: BlKDepSpecial.Attention },\n                dimX: DimStyle.T, dimY: DimStyle.T,\n                special: BlkSpecial.Attention,\n                transpose: true,\n                name: 'Attention Matrix',\n            });\n\n            let attnMtxAgg1 = mk({\n                t: 'a', cx: 1, cz: B, cy: T, y: attn1Y,\n                xR: attnLeftX - T * cell - margin - cell, zM: headZMid,\n                access: { src: attnTarget?.attnMatrixSoftmax, x: [0, 0, 0, 1], y: [0, 1, nHeads * T, T * i], channel: 'r' },\n                deps: { add: [[attnMtx, 'iy']], special: BlKDepSpecial.SoftmaxAggExp },\n                dimX: DimStyle.None, dimY: DimStyle.T, small: true,\n                name: '',\n            });\n\n            let attnMtxAgg2 = mk({\n                t: 'a', cx: 1, cz: B, cy: T, y: attn1Y,\n                xR: attnLeftX - T * cell - margin, zM: headZMid,\n                access: { src: attnTarget?.attnMatrixSoftmax, x: [0, 0, 0, 1], y: [0, 1, nHeads * T, T * i], channel: 'g' },\n                deps: { add: [[attnMtx, 'iy']], special: BlKDepSpecial.SoftmaxAggMax },\n                dimX: DimStyle.None, dimY: DimStyle.T, small: true,\n                name: '',\n            });\n\n            let attnMtxSm = mk({\n                t: 'i', cx: T, cz: B, cy: T, y: attn1Y,\n                xR: attn2LeftX, zM: headZMid,\n                access: { src: attnTarget?.attnMatrixSoftmax, x: [1, 0, 0], y: [0, 1, nHeads * T, T * i], scale: 2.0 },\n                deps: { add: [[attnMtx, 'xy'], [attnMtxAgg1, 'iy'], [attnMtxAgg2, 'iy']], lowerTri: true, special: BlKDepSpecial.Softmax },\n                dimX: DimStyle.T, dimY: DimStyle.T,\n                special: BlkSpecial.Attention,\n                transpose: true,\n                name: 'Attn Matrix Softmax',\n            });\n\n            let vOutBlock = mk({\n                t: 'i', cx: T, cz: B, cy: A, y: vOutY + i * stepPerHeadY,\n                xR: attnLeftX, zM: headZMid,\n                access: { src: attnTarget?.scaledVectors, x: [0, 1, 0, i * A], y: [1, 0, T] },\n                deps: { dot: [[vBlock, 'iy'], [attnMtxSm, 'ix']], dotLen: A },\n                dimX: DimStyle.T, dimY: DimStyle.A,\n                name: 'V Output',\n            });\n\n            let headCubes = [...isLargeModel ? [qkvWeightBlock, qkvBlock] : [qWeightBlock, kWeightBlock, vWeightBlock, qBlock, kBlock, vBlock],\n                qBiasBlock, kBiasBlock, vBiasBlock,\n                attnMtx, attnMtxAgg1, attnMtxAgg2, attnMtxSm, vOutBlock];\n\n            let headLabel = mkLabel(1.0, headCubes);\n            let qLabel = mkLabel(1.0, [qWeightBlock, qBiasBlock, qBlock]);\n            let kLabel = mkLabel(1.0, [kWeightBlock, kBiasBlock, kBlock]);\n            let vLabel = mkLabel(1.0, [vWeightBlock, vBiasBlock, vBlock]);\n            let biasLabel = mkLabel(1.0, [qBiasBlock, kBiasBlock, vBiasBlock]);\n            let mtxLabel = mkLabel(1.0, [attnMtx, attnMtxAgg1, attnMtxAgg2, attnMtxSm]);\n            let vectorLabel = mkLabel(1.0, [vOutBlock]);\n\n            let head = {\n                qWeightBlock, kWeightBlock, vWeightBlock,\n                qBiasBlock, kBiasBlock, vBiasBlock,\n                qBlock, kBlock, vBlock,\n                attnMtx, attnMtxAgg1, attnMtxAgg2, attnMtxSm, vOutBlock,\n                qLabel, kLabel, vLabel, biasLabel, mtxLabel, vectorLabel, headLabel,\n                cubes: headCubes,\n                labels: [qLabel, kLabel, vLabel, biasLabel, mtxLabel, vectorLabel, headLabel],\n            };\n            heads.push(head);\n        }\n\n        let vOutCombined = mk({\n            t: 'i', cx: T, cz: B, cy: C, y: vOutY,\n            xR: attnLeftX, zF: - headWidth * nHeads / 2,\n            dimX: DimStyle.T, dimY: DimStyle.C,\n            hidden: true,\n            name: 'V Output Combined',\n        });\n\n        let vFinalZ = Math.max(\n            vOutY + stepPerHeadY * (nHeads - 1) + A * cell + 2 * margin,\n            y + C * cell + margin, // in case the layer norm block is shorter\n        );\n\n        let projWeight = mk({\n            t: 'w', cx: C, cz: 1, cy: C, y: vFinalZ,\n            xR: qkvValLeftX, zM: 0,\n            access: { src: attnTarget?.proj.weight, x: [1, 0, 0], y: [0, 1, 0], scale: C * 0.5 },\n            dimX: DimStyle.C, dimY: DimStyle.C,\n            name: 'Projection Weights',\n        });\n\n        let projBias = mk({\n            t: 'w', cx: 1, cz: 1, cy: C, y: vFinalZ,\n            xR: qkvValLeftX - C * cell - margin, zM: 0,\n            access: { src: attnTarget?.proj.bias!, x: [0, 0, 0], y: [0, 1, 0], scale: C * 0.5 },\n            dimX: DimStyle.None, dimY: DimStyle.C, small: true,\n            name: 'Projection Bias',\n        });\n\n        let attnOut = mk({\n            t: 'i', cx: T, cz: B, cy: C, y: vFinalZ,\n            xR: attnLeftX, zM: 0,\n            access: { src: attnTarget?.proj.output, x: [0, 1, 0], y: [1, 0, T] },\n            // deps: { dot: [[projWeight, 'iy'], [vOutCombined, 'xi']], dotLen: C },\n            // vOutCombined isn't displayed atm, so add from the heads instead\n            deps: {\n                dot: [[projWeight, 'iy'], [vOutCombined, 'xi']], dotLen: C,\n                add: [[projBias, '0y'], ...heads.map(h => [h.vOutBlock, 'xi'] as [IBlkDef, string])]\n            },\n            dimX: DimStyle.T, dimY: DimStyle.C,\n            name: 'Attention Output',\n        });\n\n        let attnResidual = mk({\n            t: 'i', cx: T, cz: B, cy: C, y: vFinalZ,\n            xM: 0, zM: 0,\n            access: { src: attnTarget?.output, x: [0, 1, 0], y: [1, 0, T] },\n            deps: { add: [[attnOut, 'xy'], [src, 'xy']] },\n            dimX: DimStyle.T, dimY: DimStyle.C,\n            name: 'Attention Residual',\n        });\n\n        y = vFinalZ + C * cell + margin;\n\n        let ln2 = createLn(0, attnResidual, target?.ln_2);\n\n        let mlpFcWeight = mk({\n            t: 'w', cx: C * 4, cz: 1, cy: C, y: y,\n            xR: attnLeftX, zM: 0,\n            access: { src: target?.mlp.fcLayer.weight, x: [0, 1, 0], y: [1, 0, 0], scale: C * 0.5 },\n            dimX: DimStyle.C4, dimY: DimStyle.C,\n            name: 'MLP Weights',\n        });\n\n        let mlpFcBias = mk({\n            t: 'w', cx: C * 4, cz: 1, cy: 1, y: y - 1 * cell - margin,\n            xR: attnLeftX, zM: 0,\n            access: { src: target?.mlp.fcLayer.bias!, x: [0, 1, 0], y: [1, 0, 0], scale: C * 0.5 },\n            dimX: DimStyle.C4, dimY: DimStyle.None,\n            name: 'MLP Bias', small: true,\n        });\n\n        y += C * cell + margin;\n\n        let mlpFc = mk({\n            t: 'i', cx: C * 4, cz: B, cy: T, y: y,\n            xR: attnLeftX, zM: 0,\n            access: { src: target?.mlp.fcLayer.output, x: [1, 0, 0], y: [0, 1, T], scale: 1.0 },\n            deps: { dot: [[mlpFcWeight, 'xi'], [ln2.lnResid, 'yi']], dotLen: C, add: [[mlpFcBias, 'x']] },\n            dimX: DimStyle.C4, dimY: DimStyle.T,\n            name: 'MLP',\n            transpose: true,\n        });\n\n        y += T * cell + margin;\n\n        let mlpAct = mk({\n            t: 'i', cx: C * 4, cz: B, cy: T, y: y,\n            xR: attnLeftX, zM: 0,\n            access: { src: target?.mlp.mlpGelu, x: [1, 0, 0], y: [0, 1, T], scale: 1.0 },\n            deps: { add: [[mlpFc, 'xy']], special: BlKDepSpecial.Gelu },\n            dimX: DimStyle.C4, dimY: DimStyle.T,\n            name: 'MLP Activation',\n            transpose: true,\n        });\n\n        y += T * cell + margin;\n\n        let mlpProjWeight = mk({\n            t: 'w', cx: C * 4, cz: 1, cy: C, y: y,\n            xR: attnLeftX, zM: 0,\n            access: { src: target?.mlp.projLayer.weight, x: [1, 0, 0], y: [0, 1, 0], scale: C * 0.5 },\n            dimX: DimStyle.C4, dimY: DimStyle.C,\n            name: 'MLP Projection Weights',\n        });\n\n        let mlpProjBias = mk({\n            t: 'w', cx: 1, cz: 1, cy: C, y: y,\n            xR: attnLeftX - C * 4 * cell - margin, zM: 0,\n            access: { src: target?.mlp.projLayer.bias!, x: [1, 0, 0], y: [0, 1, 0], scale: C * 0.5 },\n            dimX: DimStyle.None, dimY: DimStyle.C, small: true,\n            name: 'MLP Projection Bias',\n        });\n\n        let mlpResult = mk({\n            t: 'i', cx: T, cz: B, cy: C, y: y,\n            xL: attnLeftX + margin, zM: 0,\n            access: { src: target?.mlp.projLayer.output, x: [0, 1, 0], y: [1, 0, T] },\n            deps: { dot: [[mlpProjWeight, 'iy'], [mlpAct, 'ix']], dotLen: C, add: [[mlpProjBias, '0y']] },\n            dimX: DimStyle.T, dimY: DimStyle.C,\n            name: 'MLP Result',\n        });\n\n        let mlpResidual = mk({\n            t: 'i', cx: T, cz: B, cy: C, y: y,\n            xM: 0, zM: 0,\n            access: { src: target?.mlp.output, x: [0, 1, 0], y: [1, 0, T] },\n            deps: { add: [[mlpResult, 'xy'], [attnResidual, 'xy']] },\n            dimX: DimStyle.T, dimY: DimStyle.C,\n            name: 'MLP Residual',\n        });\n\n        y += C * cell - margin;\n\n        let blockCubes = [\n            ...ln1.cubes,\n            ...heads.flatMap(h => h.cubes),\n            projWeight,\n            projBias,\n            attnOut,\n            attnResidual,\n            ...ln2.cubes,\n            mlpFcWeight,\n            mlpFcBias,\n            mlpFc,\n            mlpAct,\n            mlpProjWeight,\n            mlpProjBias,\n            mlpResult,\n            mlpResidual,\n        ]\n\n        let headCubes = [...ln1.cubes, ...heads.flatMap(h => h.cubes)];\n        let projCubes = [projWeight, projBias, attnOut, attnResidual];\n\n        let transformerLabel = mkLabel(1.0, blockCubes);\n        let selfAttendLabel = mkLabel(1.0, [...headCubes, ...projCubes]);\n        let projLabel = mkLabel(1.0, projCubes);\n        let mlpLabel = mkLabel(1.0, [...ln2.cubes, mlpFcWeight, mlpFcBias, mlpFc, mlpAct, mlpProjWeight, mlpProjBias, mlpResult, mlpResidual]);\n\n        cubes.push(...blockCubes);\n\n        return {\n            ln1,\n            heads,\n            labels: [transformerLabel, projLabel, selfAttendLabel, mlpLabel, ...heads.flatMap(h => h.labels)],\n            cubes: blockCubes,\n            transformerLabel,\n            projLabel,\n            selfAttendLabel,\n            mlpLabel,\n            projWeight,\n            projBias,\n            attnOut,\n            attnResidual,\n            mlpFc,\n            mlpFcWeight,\n            mlpFcBias,\n            mlpAct,\n            mlpProjWeight,\n            mlpProjBias,\n            mlpResult,\n            mlpResidual,\n            ln2,\n        };\n    }\n\n\n    let blockHalfMargin = 2 * margin;\n\n    y += blockHalfMargin;\n\n    let numColumns = 1;\n    let blocksPerColumn = 12;\n    if (shape.nBlocks > blocksPerColumn) {\n        numColumns = Math.ceil(shape.nBlocks / blocksPerColumn);\n    }\n    let columnWidth = (C * 14) * cell + margin * 2;\n    let blockIdxInColumn = 0;\n    let blockYTop = y;\n\n    let blocks: ReturnType<typeof createLayer>[] = [];\n    let blockSrc = residual0;\n    for (let i = 0; i < nBlocks; i++) {\n        if (blockIdxInColumn >= blocksPerColumn) {\n            blockIdxInColumn = 0;\n            y = blockYTop;\n            lnLeftX += columnWidth;\n            leftX += columnWidth;\n            rightX += columnWidth;\n        }\n\n        let target = gptGpuModel?.blocks[i];\n        y += blockHalfMargin;\n        let block = createLayer(blockSrc, target);\n        blocks.push(block);\n        blockSrc = block.mlpResidual;\n        y += blockHalfMargin;\n        blockIdxInColumn++;\n    }\n\n    y += blockHalfMargin;\n    let ln_f = createLn(0, blockSrc, gptGpuModel?.ln_f);\n\n    cubes.push(...ln_f.cubes);\n\n    let logitsTransposed = false;\n\n    let lmHeadWeight: IBlkDef, logits: IBlkDef, logitsAgg1: IBlkDef, logitsAgg2: IBlkDef, logitsSoftmax: IBlkDef;\n\n    if (logitsTransposed) {\n        lmHeadWeight = mk({\n            t: 'w', cx: vocabSize, cz: 1, cy: C, y: y,\n            xR: lnLeftX, zM: 0,\n            access: { src: gptGpuModel?.lm_head.weight, x: [0, 1, 0], y: [1, 0, 0], scale: 5.0 },\n            dimX: DimStyle.n_vocab, dimY: DimStyle.C,\n            name: 'LM Head Weights',\n        });\n\n        y += C * cell + margin;\n\n        logits = mk({\n            t: 'i', cx: vocabSize, cz: B, cy: T, y: y,\n            xR: lnLeftX, zM: 0,\n            access: { src: gptGpuModel?.lm_head.output, x: [1, 0, 0], y: [0, 1, T] },\n            deps: { dot: [[lmHeadWeight, 'xi'], [ln_f.lnResid, 'yi']], dotLen: C },\n            dimX: DimStyle.n_vocab, dimY: DimStyle.T,\n            name: 'Logits',\n        });\n\n        // z += vocabSize * cell + margin;\n\n        logitsAgg1 = mk({\n            t: 'a', cx: 1, cz: B, cy: T, y: y,\n            xL: lnLeftX + 1.5 * margin, zM: -3 * cell,\n            access: { src: gptGpuModel?.softmaxFinal.agg, x: [1, 0, 0], y: [0, 1, T], channel: 'r' },\n            deps: { add: [[logits, 'iy']], special: BlKDepSpecial.SoftmaxAggExp },\n            dimX: DimStyle.None, dimY: DimStyle.T,\n            name: 'SM Agg',\n        });\n\n        logitsAgg2 = mk({\n            t: 'a', cx: 1, cz: B, cy: T, y: y,\n            xL: lnLeftX + 1.5 * margin + cell, zM: -3 * cell,\n            access: { src: gptGpuModel?.softmaxFinal.agg, x: [1, 0, 0], y: [0, 1, T], channel: 'g' },\n            deps: { add: [[logits, 'iy']], special: BlKDepSpecial.SoftmaxAggMax },\n            dimX: DimStyle.None, dimY: DimStyle.T,\n            name: '',\n        });\n\n        y += T * cell + margin;\n\n        logitsSoftmax = mk({\n            t: 'i', cx: vocabSize, cz: B, cy: T, y: y,\n            xR: lnLeftX, zM: 0,\n            access: { src: gptGpuModel?.softmaxFinal.output, x: [1, 0, 0], y: [0, 1, T] },\n            deps: { add: [[logits, 'xy'], [logitsAgg1, 'iy'], [logitsAgg2, 'iy']], special: BlKDepSpecial.Softmax },\n            dimX: DimStyle.n_vocab, dimY: DimStyle.T,\n            name: 'Logits Softmax',\n        });\n\n    } else {\n        y += C * cell + margin;\n        let leftX2 = leftX - T * cell - margin;\n\n        lmHeadWeight = mk({\n            t: 'w', cx: C, cy: vocabSize, cz: 1, y: y,\n            xR: leftX2, zM: 0,\n            access: { src: gptGpuModel?.lm_head.weight, x: [1, 0, 0], y: [0, 1, 0], scale: 5.0 },\n            dimX: DimStyle.C, dimY: DimStyle.n_vocab,\n            name: 'LM Head Weights',\n        });\n\n\n        logits = mk({\n            t: 'i', cx: T, cy: vocabSize, cz: B, y: y,\n            xR: leftX, zM: 0,\n            access: { src: gptGpuModel?.lm_head.output, x: [0, 1, 0], y: [1, 0, T] },\n            deps: { dot: [[lmHeadWeight, 'iy'], [ln_f.lnResid, 'xi']], dotLen: C },\n            dimX: DimStyle.T, dimY: DimStyle.n_vocab,\n            name: 'Logits',\n        });\n\n        y += vocabSize * cell + margin;\n\n        logitsAgg2 = mk({\n            t: 'a', cx: T, cy: 1, cz: B, y: y,\n            xR: leftX, zM: 0,\n            access: { src: gptGpuModel?.softmaxFinal.agg, x: [0, 1, 0], y: [1, 0, T], channel: 'g' },\n            deps: { add: [[logits, 'xi']], special: BlKDepSpecial.SoftmaxAggMax },\n            dimX: DimStyle.T, dimY: DimStyle.None,\n            name: 'SM Agg',\n        });\n\n        logitsAgg1 = mk({\n            t: 'a', cx: T, cy: 1, cz: B, y: y + cell,\n            xR: leftX, zM: 0,\n            access: { src: gptGpuModel?.softmaxFinal.agg, x: [0, 1, 0], y: [1, 0, T], channel: 'r' },\n            deps: { add: [[logits, 'xi'], [logitsAgg2, 'x0']], special: BlKDepSpecial.SoftmaxAggExp },\n            dimX: DimStyle.T, dimY: DimStyle.None,\n            name: '',\n        });\n\n        y += 2 * cell + margin;\n\n        logitsSoftmax = mk({\n            t: 'i', cx: T, cy: vocabSize, cz: B, y: y,\n            xR: leftX, zM: 0,\n            access: { src: gptGpuModel?.softmaxFinal.output, x: [0, 1, 0], y: [1, 0, T] },\n            deps: { add: [[logits, 'xy'], [logitsAgg1, 'xi'], [logitsAgg2, 'xi']], special: BlKDepSpecial.Softmax },\n            dimX: DimStyle.T, dimY: DimStyle.n_vocab,\n            name: 'Logits Softmax',\n        });\n\n    }\n\n    // let logitsSoftmaxTopN = mk({\n    //     t: 'i', cx: T, cz: B, cy: Math.min(32, vocabSize), y: y,\n    //     xM: 0, zM: 0,\n    // });\n\n    let weightCount = vocabSize * C + T * C +\n        nBlocks * ((2 * C + 4 * C * C + C + 3 * C) + // self attn\n            (2 * C + 4 * C + 8 * C * C + C)) + 2 * C; // mlp\n\n    // let decoderCount = vocabSize * C; (excluded from the weight count apparently)\n\n    cubes.push(lmHeadWeight, logits, logitsAgg1, logitsAgg2, logitsSoftmax);\n\n    for (let i = 0; i < cubes.length; i++) {\n        cubes[i].idx = i;\n    }\n\n    return {\n        cubes,\n        cell,\n        margin,\n        idxObj,\n        tokEmbedObj,\n        posEmbedObj,\n        residual0,\n        ln_f,\n        lmHeadWeight,\n        logits,\n        logitsAgg1,\n        logitsAgg2,\n        logitsSoftmax,\n        embedLabel,\n        blocks,\n        height: y,\n        logitsTransposed,\n        model: gptGpuModel,\n        labels: [embedLabel, ...blocks.flatMap(b => b.labels)],\n        weightCount,\n        shape,\n        extraSources: {\n            idx: gptGpuModel?.inputBuf,\n            tokEmbedOut: gptGpuModel?.vocabEmbed.output,\n            posEmbedOut: gptGpuModel?.posEmbed.output,\n        },\n    };\n}\n\n","import { Mat4f } from \"@/src/utils/matrix\";\nimport { bindFloatAttribs, createElementBuffer, createFloatBuffer, createShaderProgram, ensureElementBufferSize, ensureFloatBufferSize, IGLContext, resetElementBufferMap, resetFloatBufferMap, uploadElementBuffer, uploadFloatBuffer } from \"@/src/utils/shader\";\nimport { Vec3, Vec3Buf, Vec4 } from \"@/src/utils/vector\";\nimport { ISharedRender, modelViewUboText, RenderPhase, UboBindings } from \"./sharedRender\";\n\nexport type ILineRender = ReturnType<typeof createLineRender>;\n\nexport function createLineRender(ctx: IGLContext, sharedRender: ISharedRender) {\n\n\n    /* Lines are made up of several quads, 1(?) for each line segment.\n\n    we'll use TRIANGLE_STRIP for rendering, and indexed arrays to support primitive restart.\n\n    Just gonna render each line segment separately. Corners too much of a pain for now!\n\n    Still need to get the quad to face the camera, and to be the right size.\n    I think it makes sense to do this after projection in the vertex shader.\n\n    */\n\n    let gl = ctx.gl;\n\n    let lineVao = gl.createVertexArray()!;\n    gl.bindVertexArray(lineVao);\n\n    let lineVbo = gl.createBuffer()!;\n    let strideBytes = bindFloatAttribs(gl, lineVbo, { }, [\n        { name: 'a_position', size: 3 },\n        { name: 'a_lineDirA', size: 3 },\n        { name: 'a_lineDirB', size: 3 },\n        { name: 'a_color', size: 4 },\n        { name: 'a_thickness', size: 1 },\n        { name: 'a_firstPair', size: 1 },\n        { name: 'a_normal', size: 3 },\n        { name: 'a_dash', size: 1 },\n        { name: 'a_t', size: 1 },\n    ]);\n\n    let lineFloatBuf = createFloatBuffer(gl, gl.ARRAY_BUFFER, lineVbo, 1024, strideBytes, null);\n\n    let lineIbo = gl.createBuffer()!;\n    let lineIndexBuf = createElementBuffer(gl, lineIbo, 1024, sharedRender);\n\n    let lineShader = createShaderProgram(ctx, 'line', /*glsl*/`#version 300 es\n        precision highp float;\n        ${modelViewUboText}\n        uniform vec2 u_viewSizeInv;\n        layout(location = 0) in vec3 a_position;\n        layout(location = 1) in vec3 a_lineDirA;\n        layout(location = 2) in vec3 a_lineDirB;\n        layout(location = 3) in vec4 a_color;\n        layout(location = 4) in float a_thickness;\n        layout(location = 5) in float a_firstPair;\n        layout(location = 6) in vec3 a_normal;\n        layout(location = 7) in float a_dash;\n        layout(location = 8) in float a_t;\n        out vec2 v_linePos;\n        out vec4 v_color;\n        out float v_thickness;\n        out float v_dash;\n        void main() {\n\n            float mul = 1.0;\n            if (gl_VertexID % 2 == 0) {\n                mul = -1.0;\n            }\n\n            bool firstPair = a_firstPair > 0.0;\n\n            float width;\n\n            if (length(a_normal) == 0.0) {\n                vec4 clipPos = u_view * u_model * vec4(a_position, 1);\n                vec2 screenPos = clipPos.xy / clipPos.w;\n\n                vec4 lineDirAClip = u_view * u_model * vec4(a_position + a_lineDirA, 1);\n                vec2 lineDirA = normalize(lineDirAClip.xy / lineDirAClip.w - screenPos);\n                vec4 lineDirBClip = u_view * u_model * vec4(a_position + a_lineDirB, 1);\n                vec2 lineDirB = normalize(lineDirBClip.xy / lineDirBClip.w - screenPos);\n\n                vec2 avgDir = normalize(lineDirA + lineDirB);\n                vec2 activeDir = firstPair ? lineDirA : lineDirB;\n\n                float scale = sqrt(2.0) / length(lineDirA + lineDirB);\n                vec2 offset = vec2(-avgDir.y, avgDir.x);\n\n                if (scale > 5.0) {\n                    bool isOuter = cross(vec3(lineDirA, 0), vec3(lineDirB, 0)).z * mul < 0.0;\n                    if (isOuter) {\n                        offset = vec2(-activeDir.y, activeDir.x);\n                        scale = 1.0 / sqrt(2.0);\n                    } else {\n                        offset = vec2(-activeDir.y, activeDir.x);\n                        scale = 1.0 / sqrt(2.0);\n                    }\n                }\n\n                width = a_thickness * 2.0;\n                vec2 linePos = screenPos + offset * u_viewSizeInv * width * mul * scale;\n\n                gl_Position = vec4(linePos.xy * clipPos.w, clipPos.z, clipPos.w);\n                v_thickness = a_thickness;\n\n            } else {\n\n                width = a_thickness * 2.0;\n                vec3 activeDir = firstPair ? a_lineDirA : a_lineDirB;\n\n                vec3 avgDir = normalize(a_lineDirA + a_lineDirB);\n                vec3 offset = normalize(cross(a_normal, avgDir));\n                // need to scale by the amount of angle between the two line directions\n                float scale = sqrt(2.0) / length(a_lineDirA + a_lineDirB);\n\n                // if we exceed the miter limit (90 degrees), we need to clamp the line width, and draw a bevel instead.\n                // the inner corner stays the same, but the outer corner is a bevel.\n\n                if (scale > 2.0) {\n                    bool isOuter = cross(a_lineDirA, a_lineDirB).z * mul < 0.0;\n\n                    if (isOuter) {\n                        offset = normalize(cross(a_normal, activeDir));\n                        scale = 1.0 / sqrt(2.0);\n                    }\n                }\n\n                vec3 linePos = a_position + offset * mul * width * scale;\n\n                gl_Position = u_view * u_model * vec4(linePos, 1);\n                v_thickness = 100.0;\n\n            }\n\n            v_dash = a_dash;\n            v_color = a_color;\n            v_linePos = vec2(mul * width, a_t);\n        }\n    `, /*glsl*/`#version 300 es\n        precision highp float;\n        in vec2 v_linePos;\n        in vec4 v_color;\n        in float v_thickness;\n        in float v_dash;\n        out vec4 o_color;\n\n        void main() {\n            float lineWidth = v_thickness - 1.0;\n            float edge0 = lineWidth / 2.0;\n            float edge1 = lineWidth / 2.0 + fwidth(v_linePos.x);\n            float t = 1.0 - smoothstep(edge0, edge1, abs(v_linePos.x));\n\n            if (v_dash > 0.0) {\n                float dashPos = mod(v_linePos.y, v_dash);\n                if (dashPos > v_dash / 2.0) {\n                    t = 0.0;\n                }\n            }\n\n            if (t == 0.0) {\n                discard;\n            }\n\n            o_color = v_color * t;\n        }\n    `, [\n        'u_viewSizeInv'\n    ], { uboBindings: { 'ModelViewUbo': UboBindings.ModelView } })!;\n\n    return {\n        gl,\n        vao: lineVao,\n        floatBuf: lineFloatBuf,\n        indexBuf: lineIndexBuf,\n        lineShader,\n        sharedRender,\n    };\n}\n\nexport interface ILineOpts {\n    thick: number;\n    color: Vec4;\n    mtx: Mat4f;\n    n?: Vec3;\n    closed?: boolean;\n    dash?: number;\n}\n\nexport function makeLineOpts(opts: Partial<ILineOpts> = {}): ILineOpts {\n    return {\n        thick: +(opts.thick || 1),\n        color: opts.color || new Vec4(1, 1, 1, 1),\n        mtx: opts.mtx || Mat4f.identity,\n        n: opts.n || undefined,\n        closed: opts.closed || false,\n        dash: opts.dash ?? 0,\n    };\n}\n\nexport function addLine2(render: ILineRender, a: Vec3, b: Vec3, opts: ILineOpts) {\n    addLine(render, opts.thick, opts.color, a, b, opts.n, opts.mtx, opts.dash);\n}\n\nlet _lineA = new Vec3();\nlet _lineB = new Vec3();\nlet _lineDir = new Vec3();\n\nexport function addLine(render: ILineRender, thickness: number, color: Vec4, a: Vec3, b: Vec3, n?: Vec3, mtx?: Mat4f, dash?: number, t?: number) {\n    let phase = render.sharedRender.activePhase;\n    let floatLocalBuf = render.floatBuf.localBufs[0];\n    let buf = floatLocalBuf.buf;\n    let idxLocalBuf = render.indexBuf.localBufs[phase];\n    let idxBuf = idxLocalBuf.buf;\n    ensureFloatBufferSize(floatLocalBuf, 4);\n    ensureElementBufferSize(idxLocalBuf, 5);\n    if (mtx) {\n        mtx.mulVec3Affine_(a, _lineA);\n        mtx.mulVec3Affine_(b, _lineB);\n        // thickness = thickness;\n        // n = n ? mtx.mulVec3ProjVec(n) : undefined;\n    } else {\n        _lineA.copy_(a);\n        _lineB.copy_(b);\n    }\n\n    dash = dash ?? 0;\n    _lineDir.x = _lineB.x - _lineA.x;\n    _lineDir.y = _lineB.y - _lineA.y;\n    _lineDir.z = _lineB.z - _lineA.z;\n    let len = _lineDir.len();\n    let dirLen = 1.0 / len;\n    _lineDir.x *= dirLen;\n    _lineDir.y *= dirLen;\n    _lineDir.z *= dirLen;\n\n    let pt = [_lineA, _lineA, _lineB, _lineB];\n    n = n ?? Vec3.zero;\n\n    let i = floatLocalBuf.usedEls * floatLocalBuf.strideFloats;\n    let k = idxLocalBuf.usedVerts;\n    for (let j = 0; j < 4; j++) {\n        buf[i + 0] = pt[j].x;\n        buf[i + 1] = pt[j].y;\n        buf[i + 2] = pt[j].z;\n        buf[i + 3] = _lineDir.x;\n        buf[i + 4] = _lineDir.y;\n        buf[i + 5] = _lineDir.z;\n        buf[i + 6] = _lineDir.x;\n        buf[i + 7] = _lineDir.y;\n        buf[i + 8] = _lineDir.z;\n        buf[i + 9] = color.x;\n        buf[i + 10] = color.y;\n        buf[i + 11] = color.z;\n        buf[i + 12] = color.w;\n        buf[i + 13] = thickness;\n        buf[i + 14] = 1.0;\n        buf[i + 15] = n.x;\n        buf[i + 16] = n.y;\n        buf[i + 17] = n.z;\n        buf[i + 18] = dash;\n        buf[i + 19] = j < 2 ? 0 : len;\n        i += floatLocalBuf.strideFloats;\n        idxBuf[k + j] = floatLocalBuf.usedEls + j;\n    }\n    idxBuf[k + 4] = 0xffffffff;\n    floatLocalBuf.usedEls += 4;\n    idxLocalBuf.usedVerts += 5;\n}\n\nlet _lineSegBufs = new Float32Array(2 * 3);\nlet _dir = _lineSegBufs.subarray(0, 3);\nlet _prevDir = _lineSegBufs.subarray(3, 6);\nlet _ptsTransformed = new Float32Array(0);\nexport function drawLineSegs(render: ILineRender, pts: Float32Array, opts: ILineOpts) {\n    let phase = render.sharedRender.activePhase;\n    let floatLocalBuf = render.floatBuf.localBufs[0];\n    let buf = floatLocalBuf.buf;\n\n    let idxLocalBuf = render.indexBuf.localBufs[phase];\n    let idxBuf = idxLocalBuf.buf;\n\n    let ptsLen = pts.length;\n    let n = (opts.n ?? Vec3.zero).clone();\n\n    if (opts.mtx) {\n        if (_ptsTransformed.length < pts.length) {\n            _ptsTransformed = new Float32Array(pts.length);\n        }\n        for (let i = 0; i < pts.length; i += 3) {\n            opts.mtx.mulVec3AffineArr_(pts, i, _ptsTransformed, i);\n        }\n        pts = _ptsTransformed;\n        opts.mtx.mulVec3AffineVec_(n, n);\n    }\n\n    let nPts = ptsLen / 3 + (opts.closed ? 1 : 0);\n\n    ensureFloatBufferSize(floatLocalBuf, nPts * 4);\n    ensureElementBufferSize(idxLocalBuf, nPts * 4 + 1); // +1 for the primitive restart\n\n    if (opts.closed) {\n        Vec3Buf.sub_(pts, 0, pts, ptsLen - 3, _prevDir, 0);\n        Vec3Buf.normalize_(_prevDir, 0, _prevDir, 0);\n    }\n\n    let dash = opts.dash ?? 0;\n    let cx = opts.color.x;\n    let cy = opts.color.y;\n    let cz = opts.color.z;\n    let cw = opts.color.w;\n    let thick = opts.thick;\n    let nx = n.x;\n    let ny = n.y;\n    let nz = n.z;\n    let linePos = 0;\n\n    for (let i = 0; i < nPts; i++) {\n        let pOff = i * 3;\n        if (opts.closed && i === nPts - 1) {\n            pOff = 0;\n        }\n\n        let segLen = 0.0;\n        if ((!opts.closed && i < nPts - 1) || (opts.closed && i !== nPts - 2)) {\n            Vec3Buf.sub_(pts, pOff + 3, pts, pOff, _dir, 0);\n            segLen = Vec3Buf.len_(_dir, 0);\n            Vec3Buf.normalize_(_dir, 0, _dir, 0);\n\n        } else if (opts.closed && i === nPts - 2) {\n            // wrap around\n            Vec3Buf.sub_(pts, 0, pts, ptsLen - 3, _dir, 0);\n            segLen = Vec3Buf.len_(_dir, 0);\n            Vec3Buf.normalize_(_dir, 0, _dir, 0);\n        }\n\n        let bufOff = floatLocalBuf.usedEls * floatLocalBuf.strideFloats;\n        let idxOff = idxLocalBuf.usedVerts;\n\n        let dirA = (i == 0 && !opts.closed) ? _dir : _prevDir;\n        let dirB = (i == nPts - 1 && !opts.closed) ? _prevDir : _dir;\n\n        let idxCount = opts.closed && i === nPts - 1 ? 2 : 4;\n\n        for (let j = 0; j < idxCount; j++) {\n            Vec3Buf.copy_(pts, pOff, buf, bufOff);\n            Vec3Buf.copy_(dirA, 0, buf, bufOff + 3);\n            Vec3Buf.copy_(dirB, 0, buf, bufOff + 6);\n            buf[bufOff + 9] = cx;\n            buf[bufOff + 10] = cy;\n            buf[bufOff + 11] = cz;\n            buf[bufOff + 12] = cw;\n            buf[bufOff + 13] = thick;\n            buf[bufOff + 14] = j > 2 ? 0.0 : 1.0;\n            buf[bufOff + 15] = nx;\n            buf[bufOff + 16] = ny;\n            buf[bufOff + 17] = nz;\n            buf[bufOff + 18] = dash;\n            buf[bufOff + 19] = linePos;\n            bufOff += floatLocalBuf.strideFloats;\n            idxBuf[idxOff + j] = floatLocalBuf.usedEls + j;\n        }\n\n        floatLocalBuf.usedEls += idxCount;\n        idxLocalBuf.usedVerts += idxCount;\n        linePos += segLen;\n\n        Vec3Buf.copy_(_dir, 0, _prevDir, 0);\n    }\n\n    idxBuf[idxLocalBuf.usedVerts] = 0xffffffff;\n    idxLocalBuf.usedVerts += 1;\n}\n\nexport function uploadAllLines(render: ILineRender) {\n    let gl = render.gl;\n    uploadFloatBuffer(gl, render.floatBuf);\n    uploadElementBuffer(gl, render.indexBuf)\n}\n\nexport function renderAllLines(render: ILineRender, renderPhase: RenderPhase) {\n    let gl = render.gl;\n    let localIdxBuf = render.indexBuf.localBufs[renderPhase];\n    if (localIdxBuf.usedVerts === 0) {\n        return;\n    }\n\n    gl.disable(gl.CULL_FACE);\n    gl.depthMask(false);\n\n    gl.useProgram(render.lineShader.program);\n    gl.bindVertexArray(render.vao);\n\n    let locs = render.lineShader.locs;\n    gl.uniform2f(locs.u_viewSizeInv, 1.0 / gl.canvas.width, 1.0 / gl.canvas.height);\n    gl.drawElements(gl.TRIANGLE_STRIP, localIdxBuf.usedVerts, gl.UNSIGNED_INT, localIdxBuf.glOffsetBytes);\n\n    gl.depthMask(true);\n}\n\nexport function resetLineRender(render: ILineRender) {\n    resetFloatBufferMap(render.floatBuf);\n    resetElementBufferMap(render.indexBuf);\n}\n","import { IModelLayout } from \"./GptModelLayout\";\nimport { IProgramState } from \"./Program\";\nimport { Mat4f } from \"@/src/utils/matrix\";\nimport { BoundingBox3d, Vec3 } from \"@/src/utils/vector\";\nimport { IRenderView } from \"./render/modelRender\";\nimport { clamp } from \"../utils/data\";\n\nexport interface ICamera {\n    camPos: Vec3;\n    camPosModel: Vec3;\n    lookAtMtx: Mat4f;\n    viewMtx: Mat4f;\n    modelMtx: Mat4f;\n    center: Vec3;\n    angle: Vec3; // x = degrees about z axis, y = degrees above the x-y plane; z = zoom\n\n    centerDesired?: Vec3;\n    // separated into rotation & zoom since they behave differently, and we want to control them separately\n    // probably should just split out the zoom into a separate variable\n    angleDesired?: Vec3;\n    angleZDesired?: number;\n\n    desiredCamera?: ICameraPos;\n    desiredCameraTransition?: {\n        t: number;\n        initialPos: ICameraPos;\n        targetPos: ICameraPos;\n    },\n\n    transition: {\n        centerT?: number;\n        angleT?: number;\n        angleZT?: number;\n\n        centerInit?: Vec3;\n        angleInit?: Vec3;\n        angleZInit?: number;\n    }\n}\n\nexport interface ICameraPos {\n    center: Vec3;\n    angle: Vec3;\n}\n\n\nexport function cameraToMatrixView(camera: ICamera) {\n    while (camera.angle.x < 0) camera.angle.x += 360;\n    while (camera.angle.x > 360) camera.angle.x -= 360;\n\n    let camZoom = camera.angle.z;\n    let angleX = camera.angle.x * Math.PI / 180;\n    let angleY = camera.angle.y * Math.PI / 180;\n\n    let dist = 200 * camZoom;\n    let camZ = dist * Math.sin(angleY);\n    let camX = dist * Math.cos(angleY) * Math.cos(angleX);\n    let camY = dist * Math.cos(angleY) * Math.sin(angleX);\n\n    let camLookat = camera.center;\n    let camPos = new Vec3(camX, camY, camZ).add(camLookat);\n\n    return {\n        lookAt: Mat4f.fromLookAt(camPos, camLookat, new Vec3(0, 0, 1)),\n        camPos,\n    };\n}\n\nexport function genModelViewMatrices(state: IProgramState, layout: IModelLayout, modelOffset: Vec3 = Vec3.zero) {\n    let { camera } = state;\n\n    let bb = new BoundingBox3d();\n    for (let c of layout.cubes) {\n        let tl = new Vec3(c.x, c.y, c.z).add(modelOffset);\n        let br = new Vec3(c.x + c.dx, c.y + c.dy, c.z + c.dz).add(modelOffset);\n        bb.addInPlace(tl);\n        bb.addInPlace(br);\n    }\n    let localDist = bb.size().len();\n\n    let { lookAt, camPos } = cameraToMatrixView(camera);\n    let dist = 200 * camera.angle.z;\n\n    // let persp = Mat4f.fromPersp(40, state.render.size.x / state.render.size.y, dist / 100, localDist + Math.max(dist * 2, 100000));\n    let persp = Mat4f.fromPersp(40, state.render.size.x / state.render.size.y, 100, 10000000);\n    let viewMtx = persp.mul(lookAt);\n    let modelMtx = new Mat4f();\n    modelMtx[0] = 1.0;\n    modelMtx[5] = 0.0;\n    modelMtx[6] = -1.0;\n    modelMtx[9] = -1.0;\n    modelMtx[10] = 0.0;\n\n    state.camera.modelMtx = modelMtx;\n    state.camera.viewMtx = viewMtx;\n    state.camera.camPos = camPos;\n    state.camera.camPosModel = modelMtx.invert().mulVec3Affine(camPos);\n    state.camera.lookAtMtx = lookAt;\n}\n\nexport function camScaleToScreen(state: IProgramState, modelPt: Vec3) {\n    let camDist = state.camera.camPosModel.dist(modelPt);\n    return camDist / state.render.size.y * 5.0;\n}\n\nexport function cameraMoveToDesired(camera: ICamera, dt: number) {\n\n    // This is making me nauseous. Gonna do jump-to instead of smooth transition for now.\n\n    // We'll use the velocity to check if we've applied the desired value, so we know when to\n    // modify the main camera\n    let duration = 1000 * 1;\n\n    if (camera.centerDesired && camera.transition.centerT === undefined) {\n        camera.transition.centerInit = camera.center;\n        camera.transition.centerT = 0.0;\n    }\n    if (camera.transition.centerT !== undefined) {\n        camera.transition.centerT += dt / duration;\n        if (camera.transition.centerT > 1.0) {\n            camera.transition.centerT = undefined;\n            camera.transition.centerInit = undefined;\n            camera.centerDesired = undefined;\n        } else if (camera.transition.centerInit && camera.centerDesired) {\n            camera.center = camera.transition.centerInit!.lerp(camera.centerDesired!, camera.transition.centerT);\n        }\n    }\n\n    if (camera.angleDesired && camera.transition.angleT === undefined) {\n        camera.transition.angleInit = camera.angle;\n        camera.transition.angleT = 0.0;\n    }\n    if (camera.transition.angleT !== undefined) {\n        camera.transition.angleT += dt / duration;\n        if (camera.transition.angleT > 1.0) {\n            camera.transition.angleT = undefined;\n            camera.transition.angleInit = undefined;\n            camera.angleDesired = undefined;\n        } else if (camera.transition.angleInit && camera.angleDesired) {\n            camera.angle = camera.transition.angleInit!.lerp(camera.angleDesired!, camera.transition.angleT);\n        }\n    }\n}\n\nexport function updateCamera(state: IProgramState, view: IRenderView) {\n\n    let transition = state.camera.desiredCameraTransition;\n\n    if (transition) {\n        if (transition.t < 1) {\n            transition.t = clamp(transition.t + view.dt / 1000 * 1.5, 0, 1);\n            let src = transition.initialPos;\n            let dest = transition.targetPos;\n\n            state.camera.angle = src.angle.lerp(dest.angle, transition.t);\n            state.camera.center = src.center.lerp(dest.center, transition.t);\n            view.markDirty();\n        } else {\n            state.camera.desiredCameraTransition = undefined;\n        }\n    }\n\n    // take a frame before we start moving the camera\n    if (state.camera.desiredCamera) {\n        state.camera.desiredCameraTransition = {\n            t: 0,\n            initialPos: {\n                center: state.camera.center,\n                angle: state.camera.angle,\n            },\n            targetPos: state.camera.desiredCamera,\n        }\n        state.camera.desiredCamera = undefined;\n        view.markDirty();\n    }\n}\n\n\nexport interface ISpringConfig {\n    tension: number;\n    mass: number;\n    friction?: number;\n    extra?: number;\n}\n\nexport function applySpringStep(pos: Vec3, target: Vec3, vel: Vec3 | null | undefined, dt: number, config: ISpringConfig) {\n    // default to critically damped\n    let friction = config.friction ?? 2 * Math.sqrt(config.mass * config.tension);\n    let dtS = dt / 1000;\n    vel = vel ?? new Vec3();\n    let dist = pos.sub(target);\n    let springExtra = dist.lenSq() === 0.0 ? new Vec3() : dist.normalize().mul(config.extra ?? 0);\n    let springF = (dist.add(springExtra)).mul(-config.tension);\n    let dampF = vel.mul(-friction);\n    let accel = springF.add(dampF).mul(1.0 / config.mass);\n\n    vel = vel.add(accel.mul(dtS));\n    pos = pos.add(vel.mul(dtS));\n    return { pos, vel };\n}\n","import { cellPosition, IBlkDef, IModelLayout } from \"./GptModelLayout\";\nimport { addLine } from \"./render/lineRender\";\nimport { IRenderState } from \"./render/modelRender\";\nimport { measureTextWidth, writeTextToBuffer } from \"./render/fontRender\";\nimport { lerp, lerpSmoothstep } from \"@/src/utils/math\";\nimport { Mat4f } from \"@/src/utils/matrix\";\nimport { Dim, Vec3, Vec4 } from \"@/src/utils/vector\";\nimport { DimStyle, dimStyleColor, dimStyleText } from \"./walkthrough/WalkthroughTools\";\nimport { IProgramState } from \"./Program\";\nimport { camScaleToScreen } from \"./Camera\";\nimport { isNil } from \"@/src/utils/data\";\n\nexport function blockDimension(state: IProgramState, layout: IModelLayout, blk: IBlkDef, dim: Dim, style: DimStyle, t: number) {\n    let render = state.render;\n\n    // Render |----- T ------| along the appropriate dimension\n\n    let { vecId } = dimConsts(dim);\n    let { cx } = dimProps(blk, dim);\n\n    let offVecId = vecId === 0 ? 1 : 0;\n\n    let text = (blk.customDimText && blk.customDimText[dim]) || dimStyleText(style);\n    if (style === DimStyle.None) {\n        return;\n    }\n\n    let start = cellPosition(layout, blk, dim, 0);\n    let end = cellPosition(layout, blk, dim, cx - 1) + layout.cell;\n    let mid = (end + start) / 2;\n    let midPos = dim === Dim.X ? new Vec3(mid, blk.y + blk.dz, blk.z + blk.dz) : new Vec3(blk.x, mid, blk.z + blk.dz);\n    let mul = dim === Dim.X ? -1.0 : 1.0;\n\n    let scale = camScaleToScreen(state, midPos);\n    scale = Math.min(scale, 1);\n\n    let fontSize = 2.5 * scale;\n    let tw = measureTextWidth(render.modelFontBuf, text, fontSize);\n    let th = fontSize;\n    let textPad = dim === Dim.X ? tw / 2 + fontSize * 0.4 : dim === Dim.Y ? th / 2 + fontSize * 0.4 : 0;\n\n    let botPad = fontSize * 0.3;\n    let edgeH2 = fontSize / 2 * 0.5;\n\n    let color = dimStyleColor(style).mul(t);\n\n    let zOffset = 0.1;\n\n    let textPos = new Vec3(blk.x, blk.y + blk.dy, blk.z + blk.dz + zOffset)\n        .setAt(vecId, mid)\n        .withAddAt(offVecId, -mul * (fontSize / 2 + botPad));\n\n    let textYOff = 0;\n    let tooSmall = tw > end - start - textPad * 2;\n    if (tooSmall) {\n        textYOff = mul * fontSize;\n    }\n\n    let mtx = Mat4f.fromTranslation(textPos);\n\n    let textDx = dim === Dim.X ? -tw / 2 : dim === Dim.Y ? -tw / 2 : 0;\n    let textDy = dim === Dim.X ? -textYOff - fontSize / 2 : dim === Dim.Y ? -fontSize / 2 : 0;\n\n    writeTextToBuffer(render.modelFontBuf, text, color, textDx, textDy, fontSize, mtx);\n\n    // let yOff = fontSize / 2 + botPad;\n    let lX = blk.x;\n    let lY = blk.y + blk.dy;\n    let lZ = blk.z + blk.dz + zOffset;\n    let thickness = fontSize * 0.02;\n    let n = new Vec3(0, 0, 1);\n\n    if (tooSmall) {\n        textPad = 0;\n\n    }\n\n    let base = new Vec3(lX, lY, lZ).withAddAt(offVecId, -mul * (fontSize / 2 + botPad));\n    let vStart = base.withSetAt(vecId, start);\n    let vEnd = base.withSetAt(vecId, end);\n    let vMid1 = base.withSetAt(vecId, mid - textPad);\n    let vMid2 = base.withSetAt(vecId, mid + textPad);\n\n    addLine(render.lineRender, thickness, color, vStart, vMid1, n);\n    addLine(render.lineRender, thickness, color, vEnd, vMid2, n);\n    addLine(render.lineRender, thickness, color, vStart.withAddAt(offVecId, edgeH2), vStart.withAddAt(offVecId, -edgeH2), n);\n    addLine(render.lineRender, thickness, color, vEnd.withAddAt(offVecId, edgeH2), vEnd.withAddAt(offVecId, -edgeH2), n);\n}\n\nexport function blockIndex(state: IRenderState, layout: IModelLayout, blk: IBlkDef, dim: Dim, style: DimStyle, idx: number, cellOffset: number, t: number) {\n    if (t === 0) return;\n\n    let fontSize = 2;\n    let text = DimStyle[style] + '=' + Math.round(idx).toFixed(0);\n    let font = '';\n\n    let tw = measureTextWidth(state.modelFontBuf, text, fontSize, font);\n\n    let cellL = cellPosition(layout, blk, dim, Math.floor(idx)) + layout.cell / 2;\n    let cellR = cellPosition(layout, blk, dim, Math.ceil(idx)) + layout.cell / 2;\n    let pos = lerp(cellL, cellR, idx - Math.floor(idx)) + lerpSmoothstep(0, cellOffset, Math.min(idx, 1));\n    let botPad = fontSize * 0.5;\n\n    let color = dimStyleColor(style).mul(t);\n\n    let mtx = Mat4f.fromTranslation(new Vec3(pos, blk.y - botPad, blk.z + blk.dz));\n\n    writeTextToBuffer(state.modelFontBuf, text, color, -tw / 2, -fontSize, fontSize, mtx, font);\n}\n\ninterface IDimConst {\n    vecId: number;\n    xName: string;\n    dxName: string;\n    cxName: string;\n    offXName: string;\n    sizeXName: string;\n}\n\nlet dimConstX: IDimConst = { vecId: 0, xName: 'x', dxName: 'dx', cxName: 'cx', offXName: 'offX', sizeXName: 'sizeX' };\nlet dimConstY: IDimConst = { vecId: 1, xName: 'y', dxName: 'dy', cxName: 'cy', offXName: 'offY', sizeXName: 'sizeY' };\nlet dimConstZ: IDimConst = { vecId: 2, xName: 'z', dxName: 'dz', cxName: 'cz', offXName: 'offZ', sizeXName: 'sizeZ' };\n\nexport function dimConsts(dim: Dim) {\n    return dim === Dim.X ? dimConstX : dim === Dim.Y ? dimConstY : dimConstZ;\n}\n\nexport function dimProps(blk: IBlkDef, dim: Dim) {\n    switch (dim) {\n        case Dim.X: return { x: blk.x, cx: blk.cx, dx: blk.dx, rangeOffsets: blk.rangeOffsetsX, offX: blk.offX ?? 0, sizeX: blk.sizeX ?? blk.cx };\n        case Dim.Y: return { x: blk.y, cx: blk.cy, dx: blk.dy, rangeOffsets: blk.rangeOffsetsY, offX: blk.offY ?? 0, sizeX: blk.sizeY ?? blk.cy };\n        case Dim.Z: return { x: blk.z, cx: blk.cz, dx: blk.dz, rangeOffsets: blk.rangeOffsetsZ, offX: blk.offZ ?? 0, sizeX: blk.sizeZ ?? blk.cz };\n    }\n}\n\nexport function duplicateGrid(layout: IModelLayout, blk: IBlkDef): IBlkDef {\n    let newBlk = { ...blk, access: blk.access ? { ...blk.access } : undefined };\n    newBlk.name = '';\n    layout.cubes.push(newBlk);\n    return newBlk;\n}\n\nexport function splitGridForHighlight(layout: IModelLayout, blk: IBlkDef, dim: Dim, xSplit: number, splitAmt: number = 0) {\n    let { x, cx, rangeOffsets } = dimProps(blk, dim);\n\n    if (cx <= 1) {\n        return blk;\n    }\n\n    // if there exists some rangeOffsets in our dim, then we iter over the sub-blocks, and split them\n    if (rangeOffsets && blk.subs) {\n        for (let s of blk.subs) {\n            let res = splitGrid(layout, s, dim, xSplit, splitAmt);\n            if (res) {\n                return res;\n            }\n        }\n    }\n\n    return splitGrid(layout, blk, dim, xSplit, splitAmt);\n}\n\nexport function splitGrid(layout: IModelLayout, blk: IBlkDef, dim: Dim, xSplit: number, splitAmt: number) {\n    // generate several new blocks (let's say up to 5) that are neighbouring the zSplit point\n\n    // main-left, left, center, right, main-right\n\n    // choose center as floor(zSplit), left is floor(zSplit) - 1, right is floor(zSplit) + 1\n    // main-left and main-right are the remaining\n    // only create those if there's space\n\n    // The splitAmt governs the overall gap between blocks\n    // Want a rotating-block-under-examination effect. When zSplit is right down the center (x + 0.5),\n    // have max seperation, and effectively join left & right with their main\n    // For non 0.5 zSplits, will show 2 gaps\n\n    let { offX, sizeX } = dimProps(blk, dim);\n\n    // if (cxSub <= 1 && ) {\n    //     return blk;\n    // }\n\n    let blocks: IBlkDef[] = [];\n    let rangeOffsets: [number, number][] = [];\n\n    let colX = Math.floor(xSplit) - offX;\n    if (colX < 0 || colX >= sizeX) {\n        return null;\n    }\n\n    if (sizeX <= 1) {\n        return blk;\n    }\n\n    function addSubBlockLocal(iStart: number, iEnd: number, xOffset: number) {\n        let res = addSubBlock(layout, blk, dim, iStart, iEnd, xOffset);\n        if (res) {\n            blocks.push(res.subBlock);\n            rangeOffsets.push(res.rangeOffset);\n        }\n        return res?.subBlock ?? null;\n    }\n\n    let midBlock: IBlkDef | null;\n    if (splitAmt === 0) {\n        addSubBlockLocal(0, colX, 0.0);\n        midBlock = addSubBlockLocal(colX, colX + 1, 0.0);\n        addSubBlockLocal(colX + 1, sizeX, 0.0);\n\n    } else {\n        let scale = 0.5;\n        let fract = (xSplit - colX - 0.5) * scale + 0.5;\n\n        let addMidBlockBefore = fract + scale < 1.0;\n        let addMidBlockAfter = fract - scale > 0.0;\n        let offset = lerpSmoothstep(-splitAmt, 0, (xSplit - 0.5) * scale + 0.5);\n\n        addSubBlockLocal(0, colX - (addMidBlockBefore ? 1 : 0), offset + 0.0);\n\n        if (addMidBlockBefore) {\n            addSubBlockLocal(colX - 1, colX, offset + lerpSmoothstep(splitAmt, 0, fract + scale));\n        }\n\n        midBlock = addSubBlockLocal(colX, colX + 1, offset + lerpSmoothstep(splitAmt, 0, fract));\n\n        if (addMidBlockAfter) {\n            addSubBlockLocal(colX + 1, colX + 2, offset + lerpSmoothstep(splitAmt, 0, fract - scale));\n        }\n\n        addSubBlockLocal(colX + (addMidBlockAfter ? 2 : 1), sizeX, offset + splitAmt);\n    }\n\n    if (blocks.length > 0) {\n        if (dim === Dim.X) blk.rangeOffsetsX = rangeOffsets;\n        if (dim === Dim.Y) blk.rangeOffsetsY = rangeOffsets;\n        if (dim === Dim.Z) blk.rangeOffsetsZ = rangeOffsets;\n        blk.subs = blocks;\n        return midBlock;\n\n    } else {\n        return null;\n    }\n}\n\ninterface ISubBlockInfo {\n    subBlock: IBlkDef;\n    rangeOffset: [number, number];\n}\n\nfunction addSubBlock(layout: IModelLayout, blk: IBlkDef, dim: Dim, iStart: number, iEnd: number, xOffset: number): ISubBlockInfo | null {\n    let { x, cx, sizeX, offX } = dimProps(blk, dim);\n    let { vecId, xName, dxName, offXName, sizeXName } = dimConsts(dim);\n\n    if (iStart >= iEnd || iEnd <= 0 || iStart >= sizeX) {\n        return null;\n    }\n    // iEnd = iStart + 1;\n    let scale = (iEnd - iStart) / sizeX;\n    let translate = iStart / sizeX;\n\n    let mtx = Mat4f.fromScaleTranslation(new Vec3(1, 1, 1).setAt(vecId, scale), new Vec3().setAt(vecId, translate));\n\n    let subBlock: IBlkDef = {\n        ...blk,\n        [dxName]: (iEnd - iStart) * layout.cell,\n        // [cxName]: iEnd - iStart,\n        access: blk.access && { ...blk.access },\n        localMtx: (blk.localMtx ?? new Mat4f()).mul(mtx),\n        [xName]: x + (iStart * layout.cell + xOffset),\n        [offXName]: iStart + offX,\n        [sizeXName]: iEnd - iStart,\n    };\n    // console.log('I am the new subBlock!', subBlock)\n    return { subBlock, rangeOffset: [iEnd, xOffset] };\n}\n\n\nexport function splitGridAll(layout: IModelLayout, blk: IBlkDef, dim: Dim) {\n    let { dx } = dimProps(blk, dim);\n\n    let nCells = Math.ceil(dx / layout.cell);\n\n    let blocks: IBlkDef[] = [];\n    let rangeOffsets: [number, number][] = [];\n\n    for (let i = 0; i < nCells; i += 1) {\n        let res = addSubBlock(layout, blk, dim, i, i + 1, 0)!;\n        blocks.push(res.subBlock);\n        rangeOffsets.push(res.rangeOffset);\n    }\n\n    if (dim === Dim.X) blk.rangeOffsetsX = rangeOffsets;\n    if (dim === Dim.Y) blk.rangeOffsetsY = rangeOffsets;\n    if (dim === Dim.Z) blk.rangeOffsetsZ = rangeOffsets;\n    blk.subs = blocks;\n\n    return blocks;\n}\n\nexport interface IColorMix {\n    color1?: Vec4;\n    color2: Vec4;\n    mixes: number[];\n}\n\nexport function renderIndexes(state: IRenderState, layout: IModelLayout, blk: IBlkDef, color: Vec4, t: number, count: number = 4, offset: number = 0, data: Float32Array | null = null, mix?: IColorMix) {\n    let { modelFontBuf: fontBuf, lineRender } = state;\n\n    // Just rendering the 0, 1, 2 tokens, with plans to advance to the GPT text model etc\n\n    count = count || 3;\n\n    if (!data) {\n        data = new Float32Array(count);\n        for (let i = 0; i < count; i += 1) {\n            data[i] = i + offset;\n        }\n    }\n\n    // may scale with view\n    let em = layout.cell * 1;\n\n    let yLower = blk.y - em - layout.cell;// layout.cell * 2;\n\n    let strParts = [];\n    let textOffset = 0;\n    let i = 0;\n    for (let a of data) {\n        if (i >= count) {\n            break;\n        }\n        let w = measureTextWidth(fontBuf, '' + a, em);\n        let space = Math.max(layout.cell, w);\n        strParts.push({ val: a, textOffset, w, i, space });\n        textOffset += space;\n        i += 1;\n    }\n\n    let leftPos = cellPosition(layout, blk, Dim.X, offset);\n\n    let mtxRes = Mat4f.fromTranslation(new Vec3(0, yLower, 0));\n    let totalOffset = leftPos - textOffset / 2 + layout.cell * count / 2;\n    color = color.mul(t);\n\n    for (let a of strParts) {\n        let x = totalOffset + a.textOffset + a.space / 2 - a.w / 2;\n\n        let drawColor = color;\n        if (mix) {\n            let val = mix.mixes[a.i];\n            if (val > 0.0) {\n                drawColor = Vec4.lerp(color, mix.color2, val);\n            }\n        }\n\n        writeTextToBuffer(fontBuf, '' + a.val, drawColor, x, 0, em, mtxRes);\n\n        let tx = x + a.w / 2;\n        let bx = cellPosition(layout, blk, Dim.X, a.i + offset) + layout.cell * 0.5;\n        let top = yLower + em;\n        let delta = 0.1 * em;\n        let bot = Math.max(blk.y - 0.3, top);\n        let thick = em * 0.02;\n        // addLine(lineRender, thick, color, new Vec3(tx, 0, top), new Vec3(tx, 0, top - delta));\n        addLine(lineRender, thick, drawColor, new Vec3(tx, top + delta, 0), new Vec3(bx, bot - delta, 0), new Vec3(0, 0, 1));\n        // addLine(lineRender, thick, color, new Vec3(bx, 0, bot + delta), new Vec3(bx, 0, bot));\n    }\n}\n\nexport function indexMappingLines(state: IRenderState, layout: IModelLayout, blkSrc: IBlkDef, blkDest: IBlkDef, color: Vec4, srcPad: number, destPad: number, srcIdx: number, destIdx: number, lineFract: number) {\n\n    // assume all in x-y plane, and idx's are in x, and src is above dest\n\n    let top = blkSrc.y + blkSrc.dy + srcPad;\n    let bot = blkDest.y - destPad;\n    let midY = lerp(top, bot, lineFract);\n    let z = 0; // blkSrc.z + blkSrc.dz;\n\n    let srcX = cellPosition(layout, blkSrc, Dim.X, srcIdx) + layout.cell * 0.5;\n    let destX = cellPosition(layout, blkDest, Dim.X, destIdx) + layout.cell * 0.5;\n\n    // dogleg line, using only horizontal and vertical lines\n\n    let n = new Vec3(0, 0, 1);\n    let thick = layout.cell * 0.025;\n    addLine(state.lineRender, thick, color, new Vec3(srcX, top, z), new Vec3(srcX, midY, z), n);\n    addLine(state.lineRender, thick, color, new Vec3(srcX, midY, z), new Vec3(destX, midY, z), n);\n    addLine(state.lineRender, thick, color, new Vec3(destX, midY, z), new Vec3(destX, bot, z), n);\n}\n\n/* Returns all subblocks along a given dimension that overlap the provided range\n\nUsed in combination with splitGrid. To find all blocks up to, but not including the target idx 3, use:\n\n    findSubBlocks(blk, Dim.X, null, 3)\n\nTo find the exact block at idx 3, use:\n\n    findSubBlocks(blk, Dim.X, 3, 3)\n\nTo find all blocks after idx 3, use:\n\n    findSubBlocks(blk, Dim.X, 4, null)\n\n*/\nexport function findSubBlocks(blk: IBlkDef, dim: Dim, idxLow: number | null, idxHi: number | null) {\n    if (!blk.subs) {\n        return [];\n    }\n\n    let offsets = dim === Dim.X ? blk.rangeOffsetsX : dim === Dim.Y ? blk.rangeOffsetsY : blk.rangeOffsetsZ;\n    idxLow = idxLow === null ? null : Math.floor(idxLow);\n    idxHi = idxHi === null ? null : Math.floor(idxHi);\n\n    let subBlocks: IBlkDef[] = [];\n    let startIdx = 0;\n    for (let i = 0; i < blk.subs.length; i += 1) {\n        let endIdx = offsets?.[i]?.[0];\n        if (isNil(endIdx)) {\n            break;\n        }\n        if ((idxLow === null || idxLow < endIdx) && (idxHi === null || idxHi >= startIdx)) {\n            subBlocks.push(blk.subs[i]);\n        }\n        startIdx = endIdx;\n    }\n    return subBlocks;\n}\n\nexport enum TextAlignVert {\n    Top,\n    Middle,\n    Bottom,\n}\n\nexport enum TextAlignHoriz {\n    Left,\n    Center,\n    Right,\n}\n\nexport interface IFontConfig {\n    color?: Vec4; // default black\n    align?: TextAlignHoriz; // default left\n    valign?: TextAlignVert; // default top\n    size?: number; // default 1\n    face?: string; // default 'Roboto-Regular'\n}\n\nexport function drawTextOnModel(state: IRenderState, text: string, pos: Vec3, cfg: IFontConfig) {\n    let { modelFontBuf: fontBuf } = state;\n\n    let color = cfg.color || new Vec4(0, 0, 0, 1);\n    let align = cfg.align || TextAlignHoriz.Left;\n    let valign = cfg.valign || TextAlignVert.Top;\n    let size = cfg.size || 1;\n    let face = cfg.face;\n\n    let w = measureTextWidth(fontBuf, text, size);\n    let h = size;\n\n    let x = pos.x;\n    let y = pos.y;\n    let z = pos.z;\n\n    if (align === TextAlignHoriz.Center) {\n        x -= w / 2;\n    } else if (align === TextAlignHoriz.Right) {\n        x -= w;\n    }\n\n    if (valign === TextAlignVert.Middle) {\n        y -= h / 2;\n    } else if (valign === TextAlignVert.Bottom) {\n        y -= h;\n    }\n\n    let mtxRes = Mat4f.fromTranslation(new Vec3(x, y, 0));\n\n    writeTextToBuffer(fontBuf, text, color, 0, 0, size, mtxRes, face);\n}\n\n\nexport function addSourceDestCurveLine(state: IRenderState, layout: IModelLayout, srcBlk: IBlkDef, destBlk: IBlkDef, srcIdx: Vec3, destIdx: Vec3, color: Vec4) {\n    // assume always sampling in x-y plane\n    // so ignoring the z component of the idx's\n\n    let srcX = cellPosition(layout, srcBlk, Dim.X, srcIdx.x) + layout.cell * 0.5;\n    let srcY = cellPosition(layout, srcBlk, Dim.Y, srcIdx.y) + layout.cell * 0.5;\n    let srcZ = cellPosition(layout, srcBlk, Dim.Z, srcBlk.cz - 1) + layout.cell;\n\n    let destX = cellPosition(layout, destBlk, Dim.X, destIdx.x) + layout.cell * 0.5;\n    let destY = cellPosition(layout, destBlk, Dim.Y, destIdx.y) + layout.cell * 0.5;\n    let destZ = cellPosition(layout, destBlk, Dim.Z, destBlk.cz - 1) + layout.cell;\n\n    // want the curve to start & end at about 45deg from the x-y plane, and rise up in z\n    // projected along the x-y plane, the curve should be straight line\n    // we'll go for a circular arc, where the center of the circle is at the midpoint of the line, and at a fixed z height\n\n    // may have to deal with different z heights of the src & dest blocks\n    let srcPos = new Vec3(srcX, srcY, srcZ);\n    let destPos = new Vec3(destX, destY, destZ);\n    let midPos = srcPos.add(destPos).mul(0.5);\n\n    let cVec = Vec3.cross(srcPos.sub(destPos), new Vec3(1.2, 1, 0)).normalize().mul(10);\n    if (cVec.z > srcZ) {\n        cVec = cVec.mul(-1);\n    }\n    let circleCenter = cVec.add(midPos);\n\n\n    let radius = srcPos.dist(circleCenter);\n\n    let theta = Math.asin(srcPos.dist(midPos) / radius) * 2.0;\n\n    let n = Vec3.cross(circleCenter.sub(srcPos), circleCenter.sub(destPos)).normalize();\n\n    let rotateVec = srcPos.sub(circleCenter);\n\n    let count = 20;\n    let prevP = srcPos;\n    for (let i = 0; i <= count; i++) {\n        let t = i / count;\n        let p1 = circleCenter.add(rotateVec.rotateAbout(n, t * theta));\n        addLine(state.lineRender, 3, color, prevP, p1);\n        prevP = p1;\n    }\n    // arc from src to dest around circleCenter\n\n\n\n}\n","import { IBlkDef, IModelLayout } from \"../GptModelLayout\";\nimport { Mat4f } from \"@/src/utils/matrix\";\nimport { bindFloatAttribs, createFloatBuffer, createShaderProgram, IGLContext } from \"@/src/utils/shader\";\nimport { Dim, Vec3, Vec4 } from \"@/src/utils/vector\";\nimport { modelViewUboText, UboBindings } from \"./sharedRender\";\n\nexport type IThreadRender = ReturnType<typeof initThreadRender>;\n\nexport function initThreadRender(ctx: IGLContext) {\n\n\n    /* We'll construct a quad [0..1], [0..1] in the x-z plane that looks something like this:\n\n    It can go either vertical or horizontal, and in either forward or back.\n\n         [   ]\n         [ . ]\n         [ | ]\n         [ | ]\n         [ 0 ]\n\n    It's made up of a head, and a tail. Want a falloff pattern for the tail, and also a strength.\n    Likely clamp the tail for a max thickness/brightness.\n\n    Units are the same as the blocks, and threads are 1 unit thick (actually do multiple threads in one view).\n\n    Standard thread direction is towards the top, and in the first row of cells.\n    All cells below those are in the tail, with appropriate falloff.\n\n    The 3x2 threadDir matrix can be used to rotate the thread to any direction.\n\n    Any special effects like coloring one particular thread differently requires separate blocks.\n    E.g. first 5 columns have standard, next 1 has special, remaining have standard again.\n\n      0         1\n   0  ----------->  +x\n      | 0  0  0 |\n      | |  |  | |\n      | |  |  | |\n      | .  .  . |\n   1  v---------|\n\n      +y\n\n    */\n\n    let gl = ctx.gl;\n\n    let quadVbo = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, quadVbo);\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([\n        0, 1, 0,\n        1, 1, 0,\n        1, 0, 0,\n        0, 0, 0,\n    ]), gl.STATIC_DRAW);\n\n    let vao = gl.createVertexArray()!;\n    gl.bindVertexArray(vao);\n    gl.enableVertexAttribArray(0);\n    gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);\n\n    let instanceVbo = gl.createBuffer()!;\n    let instanceStride = bindFloatAttribs(gl, instanceVbo, { divisor: 1, locOffset: 2 }, [\n        { name: 'a_offset', size: 3 },\n        { name: 'a_size', size: 3 },\n        { name: 'a_nCells', size: 2 },\n        { name: 'a_threadDir', size: 2, nCols: 3 },\n    ]);\n    let instanceBuf = createFloatBuffer(gl, gl.ARRAY_BUFFER, instanceVbo, 1024, instanceStride, null);\n\n    let shader = createShaderProgram(ctx, 'thread', /*glsl*/`#version 300 es\n        precision highp float;\n        ${modelViewUboText}\n        layout(location = 0) in vec3 a_position;\n        layout(location = 1) in vec3 a_normal;\n\n        uniform vec3 u_offset;\n        uniform vec3 u_size;\n        uniform vec2 u_nCells;\n        uniform mat3x2 u_threadDir;\n        out vec3 v_normal;\n        out vec3 v_modelPos;\n        out vec2 v_blockPos;\n        out vec2 v_squarePos;\n        void main() {\n            vec2 localPos = u_threadDir * vec3(a_position.xy, 1);\n            vec3 model_pos = a_position * u_size + u_offset;\n            gl_Position = u_view * u_model * vec4(model_pos, 1);\n            v_normal = a_normal;\n            v_modelPos = model_pos;\n            v_blockPos = localPos * abs(u_threadDir * vec3(u_nCells, 0));\n            v_squarePos = localPos;\n        }\n    `, /*glsl*/`#version 300 es\n        precision highp float;\n        in vec3 v_normal;\n        in vec3 v_modelPos;\n        in vec2 v_blockPos;\n        in vec2 v_squarePos;\n        out vec4 o_color;\n        uniform vec2 u_nCells;\n        uniform vec3 u_camPos; // in model space\n        uniform vec3 u_baseColor;\n\n        void main() {\n            ivec2 blockPos = ivec2(v_blockPos - v_normal.xy * 0.0);\n\n            vec2 pxPerCell = 1.0 / fwidth(v_blockPos);\n            float maxPxPerCell = max(pxPerCell.x, pxPerCell.y);\n\n            vec4 color = vec4(0);\n\n            if (v_blockPos.y < 0.0) {\n                discard;\n            }\n\n            if (blockPos.y == 0) {\n                // draw head\n                vec2 d = fract(v_blockPos) - 0.5;\n                float d2 = sqrt(d.x * d.x + d.y * d.y);\n\n                // fwidth(d);\n                float deltad2_per_px = fwidth(d2); // fwidth(d2);\n\n                float t = 1.0 - smoothstep(0.45, 0.45 + 1.0 * deltad2_per_px, d2);\n\n                float t2 = smoothstep(0.35, 0.35 + 1.0 * deltad2_per_px, d2);\n\n                // if (d2 > 0.35 && d2 < 0.45) {\n                color = mix(color, vec4(u_baseColor, 1), min(t, t2));\n                // }\n            }\n\n            if (v_blockPos.y > (0.5 + 0.45)) {\n                float falloffY = 1.0 - clamp(v_blockPos.y / 10.0, 0.0, 1.0);\n\n                float cellPosX = fract(v_blockPos.x);\n                float distFromX = abs(cellPosX - 0.5);\n                // small side-to-side falloff based on distFromX for a glow effect\n                float falloffX = 1.0 - smoothstep(0.0, min(0.3, 5.0 * fwidth(v_blockPos.x)), distFromX);\n\n                color = mix(color, vec4(u_baseColor, 1), falloffX * falloffY);\n            }\n\n            // color = vec4(1, 0, 0, 1);\n\n            o_color = color;\n        }\n    `, [\n        'u_size', 'u_offset', 'u_baseColor', 'u_nCells', 'u_threadDir',\n    ], { uboBindings: { 'ModelViewUbo': UboBindings.ModelView } })!;\n\n\n    return {\n        gl,\n        vao,\n        quadVbo,\n        instanceVbo,\n        instanceBuf,\n        numInstances: 0,\n        shader,\n        threadInfos: [] as IThreadInfo[],\n    };\n}\n\nexport interface IThreadInfo {\n    pos: Vec3;\n    size: Vec3;\n    nCells: Vec3;\n    baseColor: Vec4;\n    threadDir: number[]; // 6 element, 3x2 matrix; col major\n}\n\nexport function drawThread(threadRender: IThreadRender, layout: IModelLayout, blk: IBlkDef, dim: Dim, x: number, y: number, cx: number, cy: number, color: Vec4) {\n    let threadDir = dim === Dim.X ? [0, -1,  1, 0,  0, 1] : [1, 0,  0, -1,  0, 1];\n    let pos = new Vec3(blk.x + x * layout.cell, blk.y + y * layout.cell, blk.z + blk.dz);\n    let size = new Vec3(cx * layout.cell, cy * layout.cell, blk.dz);\n    let nCells = new Vec3(cx, cy, 0);\n    threadRender.threadInfos.push({ pos, size, nCells, baseColor: color, threadDir });\n}\n\nexport function renderAllThreads(threadRender: IThreadRender) {\n    let { gl, shader, vao: threadVao } = threadRender;\n\n    gl.enable(gl.POLYGON_OFFSET_FILL);\n    gl.disable(gl.CULL_FACE);\n    gl.depthMask(false);\n    gl.polygonOffset(-1.0, -2.0);\n\n    let locs = shader.locs;\n    gl.useProgram(shader.program);\n    gl.bindVertexArray(threadVao);\n\n    for (let a of threadRender.threadInfos) {\n        let color = a.baseColor;\n        gl.uniform3f(locs.u_offset, a.pos.x, a.pos.y, a.pos.z);\n        gl.uniform3f(locs.u_size, a.size.x, a.size.y, a.size.z);\n        gl.uniform2f(locs.u_nCells, a.nCells.x, a.nCells.y);\n        gl.uniform3f(locs.u_baseColor, color.x, color.y, color.z);\n        gl.uniformMatrix3x2fv(locs.u_threadDir, false, a.threadDir);\n        gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);\n    }\n\n    threadRender.threadInfos = [];\n\n    gl.disable(gl.POLYGON_OFFSET_FILL);\n    gl.depthMask(true);\n}\n","import { ICamera } from \"./Camera\";\n\nexport interface ISavedState {\n    phase: number;\n    phaseTime: number;\n    camera: ICamera;\n}\n\nexport let SavedState = {\n    state: null as ISavedState | null,\n};\n","import { Mat4f } from \"@/src/utils/matrix\";\nimport { bindFloatAttribs, createElementBuffer, createFloatBuffer, createShaderProgram, ensureElementBufferSize, ensureFloatBufferSize, IGLContext, resetElementBufferMap, resetFloatBufferMap, uploadElementBuffer, uploadFloatBuffer } from \"@/src/utils/shader\";\nimport { Vec3, Vec4 } from \"@/src/utils/vector\";\nimport { ISharedRender, modelViewUboText, RenderPhase, UboBindings } from \"./sharedRender\";\n\nexport type ITriRender = ReturnType<typeof initTriRender>;\n\nexport function initTriRender(ctx: IGLContext, sharedRender: ISharedRender) {\n\n\n    /* Lines are made up of several quads, 1(?) for each line segment.\n\n    we'll use TRIANGLE_STRIP for rendering, and indexed arrays to support primitive restart.\n\n    Just gonna render each line segment separately. Corners too much of a pain for now!\n\n    Still need to get the quad to face the camera, and to be the right size.\n    I think it makes sense to do this after projection in the vertex shader.\n\n    */\n\n    let gl = ctx.gl;\n\n    let vao = gl.createVertexArray()!;\n    gl.bindVertexArray(vao);\n\n    let triVbo = gl.createBuffer()!;\n    let byteStride = bindFloatAttribs(gl, triVbo, {}, [\n        { name: 'a_pos', size: 3 },\n        { name: 'a_normal', size: 3 },\n        { name: 'a_color', size: 4 },\n        { name: 'a_uv', size: 2 },\n    ]);\n    let triFloatBuf = createFloatBuffer(gl, gl.ARRAY_BUFFER, triVbo, 1024, byteStride, null);\n\n    let triIbo = gl.createBuffer()!;\n    let triIndexBuf = createElementBuffer(gl, triIbo, 1024, sharedRender);\n\n    let triShader = createShaderProgram(ctx, 'triangles', /*glsl*/`#version 300 es\n        precision highp float;\n        ${modelViewUboText}\n        layout(location = 0) in vec3 a_position;\n        layout(location = 1) in vec3 a_normal;\n        layout(location = 2) in vec4 a_color;\n        layout(location = 3) in vec2 a_uv;\n        out vec4 v_color;\n        out vec2 v_uv;\n        out vec3 v_normal;\n        void main() {\n            gl_Position = u_view * u_model * vec4(a_position, 1);\n            v_color = a_color;\n            v_normal = a_normal;\n            v_uv = a_uv;\n        }\n    `, /*glsl*/`#version 300 es\n        precision highp float;\n        in vec2 v_uv;\n        in vec3 v_normal;\n        in vec4 v_color;\n        out vec4 o_color;\n\n        void main() {\n            o_color = v_color;\n        }\n    `, [], { uboBindings: { 'ModelViewUbo': UboBindings.ModelView } })!;\n\n    return {\n        gl,\n        vao,\n        vbo: triFloatBuf,\n        ibo: triIndexBuf,\n        triShader,\n        sharedRender,\n    };\n}\n\nlet defaultN = new Vec3(0, 0, 1);\n\nlet _vertP = new Vec3();\nlet _vertN = new Vec3();\nexport function addVert(render: ITriRender, p: Vec3, color: Vec4, n?: Vec3, mtx?: Mat4f) {\n    let phase = render.sharedRender.activePhase;\n    let vbo = render.vbo.localBufs[0];\n    let ibo = render.ibo.localBufs[phase];\n    ensureFloatBufferSize(vbo, 1);\n    ensureElementBufferSize(ibo, 1);\n    let fBuf = vbo.buf;\n    let iBuf = ibo.buf;\n    let fIdx = vbo.usedEls * vbo.strideFloats;\n    let iIdx = ibo.usedVerts;\n\n    if (mtx) {\n        mtx.mulVec3Affine_(p, _vertP);\n        mtx.mulVec3AffineVec_(n || defaultN, _vertN);\n    } else {\n        _vertP.copy_(p);\n        _vertN.copy_(n || defaultN);\n    }\n\n    fBuf[fIdx + 0] = _vertP.x;\n    fBuf[fIdx + 1] = _vertP.y;\n    fBuf[fIdx + 2] = _vertP.z;\n    fBuf[fIdx + 3] = _vertN.x;\n    fBuf[fIdx + 4] = _vertN.y;\n    fBuf[fIdx + 5] = _vertN.z;\n    fBuf[fIdx + 6] = color.x;\n    fBuf[fIdx + 7] = color.y;\n    fBuf[fIdx + 8] = color.z;\n    fBuf[fIdx + 9] = color.w;\n    fBuf[fIdx + 10] = 0; // uv.x\n    fBuf[fIdx + 11] = 0; // uv.y\n\n    iBuf[iIdx] = vbo.usedEls;\n\n    vbo.usedEls += 1;\n    ibo.usedVerts += 1;\n}\n\nlet _quadTr = new Vec3();\nlet _quadBl = new Vec3();\nexport function addQuad(render: ITriRender, tl: Vec3, br: Vec3, color: Vec4, mtx?: Mat4f, isEnd: boolean = true) {\n    _quadTr.x = br.x;\n    _quadTr.y = tl.y;\n    _quadTr.z = tl.z;\n\n    _quadBl.x = tl.x;\n    _quadBl.y = br.y;\n    _quadBl.z = br.z;\n\n    addVert(render, tl, color, undefined, mtx);\n    addVert(render, _quadBl, color, undefined, mtx);\n    addVert(render, _quadTr, color, undefined, mtx);\n    addVert(render, br, color, undefined, mtx);\n    if (isEnd) {\n        let phase = render.sharedRender.activePhase;\n        let localBuf = render.ibo.localBufs[phase];\n        ensureElementBufferSize(localBuf, 1);\n        localBuf.buf[localBuf.usedVerts++] = 0xffffffff; // primitive restart\n    }\n}\n\nexport function addPrimitiveRestart(render: ITriRender) {\n    let phase = render.sharedRender.activePhase;\n    let localBuf = render.ibo.localBufs[phase];\n    ensureElementBufferSize(localBuf, 1);\n    localBuf.buf[localBuf.usedVerts++] = 0xffffffff; // primitive restart\n}\n\nexport function uploadAllTris(render: ITriRender) {\n    let gl = render.gl;\n    uploadFloatBuffer(gl, render.vbo);\n    uploadElementBuffer(gl, render.ibo);\n}\n\nexport function renderAllTris(render: ITriRender, renderPhase: RenderPhase) {\n    let gl = render.gl;\n    let localIdxBuf = render.ibo.localBufs[renderPhase];\n    if (localIdxBuf.usedVerts === 0) {\n        return;\n    }\n\n    gl.depthMask(renderPhase === RenderPhase.Opaque);\n    gl.disable(gl.CULL_FACE);\n    gl.useProgram(render.triShader.program);\n    gl.bindVertexArray(render.vao);\n    gl.drawElements(gl.TRIANGLE_STRIP, localIdxBuf.usedVerts, gl.UNSIGNED_INT, localIdxBuf.glOffsetBytes);\n    gl.depthMask(true);\n}\n\nexport function resetTriRender(render: ITriRender) {\n    resetElementBufferMap(render.ibo);\n    resetFloatBufferMap(render.vbo);\n}\n\nexport function checkError(gl: WebGL2RenderingContext, msg: string) {\n    let errno = gl.getError();\n    if (errno !== gl.NO_ERROR) {\n        console.error('GLERROR:', msg, '0x' + errno.toString(16));\n        return true;\n    }\n    return false;\n}\n","\n\n\nimport { IFontOpts, measureText, drawText } from \"../render/fontRender\";\nimport { ILineOpts, makeLineOpts, addLine2 } from \"../render/lineRender\";\nimport { IRenderState } from \"../render/modelRender\";\nimport { addQuad } from \"../render/triRender\";\nimport { isNotNil, isNil } from \"@/src/utils/data\";\nimport { lerp } from \"@/src/utils/math\";\nimport { Mat4f } from \"@/src/utils/matrix\";\nimport { Vec3, Vec4 } from \"@/src/utils/vector\";\nimport { drawRoundedRect } from \"./DataFlow\";\nimport { drawLineRect } from \"./ModelCard\";\nimport { TextAlignHoriz } from \"../Annotations\";\n\n/*\n\nWe make a simple text/math layout engine!\n\nWe can't do direct rendering since things need to be layed out first, and information propagates upwards.\n\nLet's first define a simple text block, and see where that leads. We're going to do a sqrt()\n*/\n\nexport interface ITextBlock {\n    type: TextBlockType;\n    id?: string;\n    text?: string;\n    align?: TextAlignHoriz;\n    opts: IFontOpts;\n    size: Vec3;\n    offset: Vec3;\n    subs?: ITextBlock[];\n    cellX?: number;\n    cellY?: number;\n    rectOpts?: ILineOpts;\n    draw?: (blk: ITextBlock, render: IRenderState) => void;\n}\n\nexport interface ITextBlockArgs {\n    type?: TextBlockType;\n    id?: string;\n    text?: string;\n    align?: TextAlignHoriz;\n    opts?: IFontOpts;\n    rectOpts?: ILineOpts;\n    color?: Vec4;\n    size?: Vec3;\n    offset?: Vec3;\n    draw?: (blk: ITextBlock, render: IRenderState) => void;\n    subs?: (ITextBlockArgs | null)[];\n    cellX?: number;\n    cellY?: number;\n}\n\nexport enum TextBlockType {\n    Line,\n    Text,\n    Sqrt,\n    Divide,\n    Cells,\n    Custom,\n}\n\nexport function lineHeight(fontOpts: IFontOpts) {\n    return fontOpts.size * 1.2;\n}\n\nexport function mkTextBlock(args: ITextBlockArgs): ITextBlock {\n    let type = args.type ?? (\n        args.text ? TextBlockType.Text :\n            args.subs ? TextBlockType.Line :\n                (isNotNil(args.cellX) && isNotNil(args.cellY)) ? TextBlockType.Cells :\n                    null);\n\n    if (isNil(type)) {\n        throw new Error('Unknown text block type');\n    }\n\n    let opts = args.opts;\n    if (opts && args.color) {\n        opts = { ...opts, color: args.color };\n    }\n\n    if (!opts) {\n        throw new Error('No font opts');\n    }\n    const testTest = `total = 0\nfor k in range(8):\n    total += A[i,k] * B[j,k]\nR[i,j] = total`\n\n\n    return {\n        type: type,\n        id: args.id,\n        text: args.text,\n        align: args.align,\n        opts: opts!,\n        size: args.size ?? new Vec3(0, 0, 0),\n        offset: args.offset ?? new Vec3(0, 0, 0),\n        subs: args.subs?.filter(isNotNil).map(a => mkTextBlock({ ...a, opts: a.opts ?? opts })),\n        rectOpts: args.rectOpts,\n        draw: args.draw,\n        cellX: args.cellX,\n        cellY: args.cellY,\n    };\n}\n\n\nfunction sqrtSpacing(opts: IFontOpts, inner: ITextBlock) {\n    return {\n        tl: new Vec3(inner.size.y * 0.9, inner.size.y * 0.2),\n        br: new Vec3(inner.size.y * 0.1, 0.0),\n    };\n}\n\nfunction divideSpacing(opts: IFontOpts, inner: ITextBlock) {\n    return {\n        padX: 0,\n        padInnerY: inner.size.y * 0.5,\n    };\n}\n\nlet cellSize = 7.0;\n\nfunction cellSizing(blk: ITextBlock) {\n    return {\n        size: new Vec3(blk.cellX! * cellSize, blk.cellY! * cellSize),\n        pad: cellSize * 1.0,\n    };\n}\n\nexport function sizeBlock(render: IRenderState, blk: ITextBlock) {\n    let opts = blk.opts;\n    switch (blk.type) {\n\n        case TextBlockType.Line: {\n            let x = 0;\n            // middle-align all the sub-blocks\n            // so height is the max height\n            let maxH = 0;\n            for (let sub of blk.subs!) {\n                sizeBlock(render, sub);\n                x += sub.size.x;\n                maxH = Math.max(maxH, sub.size.y);\n            }\n            blk.size = new Vec3(x, maxH, 0);\n            if (blk.rectOpts) {\n                blk.size.x += cellSize * 0.5;\n                blk.size.y += cellSize * 0.5;\n            }\n            break;\n        }\n        case TextBlockType.Text: {\n            if (isNil(blk.text)) {\n                throw new Error('Text block has no text');\n            }\n            blk.size = new Vec3(\n                Math.max(blk.size.x, measureText(render.modelFontBuf, blk.text!, opts)),\n                lineHeight(opts),\n            );\n            break;\n        }\n        case TextBlockType.Sqrt: {\n            let sub = blk.subs![0];\n            sizeBlock(render, sub);\n            let spacing = sqrtSpacing(opts, sub);\n            blk.size = sub.size.add(spacing.tl).add(spacing.br);\n            break;\n        }\n        case TextBlockType.Divide: {\n            let subA = blk.subs![0];\n            let subB = blk.subs![1];\n            sizeBlock(render, subA);\n            sizeBlock(render, subB);\n            let spacing = divideSpacing(opts, subA);\n            blk.size = new Vec3(Math.max(subA.size.x, subB.size.x) + spacing.padX, subA.size.y + subB.size.y + spacing.padInnerY, 0);\n            break;\n        }\n        case TextBlockType.Cells: {\n            let spacing = cellSizing(blk);\n            blk.size = new Vec3(spacing.size.x + spacing.pad, spacing.size.y);\n            break;\n        }\n        case TextBlockType.Custom: {\n            // already sized\n            break;\n        }\n        default: { let _exhaustCheck: never = blk.type; }\n    }\n}\n\nexport function layoutBlock(blk: ITextBlock) {\n    switch (blk.type) {\n        case TextBlockType.Line: {\n            let x = blk.offset.x + cellSize * 0.25;\n            let midY = blk.offset.y + blk.size.y / 2;\n            for (let sub of blk.subs!) {\n                sub.offset = new Vec3(x, midY - sub.size.y / 2).round_();\n                layoutBlock(sub);\n                x += sub.size.x;\n            }\n            break;\n        }\n        case TextBlockType.Sqrt: {\n            let sub = blk.subs![0];\n            sub.offset = blk.offset.add(sqrtSpacing(blk.opts, sub).tl).round_();\n            layoutBlock(sub);\n            break;\n        }\n        case TextBlockType.Divide: {\n            let subA = blk.subs![0];\n            let subB = blk.subs![1];\n            let midX = blk.size.x / 2;\n            subA.offset = blk.offset.add(new Vec3(midX - subA.size.x / 2, 0)).round_();\n            subB.offset = blk.offset.add(new Vec3(midX - subB.size.x / 2, blk.size.y - subB.size.y)).round_();\n            layoutBlock(subA);\n            layoutBlock(subB);\n            break;\n        }\n        case TextBlockType.Text: {\n            break;\n        }\n        case TextBlockType.Cells: {\n            break;\n        }\n        case TextBlockType.Custom: {\n            break;\n        }\n        default: { let _exhaustCheck: never = blk.type; }\n    }\n}\n\nexport function drawBlock(render: IRenderState, blk: ITextBlock) {\n\n    switch (blk.type) {\n        case TextBlockType.Line: {\n            for (let sub of blk.subs!) {\n                drawBlock(render, sub);\n            }\n            if (blk.rectOpts) {\n                let rectOpts = makeLineOpts(blk.rectOpts);\n                let tl = blk.offset.round().add(new Vec3(0.5, 0.5));\n                let br = blk.offset.add(blk.size).round().add(new Vec3(0.5, 0.5));\n                drawRoundedRect(render, tl, br, rectOpts.color.mul(0.24), rectOpts.mtx, 2);\n                drawLineRect(render, tl, br, rectOpts);\n            }\n            break;\n        }\n        case TextBlockType.Text: {\n            let xPos = blk.offset.x;\n            if (blk.align === TextAlignHoriz.Right) {\n                xPos = blk.offset.x + blk.size.x - measureText(render.modelFontBuf, blk.text!, blk.opts);\n            }\n            drawText(render.modelFontBuf, blk.text!, xPos, blk.offset.y + blk.opts.size * 0.1, blk.opts);\n            break;\n        }\n        case TextBlockType.Sqrt: {\n            let sub = blk.subs![0];\n\n            let subY = sub.size.y;\n\n            let sqrtX = blk.offset.x;\n            let sqrtY = blk.offset.y - subY * 0.9;\n            let sqrtSize = subY * 1.8;\n\n            let mathOpts: IFontOpts = { ...blk.opts, faceName: 'cmsy10', size: sqrtSize };\n\n            let lineOpts = makeLineOpts({ color: blk.opts.color, n: new Vec3(0, 0, 1), mtx: blk.opts.mtx, thick: 0.4 });\n            let lineX = sqrtX + sqrtSize * 0.5;\n            let lineY = sqrtY + sqrtSize * 0.5;\n            addLine2(render.lineRender, new Vec3(lineX, lineY).round_(), new Vec3(sub.offset.x + sub.size.x, lineY).round_(), lineOpts);\n\n            drawText(render.modelFontBuf, '\\u0070', sqrtX, sqrtY, mathOpts);\n            drawBlock(render, sub);\n            break;\n        }\n        case TextBlockType.Divide: {\n            let subA = blk.subs![0];\n            let subB = blk.subs![1];\n\n            let lineOpts = makeLineOpts({ color: blk.opts.color, n: new Vec3(0, 0, 1), mtx: blk.opts.mtx, thick: 0.4 });\n            let lineY = lerp(subA.offset.y + subA.size.y, subB.offset.y, 0.5) + 1.0;\n            addLine2(render.lineRender, new Vec3(blk.offset.x, lineY), new Vec3(blk.offset.x + blk.size.x, lineY), lineOpts);\n\n            drawBlock(render, blk.subs![0]);\n            drawBlock(render, blk.subs![1]);\n            break;\n        }\n        case TextBlockType.Cells: {\n            let center = blk.offset.add(new Vec3(blk.size.x / 2, blk.size.y / 2));\n            let spacing = cellSizing(blk);\n\n            drawCells(render, new Vec3(blk.cellX!, blk.cellY!), center, spacing.size, blk.opts.color, blk.opts.mtx);\n\n            break;\n        }\n        case TextBlockType.Custom: {\n            blk.draw?.(blk, render);\n            break;\n        }\n        default: { let _exhaustCheck: never = blk.type; }\n    }\n}\n\nexport function drawCells(render: IRenderState, nCells: Vec3, center: Vec3, size: Vec3, color: Vec4, mtx?: Mat4f) {\n    let thick = 0.4;\n    let tl = center.mulAdd(size, -0.5).add(new Vec3(0.5, 0.5));\n    let br = center.mulAdd(size, 0.5).add(new Vec3(0.5, 0.5));\n    let lineOpts = makeLineOpts({ color, mtx, n: new Vec3(0, 0, 1), thick });\n\n    drawLineRect(render, tl, br, lineOpts);\n    addQuad(render.triRender, tl, br, color.mul(0.3), mtx);\n\n    for (let i = 1; i < nCells.x; i++) {\n        let lineX = tl.x + i * cellSize;\n        addLine2(render.lineRender, new Vec3(lineX, tl.y, 0), new Vec3(lineX, br.y, 0), lineOpts);\n    }\n\n    for (let i = 1; i < nCells.y; i++) {\n        let lineY = tl.y + i * cellSize;\n        addLine2(render.lineRender, new Vec3(tl.x, lineY, 0), new Vec3(br.x, lineY, 0), lineOpts);\n    }\n}\n","import { cameraToMatrixView } from \"../Camera\";\nimport { cellPosition, IGptModelLayout } from \"../GptModelLayout\";\nimport { IProgramState } from \"../Program\";\nimport { drawText, IFontOpts, measureText, measureTextWidth, writeTextToBuffer } from \"../render/fontRender\";\nimport { addLine, addLine2 as drawLine, drawLineSegs, ILineOpts, makeLineOpts } from \"../render/lineRender\";\nimport { IRenderState } from \"../render/modelRender\";\nimport { addQuad } from \"../render/triRender\";\nimport { lerp } from \"@/src/utils/math\";\nimport { Mat4f } from \"@/src/utils/matrix\";\nimport { Dim, Vec3, Vec4 } from \"@/src/utils/vector\";\nimport { DimStyle, dimStyleColor } from \"../walkthrough/WalkthroughTools\";\nimport { lineHeight } from \"./TextLayout\";\nimport { IColorMix } from \"../Annotations\";\nimport { clamp } from \"@/src/utils/data\";\n\nexport function drawModelCard(state: IProgramState, layout: IGptModelLayout, title: string, offset: Vec3) {\n    let { render } = state;\n    let { camPos } = cameraToMatrixView(state.camera);\n    let dist = camPos.dist(new Vec3(0, 0, -30)); //.add(offset));\n\n    let scale = clamp(dist / 500.0, 1.0, 800.0);\n\n    let pinY = -60;\n    let mtx = Mat4f.fromScaleTranslation(new Vec3(scale, scale, scale), new Vec3(0, pinY, 0).add(offset))\n        .mul(Mat4f.fromTranslation(new Vec3(0, -pinY, 0)));\n\n    let thick = 1.0 / 10.0 * scale;\n    let borderColor = Vec4.fromHexColor(\"#555599\", 0.8);\n    let backgroundColor = Vec4.fromHexColor(\"#93c5fd\", 0.3);\n    let titleColor = Vec4.fromHexColor(\"#000000\", 1.0);\n    let n = new Vec3(0, 0, 1);\n\n    let lineOpts: ILineOpts = { color: borderColor, mtx, thick, n };\n\n    let tl = new Vec3(-45, -97, 0);\n    let br = new Vec3( 45, -70, 0);\n    drawLineRect(render, tl, br, lineOpts);\n\n    addQuad(render.triRender, new Vec3(tl.x, tl.y, -0.1), new Vec3(br.x, br.y, -0.1), backgroundColor, mtx);\n\n    // let w = measureTextWidth(state.modelFontBuf, title, .0);\n    let { B, C, T, A, nBlocks, nHeads, vocabSize } = layout.shape;\n\n    let midX = (tl.x + br.x) / 2;\n    let paramLeft = br.x - 50;\n    let paramOff = tl.y + 2;\n\n    let paramLineHeight = 1.3;\n    let paramFontScale = 4;\n    let numWidth = paramFontScale * 0.6;\n    let allNums = [B, C, T, A, nBlocks, nHeads];\n    let maxLen = Math.max(...allNums.map(n => n.toString().length));\n    let paramHeight = 2 + paramLineHeight * paramFontScale * 3 + 1;\n\n    let titleFontScale = 13;\n    let titleW = measureTextWidth(render.modelFontBuf, title, titleFontScale);\n    let titleHeight = titleFontScale * paramLineHeight;\n    writeTextToBuffer(render.modelFontBuf, title, titleColor, midX - titleW / 2, tl.y + 2, titleFontScale, mtx);\n\n    // layout.weightCount = 150000000000;\n\n    let nParamsText = `n_params = `;\n    let weightCountText = numberToCommaSep(layout.weightCount);\n\n    let weightSize = 8;\n    let weightTitleW = measureTextWidth(render.modelFontBuf, nParamsText, paramFontScale);\n    let weightCountW = measureTextWidth(render.modelFontBuf, weightCountText, weightSize);\n    // let infoText = \"goal: sort 6 letters from { A, B, C } into ascending order\";\n    // writeTextToBuffer(render.modelFontBuf, infoText, titleColor, tl.x + 2, tl.y + paramHeight + 2, 4, mtx);\n\n    paramOff = tl.y + titleHeight + 4;\n    let weightX = midX - (weightCountW + weightTitleW) / 2;\n\n    writeTextToBuffer(render.modelFontBuf, nParamsText, titleColor, weightX, paramOff - paramFontScale / 2, paramFontScale, mtx);\n    writeTextToBuffer(render.modelFontBuf, weightCountText, titleColor, weightX + weightTitleW, paramOff - weightSize / 2, weightSize, mtx);\n    // addParam(\"C (channels) = \", C.toString(), dimStyleColor(DimStyle.C));\n    // addParam(\"T (time) = \", T.toString(), dimStyleColor(DimStyle.T));\n    // addParam(\"B (batches) = \", B.toString(), dimStyleColor(DimStyle.B));\n    // paramOff = tl.y + 2;\n    // paramLeft += 35;\n    // addParam(\"n_vocab = \", vocabSize.toString(), dimStyleColor(DimStyle.n_vocab));\n    // addParam(\"n_layers = \", nBlocks.toString(), dimStyleColor(DimStyle.n_layers));\n    // addParam(\"n_heads = \", nHeads.toString(), dimStyleColor(DimStyle.n_heads));\n\n    // function addParam(name: string, value: string, color: Vec4 = borderColor) {\n    //     let y = paramOff;\n    //     let w = measureTextWidth(render.modelFontBuf, name, paramFontScale);\n    //     let numW = measureTextWidth(render.modelFontBuf, value, paramFontScale);\n    //     let left = paramLeft;\n    //     writeTextToBuffer(render.modelFontBuf, name, color,  left - w        , y, paramFontScale, mtx);\n    //     writeTextToBuffer(render.modelFontBuf, value, color, left + maxLen * numWidth - numW, y, paramFontScale, mtx);\n    //     paramOff += paramFontScale * paramLineHeight;\n    // }\n\n    // addLine(render.lineRender, thick, borderColor, new Vec3(tl.x, tl.y + paramHeight), new Vec3(br.x, tl.y + paramHeight), n, mtx);\n\n    renderOutputAtBottom(state);\n\n    renderInputAtTop(state);\n}\n\nexport function sortABCInputTokenToString(a: number) {\n    return String.fromCharCode('A'.charCodeAt(0) + a); // just A, B, C supported!\n}\n\nexport interface IInputBoxOpts {\n    tokMixes?: IColorMix | null;\n    idxMixes?: IColorMix | null;\n}\n\nexport function renderInputBoxes(state: IProgramState, layout: IGptModelLayout, tl: Vec3, br: Vec3, cellW: number, fontSize: number, lineOpts: ILineOpts, opts?: IInputBoxOpts) {\n    let render = state.render;\n    let { T } = layout.shape;\n    let inCellH = br.y - tl.y;\n\n    let tokTextOpts: IFontOpts = { color: Vec4.fromHexColor(\"#000000\", 1.0), mtx: lineOpts.mtx, size: fontSize };\n    let idxTextOpts: IFontOpts = { color: Vec4.fromHexColor(\"#666666\", 1.0), mtx: lineOpts.mtx, size: fontSize * 0.6 };\n\n    let dimmedTokTextOpts: IFontOpts = { ...tokTextOpts, color: tokTextOpts.color.mul(0.3) };\n    let dimmedIdxTextOpts: IFontOpts = { ...idxTextOpts, color: idxTextOpts.color.mul(0.3) };\n\n    drawLineRect(render, tl, br, lineOpts);\n\n    let tokens = layout.model?.inputTokens.localBuffer;\n\n    for (let i = 0; i < T; i++) {\n\n        if (i > 0) {\n            let lineX = tl.x + i * cellW;\n            drawLine(render.lineRender, new Vec3(lineX, tl.y, 0), new Vec3(lineX, br.y, 0), lineOpts);\n        }\n\n        if (tokens && i < layout.model!.inputLen) {\n            let cx = tl.x + (i + 0.5) * cellW;\n\n            let tokOpts = { ...tokTextOpts, color: mixColorValues(opts?.tokMixes ?? null, tokTextOpts.color, i) };\n            let tokIdxOpts = { ...idxTextOpts, color: mixColorValues(opts?.idxMixes ?? null, idxTextOpts.color, i) };\n            let tokStr = sortABCInputTokenToString(tokens[i]);\n            let tokW = measureText(render.modelFontBuf, tokStr, tokTextOpts);\n            let idxW = measureText(render.modelFontBuf, tokens[i].toString(), idxTextOpts);\n            let totalH = tokTextOpts.size + idxTextOpts.size;\n            let top = tl.y + (inCellH - totalH) / 2;\n\n            drawText(render.modelFontBuf, tokStr, cx - tokW / 2, top, tokOpts);\n            drawText(render.modelFontBuf, tokens[i].toString(),  cx - idxW / 2, top + tokTextOpts.size, tokIdxOpts);\n        }\n\n    }\n}\n\nexport interface IOutputBoxOpts {\n    opacity?: number;\n    boldLast?: boolean;\n    tokMixes?: IColorMix | null;\n}\n\nexport function renderOutputBoxes(state: IProgramState, layout: IGptModelLayout, tl: Vec3, br: Vec3, cellW: number, fontSize: number, lineOpts: ILineOpts, opts?: IOutputBoxOpts) {\n    let render = state.render;\n    let { T, vocabSize } = layout.shape;\n    let outCellH = br.y - tl.y;\n\n    let opacity = opts?.opacity ?? 1.0;\n    let boldLast = opts?.boldLast ?? true;\n\n    lineOpts = { ...lineOpts, color: lineOpts.color.mul(opacity ?? 1.0) };\n    let tokTextOpts: IFontOpts = { color: Vec4.fromHexColor(\"#000000\", opacity), mtx: lineOpts.mtx, size: fontSize };\n    let idxTextOpts: IFontOpts = { color: Vec4.fromHexColor(\"#666666\", opacity), mtx: lineOpts.mtx, size: fontSize * 0.6 };\n\n    let dimmedTokTextOpts: IFontOpts = { ...tokTextOpts, color: tokTextOpts.color.mul(0.3) };\n    let dimmedIdxTextOpts: IFontOpts = { ...idxTextOpts, color: idxTextOpts.color.mul(0.3) };\n\n    drawLineRect(render, tl, br, lineOpts);\n\n    let sortedOutput = layout.model?.sortedBuf;\n\n    for (let i = 0; i < T; i++) {\n        if (i > 0) {\n            let lineX = tl.x + i * cellW;\n            drawLine(render.lineRender, new Vec3(lineX, tl.y, 0), new Vec3(lineX, br.y, 0), lineOpts);\n        }\n\n        if (sortedOutput && i < layout.model!.inputLen) {\n            let usedSoFar = 0.0;\n            let cx = tl.x + (i + 0.5) * cellW;\n\n            for (let j = 0; j < vocabSize; j++) {\n                let tokIdx = sortedOutput[(i * vocabSize + j) * 2 + 0];\n                let tokProb = sortedOutput[(i * vocabSize + j) * 2 + 1];\n\n                let partTop = tl.y + usedSoFar * outCellH;\n                let partH = tokProb * outCellH;\n\n                let dimmed = i < layout.model!.inputLen - 1 || !boldLast;\n\n                let color = mixColorValues(opts?.tokMixes ?? null, tokTextOpts.color, i);\n                if (dimmed) {\n                    color = color.mul(0.3);\n                }\n\n                let tokOpts = { ...tokTextOpts, color };\n                let idxOpts = { ...idxTextOpts, color: color.mul(0.6) };\n\n                let tokStr = sortABCInputTokenToString(tokIdx);\n                let tokW = measureText(render.modelFontBuf, tokStr, tokOpts);\n                let idxW = measureText(render.modelFontBuf, tokIdx.toString(), idxOpts);\n                let textH = tokOpts.size + idxOpts.size;\n                let top = partTop + (partH - textH) / 2;\n\n                if (partH > textH) {\n                    drawText(render.modelFontBuf, tokStr, cx - tokW / 2, top, tokOpts);\n                    drawText(render.modelFontBuf, tokIdx.toString(),  cx - idxW / 2, top + tokOpts.size, idxOpts);\n                }\n\n                usedSoFar += tokProb;\n\n                drawLine(render.lineRender, new Vec3(cx - cellW/2, partTop + partH, 0), new Vec3(cx + cellW/2, partTop + partH, 0), lineOpts);\n                if (usedSoFar >= 1.0 - 1e-4) {\n                    break;\n                }\n            }\n        }\n    }\n}\n\nexport function mixColorValues(mixes: IColorMix | null, baseColor: Vec4, idx: number) {\n    if (!mixes) {\n        return baseColor;\n    }\n    let mix = mixes.mixes[idx] ?? 0.0;\n    return Vec4.lerp(mixes.color1 ?? baseColor, mixes.color2, mix);\n}\n\nlet _lineRectArr = new Float32Array(3 * 4);\nexport function drawLineRect(render: IRenderState, tl: Vec3, br: Vec3, opts: ILineOpts) {\n\n    _lineRectArr[0] = tl.x;\n    _lineRectArr[1] = tl.y;\n    _lineRectArr[2] = 0;\n    _lineRectArr[3] = br.x;\n    _lineRectArr[4] = tl.y;\n    _lineRectArr[5] = 0;\n    _lineRectArr[6] = br.x;\n    _lineRectArr[7] = br.y;\n    _lineRectArr[8] = 0;\n    _lineRectArr[9] = tl.x;\n    _lineRectArr[10] = br.y;\n    _lineRectArr[11] = 0;\n\n    drawLineSegs(render.lineRender, _lineRectArr, makeLineOpts({ ...opts, closed: true }));\n}\n\nfunction numberToCommaSep(a: number) {\n    let s = a.toString();\n    let out = \"\";\n    for (let i = 0; i < s.length; i++) {\n        if (i > 0 && (s.length - i) % 3 == 0) {\n            out += \",\";\n        }\n        out += s[i];\n    }\n    return out;\n}\n\nfunction renderInputAtTop(state: IProgramState) {\n    let layout = state.layout;\n    let render = state.render;\n\n    let inputTokBlk = layout.idxObj;\n\n    let topMid = new Vec3(inputTokBlk.x + inputTokBlk.dx/2, inputTokBlk.y - layout.margin);\n\n    let inCellH = 10;\n    let inCellW = 6;\n\n    let nCells = layout.shape.T;\n    let tl = new Vec3(topMid.x - inCellW * nCells / 2, topMid.y - inCellH);\n    let br = new Vec3(topMid.x + inCellW * nCells / 2, topMid.y);\n\n    let outputOpacity = state.display.topOutputOpacity ?? 1.0;\n\n    let lineOpts = makeLineOpts({ color: Vec4.fromHexColor(\"#000000\", 0.2), mtx: new Mat4f(), thick: 1.5 });\n    let titleTextOpts: IFontOpts = { color: Vec4.fromHexColor(\"#666666\", 1.0), mtx: lineOpts.mtx, size: 1.9 };\n\n    renderInputBoxes(state, layout, tl, br, inCellW, 4, lineOpts, { tokMixes: state.display.tokenColors, idxMixes: state.display.tokenIdxColors });\n\n    let inputTitle = \"Input\";\n    drawText(render.modelFontBuf, inputTitle, tl.x, tl.y - lineHeight(titleTextOpts), titleTextOpts);\n\n    {\n        let outCellH = 12;\n        let outBr = new Vec3(br.x, tl.y - 4);\n        let outTl = new Vec3(tl.x, outBr.y - outCellH);\n        renderOutputBoxes(state, layout, outTl, outBr, inCellW, 4, lineOpts, { opacity: outputOpacity, boldLast: outputOpacity < 1.0, tokMixes: state.display.tokenOutputColors });\n\n        let outputTitle = \"Output\";\n        let outputTextOpts = { ...titleTextOpts, color: titleTextOpts.color.mul(outputOpacity) };\n        drawText(render.modelFontBuf, outputTitle, outTl.x, outTl.y - lineHeight(titleTextOpts), outputTextOpts);\n    }\n\n    for (let i = 0; i < nCells; i++) {\n        let mixes = state.display.tokenIdxColors;\n\n        let lineOptsLocal = { ...lineOpts, color: mixColorValues(mixes, lineOpts.color, i) };\n\n        let tx = tl.x + (i + 0.5) * inCellW;\n        let ty = tl.y + layout.cell + inCellH;\n        let bx = cellPosition(layout, inputTokBlk, Dim.X, i) + 0.5 * layout.cell;\n        let by = inputTokBlk.y - 0.5 * layout.cell;\n\n        let midY1 = lerp(by, ty, 1/6);\n        let midY2 = lerp(by, ty, 3/4);\n\n        drawLine(state.render.lineRender, new Vec3(bx, by), new Vec3(bx, midY1), lineOptsLocal);\n        drawLine(state.render.lineRender, new Vec3(bx, midY1), new Vec3(tx, midY2), lineOptsLocal);\n        drawLine(state.render.lineRender, new Vec3(tx, midY2), new Vec3(tx, ty), lineOptsLocal);\n\n        let arrLen = 0.6;\n        let arrowLeft = new Vec3(bx - arrLen, by - arrLen);\n        let arrowRight = new Vec3(bx + arrLen, by - arrLen);\n        drawLine(state.render.lineRender, arrowLeft, new Vec3(bx, by), lineOptsLocal);\n        drawLine(state.render.lineRender, arrowRight, new Vec3(bx, by), lineOptsLocal);\n    }\n}\n\nfunction renderOutputAtBottom(state: IProgramState) {\n    let layout = state.layout;\n\n    let softmax = layout.logitsSoftmax;\n\n\n    let topMid = new Vec3(softmax.x + softmax.dx/2, softmax.y + softmax.dy + layout.margin);\n\n    let outCellH = 10;\n    let outCellW = 6;\n\n    let nCells = layout.shape.T;\n    let tl = new Vec3(topMid.x - outCellW * nCells / 2, topMid.y);\n    let br = new Vec3(topMid.x + outCellW * nCells / 2, topMid.y + outCellH);\n\n    let lineOpts = makeLineOpts({ color: Vec4.fromHexColor(\"#000000\", 0.2), mtx: new Mat4f(), thick: 1.5 });\n\n    renderOutputBoxes(state, layout, tl, br, outCellW, 4, lineOpts, { boldLast: true, tokMixes: state.display.tokenOutputColors });\n\n    for (let i = 0; i < nCells; i++) {\n        let tx = cellPosition(layout, softmax, Dim.X, i) + 0.5 * layout.cell;\n        let ty = softmax.y + softmax.dy + 0.5 * layout.cell;\n        let bx = tl.x + (i + 0.5) * outCellW;\n        let by = tl.y - layout.cell;\n\n        let midY1 = lerp(ty, by, 1/6);\n        let midY2 = lerp(ty, by, 3/4);\n\n        drawLine(state.render.lineRender, new Vec3(tx, ty), new Vec3(tx, midY1), lineOpts);\n        drawLine(state.render.lineRender, new Vec3(tx, midY1), new Vec3(bx, midY2), lineOpts);\n        drawLine(state.render.lineRender, new Vec3(bx, midY2), new Vec3(bx, by), lineOpts);\n\n        let arrLen = 0.6;\n        let arrowLeft = new Vec3(bx - arrLen, by - arrLen);\n        let arrowRight = new Vec3(bx + arrLen, by - arrLen);\n        drawLine(state.render.lineRender, arrowLeft, new Vec3(bx, by), lineOpts);\n        drawLine(state.render.lineRender, arrowRight, new Vec3(bx, by), lineOpts);\n    }\n\n}\n","import { text } from \"stream/consumers\";\nimport { dimProps, TextAlignHoriz } from \"../Annotations\";\nimport { BlKDepSpecial, BlkSpecial, cellPosition, IBlkCellDep } from \"../GptModelLayout\";\nimport { IBlkDef } from \"../EinsumLayout\";\nimport { getDepDotLen, getDepSrcIdx } from \"../Interaction\";\nimport { IProgramState } from \"../Program\";\nimport { drawText, IFontOpts, measureText } from \"../render/fontRender\";\nimport { addLine2, drawLineSegs, makeLineOpts } from \"../render/lineRender\";\nimport { IRenderState } from \"../render/modelRender\";\nimport { RenderPhase } from \"../render/sharedRender\";\nimport { addPrimitiveRestart, addQuad, addVert } from \"../render/triRender\";\nimport { isNotNil } from \"@/src/utils/data\";\nimport { lerp } from \"@/src/utils/math\";\nimport { Mat4f } from \"@/src/utils/matrix\";\nimport { BoundingBox3d, Dim, Vec3, Vec4 } from \"@/src/utils/vector\";\nimport { Colors, DimStyle, dimStyleColor, dimStyleText, dimStyleTextShort } from \"../walkthrough/WalkthroughTools\";\nimport { drawLineRect } from \"./ModelCard\";\nimport { ITextBlock, sizeBlock, layoutBlock, drawBlock, mkTextBlock, TextBlockType, drawCells, ITextBlockArgs } from \"./TextLayout\";\n\ninterface IDataFlowArgs {\n    state: IProgramState;\n    center: Vec3;\n    blk: IBlkDef;\n    destIdx: Vec3;\n    mtx: Mat4f;\n}\n\nexport function drawDataFlow(state: IProgramState, blk: IBlkDef, destIdx: Vec3, pinIdx?: Vec3) {\n    if (!blk.deps && !blk.meinsumResult) {\n        return;\n    }\n    let prevPhase = state.render.sharedRender.activePhase;\n    state.render.sharedRender.activePhase = RenderPhase.Overlay2D;\n\n    // the point where we draw the overlay\n    pinIdx = pinIdx ?? destIdx;\n\n    let cellPos = new Vec3(\n        cellPosition(state.layout, blk, Dim.X, pinIdx.x) + state.layout.cell * 0.5,\n        cellPosition(state.layout, blk, Dim.Y, pinIdx.y) + state.layout.cell * 0.5,\n        cellPosition(state.layout, blk, Dim.Z, pinIdx.z) + state.layout.cell * 1.1,\n    );\n\n    let resMtx = new Mat4f();\n\n    let screenPos = projectToScreen(state, cellPos).round_();\n    let center = screenPos.add(new Vec3(0, -50));\n\n    let dataFlowArgs: IDataFlowArgs = {\n        state,\n        center,\n        blk,\n        destIdx,\n        mtx: resMtx,\n    }\n\n    let bb = new BoundingBox3d();\n\n    blk.highlight = 10.\n\n    // console.log('blk.meinsumResult', blk.meinsumResult)\n    if (blk.meinsumResult) {\n        drawMeinsum(dataFlowArgs);\n        return;\n\n    }\n\n    if (blk.deps.lowerTri && destIdx.x > destIdx.y) {\n        drawZeroSymbol(dataFlowArgs);\n\n    } else if (blk.deps.special === BlKDepSpecial.InputEmbed) {\n        bb = drawOLInputEmbed(dataFlowArgs);\n\n    } else if (blk.deps.special === BlKDepSpecial.LayerNorm) {\n        bb = drawLayerNorm(dataFlowArgs);\n\n    } else if (blk.deps.special === BlKDepSpecial.LayerNormMu) {\n        bb = drawLayerNormMuAgg(dataFlowArgs);\n\n    } else if (blk.deps.special === BlKDepSpecial.LayerNormSigma) {\n        bb = drawLayerNormSigmaAgg(dataFlowArgs);\n\n    } else if (blk.deps.special === BlKDepSpecial.SoftmaxAggMax) {\n        bb = drawSoftmaxAggMax(dataFlowArgs);\n\n    } else if (blk.deps.special === BlKDepSpecial.SoftmaxAggExp) {\n        bb = drawSoftmaxAggExp(dataFlowArgs);\n\n    } else if (blk.deps.special === BlKDepSpecial.Softmax) {\n        bb = drawSoftmax(dataFlowArgs);\n\n    } else if (blk.deps.special === BlKDepSpecial.Attention) {\n        bb = drawAttention(dataFlowArgs);\n\n    } else if (blk.deps.special === BlKDepSpecial.Gelu) {\n        bb = drawGeluActivation(dataFlowArgs);\n\n        // Standard ones\n    } else if (blk.deps.dot) {\n        bb = drawOLMatrixMul(dataFlowArgs);\n\n    } else if (blk.deps.add && blk.deps.add.length === 2) {\n        bb = drawResidualAdd(dataFlowArgs);\n    }\n\n\n    if (!bb.empty) {\n        let cellIdxBb = drawCellIndexAndValue(dataFlowArgs, bb);\n        let fullBB = new BoundingBox3d(bb.min, bb.max, cellIdxBb.min, cellIdxBb.max);\n        drawDepArrows(dataFlowArgs, fullBB);\n    }\n\n    state.render.sharedRender.activePhase = prevPhase;\n}\n\nexport function drawOLAddSymbol(args: IDataFlowArgs) {\n    let { state, center, mtx } = args;\n\n    let color = opColor;\n    let innerColor = new Vec4(1.0, 1.0, 1.0, 1).mul(0.6);\n    let width = 1;\n    let radius = 15;\n    drawCircle(state.render, center, radius, width, color, mtx);\n    drawCirclePlane(state.render, center, radius, innerColor, mtx);\n\n    let textOpts: IFontOpts = { color: color, mtx, size: 40 };\n    let tw = measureText(state.render.modelFontBuf, '+', textOpts);\n\n    drawText(state.render.modelFontBuf, '+', center.x - tw / 2, center.y - textOpts.size * 0.5, textOpts);\n}\n\nexport function drawCircle(render: IRenderState, center: Vec3, radius: number, width: number, color: Vec4, mtx: Mat4f) {\n    let nPoints = 30;\n\n    let buf = new Float32Array(nPoints * 3);\n    for (let i = 0; i < nPoints; i++) {\n        let theta = i / nPoints * Math.PI * 2;\n        buf[i * 3 + 0] = center.x + Math.cos(theta) * radius;\n        buf[i * 3 + 1] = center.y + Math.sin(theta) * radius;\n        buf[i * 3 + 2] = center.z;\n    }\n\n    drawLineSegs(render.lineRender, buf, makeLineOpts({ color, n: new Vec3(0, 0, 1), thick: width, closed: true, mtx }))\n}\n\nexport function drawCirclePlane(render: IRenderState, center: Vec3, radius: number, color: Vec4, mtx: Mat4f) {\n    let nPoints = 30;\n    let n = new Vec3(0, 0, 1);\n\n    for (let i = 0; i < nPoints + 1; i++) {\n        let theta = i / nPoints * Math.PI * 2;\n        let p = new Vec3(\n            center.x + Math.cos(theta) * radius,\n            center.y + Math.sin(theta) * radius,\n            center.z,\n        );\n\n        addVert(render.triRender, center, color, n, mtx);\n        addVert(render.triRender, p, color, n, mtx);\n    }\n    addPrimitiveRestart(render.triRender);\n}\n\nfunction projectToScreen(state: IProgramState, modelPos: Vec3) {\n    let model = state.camera.modelMtx;\n    let view = state.camera.viewMtx;\n\n    let ndc = view.mulVec3Proj(model.mulVec3Affine(modelPos));\n\n    return new Vec3(\n        (ndc.x + 1) * 0.5 * state.render.size.x,\n        (1 - ndc.y) * 0.5 * state.render.size.y,\n        0);\n}\n\nlet weightSrcColor = new Vec4(0.4, 0.4, 0.9, 1);\nlet workingSrcColor = new Vec4(0.3, 0.7, 0.3, 1);\n\nlet opColor = new Vec4(0.9, 0.9, 0.9, 1);\nlet backWhiteColor = new Vec4(0.0, 0.0, 0.0, 1).mul(1.0);\nlet nameColor = new Vec4(1.0, 1.0, 1.0, 1);\nlet embedBlockHeight = 30;\nlet tokEmbedBlockWidth = 40;\nlet posEmbedBlockWidth = 35;\n\nexport function drawOLInputEmbed(args: IDataFlowArgs) {\n    let { center, mtx } = args;\n\n    return drawMaths(args, center, mkTextBlock({\n        opts: { color: nameColor, mtx, size: 16 },\n\n        subs: [\n            { type: TextBlockType.Custom, draw: (blk) => drawOLIndexLookup(args, blk.offset), size: new Vec3(tokEmbedBlockWidth, embedBlockHeight) },\n            { text: ' + ' },\n            { type: TextBlockType.Custom, draw: (blk) => drawOLPosEmbedLookup(args, blk.offset), size: new Vec3(posEmbedBlockWidth, embedBlockHeight) },\n        ]\n\n    }), [20, 0, 0, 0]);\n}\n\nexport function getBlockValueAtIdx(blk: IBlkDef, blkIdx: Vec3) {\n    let localBuffer = blk.access?.src.localBuffer;\n    if (!blk.access || !localBuffer) {\n        return null;\n    }\n    let bufferTex = blk.access.src;\n\n    let bufferPos = blk.access.mat.mulVec4(new Vec4(blkIdx.x, blkIdx.y, blkIdx.z, 1));\n\n    let channelIdx = blk.access.channel === 'r' ? 0 : blk.access.channel === 'g' ? 1 : blk.access.channel === 'b' ? 2 : 3;\n\n    let idx = bufferPos.y * bufferTex.width * bufferTex.channels + bufferPos.x * bufferTex.channels + channelIdx;\n\n    return localBuffer[idx];\n}\n\nexport function drawOLIndexLookup(args: IDataFlowArgs, offset: Vec3) {\n    let { state, center, destIdx, mtx } = args;\n    let tokenIdx = getBlockValueAtIdx(state.layout.idxObj, new Vec3(destIdx.x, 0, destIdx.z));\n    let tokenPct = isNotNil(tokenIdx) ? tokenIdx / (state.layout.tokEmbedObj.cx - 1) : 0.3;\n    let heightPct = destIdx.y / (state.layout.residual0.cy - 1);\n\n    let pos = center.add(new Vec3(-35, -20, 0));\n    let color = Colors.Weights;\n\n    // let tl = pos.add(new Vec3(-tokEmbedBlockWidth/2, -embedBlockHeight/2));\n    // let br = pos.add(new Vec3(tokEmbedBlockWidth/2,  embedBlockHeight/2));\n    let tl = offset;\n    let br = tl.add(new Vec3(tokEmbedBlockWidth, embedBlockHeight));\n\n    drawLineRect(state.render, tl, br, makeLineOpts({ color, mtx, n: new Vec3(0, 0, 1), thick: 0.4 }));\n\n    addQuad(state.render.triRender, tl, br, backWhiteColor, mtx);\n\n    let colW = 8;\n    let colTl = new Vec3(tl.x + lerp(0, br.x - tl.x - colW, tokenPct), tl.y);\n    let colBr = new Vec3(colTl.x + colW, br.y);\n\n    let cellTl = new Vec3(colTl.x, colTl.y + lerp(0, br.y - tl.y - colW, heightPct));\n    let cellBr = new Vec3(colBr.x, cellTl.y + colW);\n\n    addQuad(state.render.triRender, colTl, colBr, color.mul(0.3), mtx);\n    addQuad(state.render.triRender, cellTl, cellBr, color, mtx);\n\n    let lineColor = Colors.Intermediates;\n    let lineEndX = colTl.x + colW / 2;\n    let lineEndY = colTl.y - 5;\n    let lineStartX = br.x;\n    let lineHeight = 10;\n\n    let pts = new Float32Array([\n        lineStartX, lineEndY - lineHeight, 0,\n        lineEndX, lineEndY - lineHeight, 0,\n        lineEndX, lineEndY, 0,\n    ]);\n    let lineOpts = makeLineOpts({ color: lineColor, mtx, n: new Vec3(0, 0, 1), thick: 0.5 });\n    drawLineSegs(state.render.lineRender, pts, lineOpts);\n\n    drawCells(state.render, new Vec3(1, 1), new Vec3(lineStartX + 8, lineEndY - lineHeight), new Vec3(7, 7), Colors.Intermediates, mtx);\n}\n\nexport function drawOLPosEmbedLookup(args: IDataFlowArgs, offset: Vec3) {\n    let { state, center, destIdx, mtx } = args;\n    let posPct = destIdx.x / (state.layout.posEmbedObj.cx - 1);\n    let heightPct = destIdx.y / (state.layout.residual0.cy - 1);\n\n    let pos = center.add(new Vec3(35, -20, 0));\n    let color = Colors.Weights;\n\n    // let tl = pos.add(new Vec3(-posEmbedBlockWidth/2, -embedBlockHeight/2));\n    // let br = pos.add(new Vec3(posEmbedBlockWidth/2,  embedBlockHeight/2));\n    let tl = offset;\n    let br = tl.add(new Vec3(tokEmbedBlockWidth, embedBlockHeight));\n\n    drawLineRect(state.render, tl, br, makeLineOpts({ color, mtx, n: new Vec3(0, 0, 1), thick: 0.4 }));\n\n    addQuad(state.render.triRender, tl, br, backWhiteColor, mtx);\n\n    let colW = 8;\n    let colTl = new Vec3(tl.x + lerp(0, br.x - tl.x - colW, posPct), tl.y);\n    let colBr = new Vec3(colTl.x + colW, br.y);\n\n    let cellTl = new Vec3(colTl.x, colTl.y + lerp(0, br.y - tl.y - colW, heightPct));\n    let cellBr = new Vec3(colBr.x, cellTl.y + colW);\n\n    addQuad(state.render.triRender, colTl, colBr, color.mul(0.3), mtx);\n    addQuad(state.render.triRender, cellTl, cellBr, color, mtx);\n\n    let textOpts: IFontOpts = { color: new Vec4(1, 1, 1, 1).mul(0.8), mtx, size: 20 };\n    let tw = measureText(state.render.modelFontBuf, 't', textOpts);\n\n    drawText(state.render.modelFontBuf, 't', (cellTl.x + cellBr.x) / 2 - tw / 2, colTl.y - 3 - textOpts.size, textOpts);\n}\n\n\nexport function drawOLMatrixMul(args: IDataFlowArgs) {\n    let { center, mtx, blk } = args;\n    let fontOpts = { color: opColor, mtx, size: 16 };\n\n    let hasAdd = !!blk.deps!.add;\n    let dotA = blk.deps!.dot![0];\n    let dotB = blk.deps!.dot![1];\n\n    function cellSizeAndColor(dep: IBlkCellDep) {\n        let isRow = dep.srcIdxMtx.g(0, 3) === 1.0;\n        return {\n            cellX: isRow ? 4 : 1,\n            cellY: isRow ? 1 : 4,\n            color: dep.src.t === 'w' ? weightSrcColor : workingSrcColor,\n        };\n    }\n\n    let textBlock = mkTextBlock({\n        opts: fontOpts,\n        subs: [\n            hasAdd ? { cellX: 1, cellY: 1, color: weightSrcColor } : null,\n            hasAdd ? { text: ' + dot(' } : { text: 'dot(' },\n            cellSizeAndColor(dotA),\n            { text: ',' },\n            cellSizeAndColor(dotB),\n            { text: ')' },\n        ].filter(isNotNil),\n    });\n\n    return drawMaths(args, center, textBlock);\n}\n\nexport function drawRoundedRect(state: IRenderState, tl: Vec3, br: Vec3, color: Vec4, mtx: Mat4f, radius: number) {\n\n    if (radius === 0) {\n        addQuad(state.triRender, tl, br, color, mtx);\n        return;\n    }\n\n    radius = Math.min(radius, (br.x - tl.x) / 2, (br.y - tl.y) / 2);\n\n    let n = new Vec3(0, 0, 1);\n    let innerQuadTl = tl.add(new Vec3(radius, radius));\n    let innerQuadBr = br.sub(new Vec3(radius, radius));\n\n    // inner quad\n    addQuad(state.triRender, innerQuadTl, innerQuadBr, color, mtx);\n\n    // bottom right starting point\n    addVert(state.triRender, new Vec3(innerQuadBr.x, br.y), color, n, mtx);\n    addVert(state.triRender, new Vec3(innerQuadBr.x, innerQuadBr.y), color, n, mtx);\n\n    for (let cIdx = 0; cIdx < 4; cIdx++) {\n        let pivot = new Vec3(\n            cIdx < 2 ? innerQuadTl.x : innerQuadBr.x,\n            (cIdx + 1) % 4 < 2 ? innerQuadBr.y : innerQuadTl.y,\n        );\n\n        let startTheta = ((cIdx + 1) % 4) * Math.PI / 2;\n\n        // pivot around each of the 4 corners\n        let nRadiusVerts = 6;\n        for (let i = 0; i < nRadiusVerts + 1; i++) {\n            let pt = new Vec3(\n                pivot.x + radius * Math.cos(startTheta + i * Math.PI / nRadiusVerts / 2),\n                pivot.y + radius * Math.sin(startTheta + i * Math.PI / nRadiusVerts / 2),\n            )\n            addVert(state.triRender, pt, color, n, mtx);\n            addVert(state.triRender, pivot, color, n, mtx);\n        }\n    }\n    addPrimitiveRestart(state.triRender);\n}\n\nfunction drawMaths(args: IDataFlowArgs, bottomMiddle: Vec3, textBlk: ITextBlock, pad?: number[] | number) {\n    let { state, mtx } = args;\n\n    let value = getBlockValueAtIdx(args.blk, args.destIdx);\n\n    if (textBlk.type === TextBlockType.Line) {\n        textBlk.subs!.push(\n            mkTextBlock({ text: '  =  ', opts: textBlk.opts }),\n        );\n        if (isNotNil(value)) {\n            textBlk.subs!.push(\n                mkTextBlock({ text: value.toFixed(2), opts: textBlk.opts, size: new Vec3(35, 0), align: TextAlignHoriz.Right }),\n            );\n        }\n    }\n\n    sizeBlock(state.render, textBlk);\n\n    textBlk.offset = new Vec3(bottomMiddle.x - textBlk.size.x / 2, bottomMiddle.y - textBlk.size.y);\n\n    layoutBlock(textBlk);\n\n    let padX = 4;\n    let padY = 4;\n\n    let tl = textBlk.offset.sub(new Vec3(padX + getPad(pad, 2), padY + getPad(pad, 0)));\n    let br = textBlk.offset.add(textBlk.size).add(new Vec3(padX * 2 + getPad(pad, 1), padY + getPad(pad, 3)));\n    drawRoundedRect(state.render, tl, br, backWhiteColor, mtx, 4);\n\n    drawBlock(state.render, textBlk);\n    return new BoundingBox3d(tl, br);\n}\n\nfunction getPad(pad: number[] | number | null | undefined, dir: number) {\n    if (Array.isArray(pad)) {\n        return pad[dir];\n    } else if (typeof pad === 'number') {\n        return pad;\n    }\n    return 0;\n}\n\nfunction drawLayerNormMuAgg(args: IDataFlowArgs) {\n    let { center, mtx } = args;\n    let fontOpts: IFontOpts = { color: opColor, mtx, size: 16 };\n\n    let textBlock = mkTextBlock({\n        opts: fontOpts,\n        subs: [\n            { text: 'E[', color: workingSrcColor },\n            { cellX: 1, cellY: 3, color: workingSrcColor },\n            { text: ']', color: workingSrcColor },\n\n        ],\n    });\n\n    return drawMaths(args, center, textBlock);\n}\n\nfunction drawLayerNormSigmaAgg(args: IDataFlowArgs) {\n    let { center, mtx } = args;\n    let fontOpts: IFontOpts = { color: opColor, mtx, size: 16 };\n\n    let textBlock = mkTextBlock({\n        opts: fontOpts,\n        subs: [{\n            type: TextBlockType.Sqrt,\n            subs: [\n                {\n                    type: TextBlockType.Line, subs: [\n                        { text: 'Var[', color: workingSrcColor },\n                        { cellX: 1, cellY: 3, color: workingSrcColor },\n                        { text: ']', color: workingSrcColor },\n                        { text: ' + ε' },\n                    ]\n                },\n            ],\n        }],\n    });\n\n    return drawMaths(args, center, textBlock);\n}\n\nfunction drawLayerNorm(args: IDataFlowArgs) {\n    let { center, mtx } = args;\n    let fontOpts: IFontOpts = { color: opColor, mtx, size: 16 };\n\n    let blk = mkTextBlock({\n        opts: fontOpts,\n        subs: [{\n            type: TextBlockType.Divide,\n            subs: [\n                {\n                    subs: [\n                        { cellX: 1, cellY: 1, color: workingSrcColor },\n                        { text: ' \\— ' },\n                        {\n                            type: TextBlockType.Line,\n                            rectOpts: { color: Colors.Aggregates.mul(0.8), mtx, thick: 1.0, dash: 6 },\n                            subs: [\n                                { text: 'E[', color: workingSrcColor },\n                                { cellX: 1, cellY: 3, color: workingSrcColor },\n                                { text: ']', color: workingSrcColor },\n                            ],\n                        },\n                    ],\n                },\n                {\n                    type: TextBlockType.Line,\n                    rectOpts: { color: Colors.Aggregates.mul(0.8), mtx, thick: 1.0, dash: 6 },\n                    subs: [{\n                        type: TextBlockType.Sqrt,\n                        subs: [\n                            {\n                                type: TextBlockType.Line, subs: [\n                                    { text: 'Var[', color: workingSrcColor },\n                                    { cellX: 1, cellY: 3, color: workingSrcColor },\n                                    { text: ']', color: workingSrcColor },\n                                    { text: ' + ε' },\n                                ]\n                            },\n                        ],\n                    }],\n                }]\n        },\n        { text: '  ‧ ' },\n        { text: 'γ', color: weightSrcColor },\n        { text: ' + ' },\n        { text: 'β', color: weightSrcColor },\n        ],\n    });\n\n    return drawMaths(args, center, blk);\n}\n\nfunction drawResidualAdd(args: IDataFlowArgs) {\n    let { center, mtx } = args;\n    let fontOpts: IFontOpts = { color: opColor, mtx, size: 16 };\n\n    let textBlock = mkTextBlock({\n        opts: fontOpts,\n        subs: [\n            { cellX: 1, cellY: 1, opts: { ...fontOpts, color: workingSrcColor } },\n            { text: ' + ' },\n            { cellX: 1, cellY: 1, opts: { ...fontOpts, color: workingSrcColor } },\n        ],\n    });\n\n    return drawMaths(args, center, textBlock);\n}\n\nfunction drawZeroSymbol(args: IDataFlowArgs) {\n    let { center, mtx } = args;\n    let fontOpts: IFontOpts = { color: opColor, mtx, size: 16 };\n\n    let textBlock = mkTextBlock({\n        opts: fontOpts,\n        subs: [\n            { text: '-' },\n        ],\n    });\n\n    return drawMaths(args, center, textBlock);\n}\n\nfunction drawSoftmaxAggMax(args: IDataFlowArgs) {\n    let { center, mtx } = args;\n    let fontOpts: IFontOpts = { color: opColor, mtx, size: 16 };\n\n    let textBlock = mkTextBlock({\n        opts: fontOpts,\n        subs: [\n            { text: 'max(' },\n            { cellX: 3, cellY: 1, color: workingSrcColor },\n            { text: ')' },\n        ],\n    });\n\n    return drawMaths(args, center, textBlock);\n}\n\nfunction drawMeinsum(args: IDataFlowArgs) {\n    let { center, mtx } = args;\n    const testText = `\n    let fontOpts: IFontOpts = { color: opColor, mtx, size: 16 };\n    `\n    let fontOpts: IFontOpts = { color: opColor, mtx, size: 16 };\n    const textBlock = mkTextBlock({\n        opts: fontOpts,\n        subs: [\n            { text: testText },\n            { text: testText },\n            { text: testText },\n        ]\n    })\n    // return drawMaths(args, center, textBlock);\n}\nfunction drawSoftmaxAggExp(args: IDataFlowArgs) {\n    let { center, mtx } = args;\n    let fontOpts: IFontOpts = { color: opColor, mtx, size: 16 };\n\n    let textBlock = mkTextBlock({\n        opts: fontOpts,\n        subs: [\n            { text: 'Σ', opts: { ...fontOpts, size: fontOpts.size * 1.5 } },\n            { text: 'exp(' },\n            { cellX: 1, cellY: 1, color: workingSrcColor },\n            { text: ' - ' },\n            {\n                type: TextBlockType.Line,\n                rectOpts: { color: Colors.Aggregates.mul(0.8), mtx, thick: 1.0, dash: 6 },\n                subs: [\n                    { text: 'max(' },\n                    { cellX: 3, cellY: 1, color: workingSrcColor },\n                    { text: ')' },\n                ],\n            },\n            { text: ')' },\n        ],\n    });\n\n    return drawMaths(args, center, textBlock);\n}\n\nfunction drawSoftmax(args: IDataFlowArgs) {\n    let { center, mtx } = args;\n    let fontOpts: IFontOpts = { color: opColor, mtx, size: 16 };\n\n    let textBlock = mkTextBlock({\n        opts: fontOpts,\n        subs: [{\n            type: TextBlockType.Divide,\n            subs: [{\n                subs: [\n                    { text: 'exp(' },\n                    { cellX: 1, cellY: 1, color: workingSrcColor },\n                    { text: ' - ' },\n                    {\n                        rectOpts: { color: Colors.Aggregates.mul(0.8), mtx, thick: 1.0, dash: 6 },\n                        subs: [\n                            { text: 'max(' },\n                            { cellX: 3, cellY: 1, color: workingSrcColor },\n                            { text: ')' },\n                        ],\n                    },\n                    { text: ')' },\n                ],\n            }, {\n                type: TextBlockType.Line,\n                rectOpts: { color: Colors.Aggregates.mul(0.8), mtx, thick: 1.0, dash: 6 },\n                subs: [\n                    { text: 'Σ', opts: { ...fontOpts, size: fontOpts.size * 1.5 } },\n                    { text: 'exp(' },\n                    { cellX: 1, cellY: 1, color: workingSrcColor },\n                    { text: ' - ' },\n                    {\n                        type: TextBlockType.Line,\n                        subs: [\n                            { text: 'max(' },\n                            { cellX: 3, cellY: 1, color: workingSrcColor },\n                            { text: ')' },\n                        ],\n                    },\n                    { text: ')' },\n                ],\n            }],\n        }],\n    });\n\n    return drawMaths(args, center, textBlock);\n}\n\nexport function drawAttention(args: IDataFlowArgs) {\n    let { center, mtx, blk } = args;\n    let fontOpts = { color: opColor, mtx, size: 16 };\n\n    let dotA = blk.deps!.dot![0];\n    let dotB = blk.deps!.dot![1];\n\n    function cellSizeAndColor(dep: IBlkCellDep) {\n        let isRow = dep.srcIdxMtx.g(0, 3) === 1.0;\n        return {\n            cellX: isRow ? 4 : 1,\n            cellY: isRow ? 1 : 4,\n            color: dep.src.t === 'w' ? weightSrcColor : workingSrcColor,\n        };\n    }\n\n    let textBlock = mkTextBlock({\n        opts: fontOpts,\n        subs: [\n            { text: 'dot(' },\n            cellSizeAndColor(dotA),\n            { text: ',' },\n            cellSizeAndColor(dotB),\n            { text: ') / ' },\n            {\n                type: TextBlockType.Sqrt,\n                subs: [{ text: 'A' }],\n            },\n        ],\n    });\n\n    return drawMaths(args, center, textBlock);\n}\n\nexport function drawGeluActivation(args: IDataFlowArgs) {\n    let { state, center, mtx, blk, destIdx } = args;\n\n    // ugly\n    // let fontOpts = { color: opColor, mtx, size: 16 };\n    // let textBlk = mkTextBlock({\n    //     opts: fontOpts,\n    //     subs: [\n    //         { text: '0.5' },\n    //         { cellX: 1, cellY: 1, color: workingSrcColor },\n    //         { text: '(1 + tanh(' },\n    //         { type: TextBlockType.Sqrt, subs: [{ text: '2/π' }], },\n    //         { text: '(' },\n    //         { cellX: 1, cellY: 1, color: workingSrcColor },\n    //         { text: ' + 0.044715' },\n    //         { cellX: 1, cellY: 1, color: workingSrcColor },\n    //         { text: '^3)' },\n    //     ],\n    // });\n    // return drawMaths(state, center, mtx, textBlk);\n\n    let geluX = (x: number) => x * 0.5 * (1.0 + Math.tanh(Math.sqrt(2.0 / Math.PI) * (x + 0.044715 * x * x * x)))\n\n    let w = 70;\n    let h = 50;\n\n    let tl = center.sub(new Vec3(w / 2, h, 0));\n    let br = center.add(new Vec3(w / 2, 0, 0));\n\n    drawRoundedRect(state.render, tl, br, backWhiteColor, mtx, 4);\n\n    let halfW = 3;\n    let halfH = halfW * h / w;\n    let hOffset = 1.2;\n    let mappingX = createMapping(tl.x, br.x, -halfW, halfW);\n    let mappingY = createMapping(br.y, tl.y, -halfH + hOffset, halfH + hOffset);\n\n    let nPts = 30;\n    let pts = new Float32Array(nPts * 3);\n    for (let i = 0; i < nPts; i++) {\n        let x = -halfW + i * halfW * 2 / (nPts - 1);\n        let y = geluX(x);\n        pts[i * 3 + 0] = mappingX(x);\n        pts[i * 3 + 1] = mappingY(y);\n    }\n\n    let axisLineOpts = makeLineOpts({ color: new Vec4(0.5, 0.5, 0.5, 1), mtx, thick: 1.5 });\n    addLine2(state.render.lineRender, new Vec3(tl.x, mappingY(0)), new Vec3(br.x, mappingY(0)), axisLineOpts);\n    addLine2(state.render.lineRender, new Vec3(mappingX(0), tl.y), new Vec3(mappingX(0), br.y), axisLineOpts);\n\n    let curveLineOpts = makeLineOpts({ color: Colors.Intermediates, mtx, thick: 3.5 });\n    drawLineSegs(state.render.lineRender, pts, curveLineOpts);\n\n    let srcBlk = blk.deps!.add![0].src;\n    let srcVal = getBlockValueAtIdx(srcBlk, destIdx);\n\n    if (isNotNil(srcVal)) {\n        let destVal = geluX(srcVal);\n        drawCircle(state.render, new Vec3(mappingX(srcVal), mappingY(destVal)), 2, 1, Colors.Intermediates, mtx);\n    }\n\n    let bb = new BoundingBox3d(tl, br);\n\n    return bb;\n}\n\nexport function createMapping(range0: number, range1: number, domain0: number, domain1: number) {\n    let m = (range1 - range0) / (domain1 - domain0);\n    let b = range0 - m * domain0;\n    return (x: number) => m * x + b;\n}\n\nfunction drawCellIndexAndValue(args: IDataFlowArgs, bb: BoundingBox3d): BoundingBox3d {\n    let { center, mtx, blk, destIdx } = args;\n    let fontOpts = { color: opColor, mtx, size: 14 };\n\n    function mapDimToSub(dim: DimStyle, idx: number): ITextBlockArgs | null {\n        if (dim === DimStyle.None) {\n            return null;\n        }\n        let posValue = destIdx.getAt(idx);\n        let color = dimStyleColor(dim);\n        let text = `${dimStyleTextShort(dim)}: ${posValue}`;\n        return { text, color };\n    }\n\n    let xDim = mapDimToSub(blk.dimX, 0);\n    let yDim = mapDimToSub(blk.dimY, 1);\n\n    let textBlock = mkTextBlock({\n        opts: fontOpts,\n        subs: [\n            xDim,\n            xDim && yDim && { text: ', ' },\n            yDim,\n        ],\n    });\n\n    let padX = 4;\n    let padY = 4;\n\n    sizeBlock(args.state.render, textBlock);\n    textBlock.offset = new Vec3(args.center.x - textBlock.size.x / 2, bb.min.y - fontOpts.size * 1.2 - padX, 0);\n    layoutBlock(textBlock);\n\n    let tl = textBlock.offset.sub(new Vec3(padX, padY));\n    let br = textBlock.offset.add(textBlock.size).add(new Vec3(padX * 2, padY * 2));\n\n    drawRoundedRect(args.state.render, tl, br, backWhiteColor, mtx, 4);\n\n    drawBlock(args.state.render, textBlock);\n    return new BoundingBox3d(tl, br);\n}\n\n\nfunction drawDepArrows(args: IDataFlowArgs, bb: BoundingBox3d) {\n    let { state, mtx, blk, destIdx } = args;\n    if (!blk.deps) {\n        return;\n    }\n\n    function drawDepArrow(dep: IBlkCellDep, dotLen?: number | null) {\n        let { srcIdx, otherDim, isDot } = getDepSrcIdx(dep, destIdx);\n\n        if (dep.src.opacity === 0) {\n            return;\n        }\n\n        if (isDot) {\n            let { cx } = dimProps(dep.src, otherDim);\n            srcIdx.setAt(otherDim, (dotLen ?? cx) / 2);\n        }\n\n        if (blk.deps?.special === BlKDepSpecial.InputEmbed && dep.src === args.state.layout.tokEmbedObj) {\n            let tokenIdx = getBlockValueAtIdx(state.layout.idxObj, new Vec3(destIdx.x, 0, destIdx.z));\n            srcIdx.setAt(Dim.X, tokenIdx ?? 0);\n        }\n\n        let srcT = dep.src.t;\n        let color = srcT === 'w' ? Colors.Weights : srcT === 'i' ? Colors.Intermediates : Colors.Aggregates;\n\n        drawArrow(dep.src, srcIdx, color, false);\n    }\n\n    function drawFinalArrow() {\n        drawArrow(blk, destIdx, new Vec4(0, 0, 0, 1), true);\n    }\n\n    function drawArrow(blk: IBlkDef, idx: Vec3, color: Vec4, reverse?: boolean) {\n        let cellPos = new Vec3(\n            cellPosition(state.layout, blk, Dim.X, idx.x) + state.layout.cell * 0.5,\n            cellPosition(state.layout, blk, Dim.Y, idx.y) + state.layout.cell * 0.5,\n            cellPosition(state.layout, blk, Dim.Z, idx.z) + state.layout.cell * 1.1,\n        );\n\n        // let's just draw a straight line for now\n\n        let lineOpts = makeLineOpts({ n: new Vec3(0, 0, 1), color, mtx, thick: 0.5, dash: 10 });\n\n        let source = projectToScreen(state, cellPos);\n\n        let center = bb.center();\n        let dir = source.sub(center).normalize();\n        let tVals = [\n            (bb.min.x - center.x) / dir.x,\n            (bb.max.x - center.x) / dir.x,\n            (bb.min.y - center.y) / dir.y,\n            (bb.max.y - center.y) / dir.y,\n        ];\n\n        let actualTarget: Vec3 | null = null;\n        for (let t of tVals) {\n            let p = center.mulAdd(dir, t);\n            let eps = 0.00001;\n            if (t > 0 && p.x > bb.min.x - eps && p.y > bb.min.y - eps && p.x < bb.max.x + eps && p.y < bb.max.y + eps) {\n                actualTarget = center.mulAdd(dir, t + 4);\n                break;\n            }\n        }\n\n        if (actualTarget) {\n            if (reverse) {\n                let tmp = source;\n                source = actualTarget;\n                actualTarget = tmp;\n            }\n            drawArc(state, source, actualTarget, color, mtx, 1.0);\n            // addLine2(state.render.lineRender, source, actualTarget, lineOpts);\n        }\n    }\n\n    if (blk.deps.add) {\n        for (let dep of blk.deps.add) {\n            drawDepArrow(dep);\n        }\n    }\n    if (blk.deps.dot) {\n        let dotLen = getDepDotLen(blk, destIdx);\n        for (let dep of blk.deps.dot) {\n            drawDepArrow(dep, dotLen);\n        }\n    }\n    drawFinalArrow();\n}\n\n// create clockwise arc from a to b\n// have line from a to b, bisect it, and cross dir with z for direction\n// scale bisection by distance\n// this now marks the center of the circle\n// grab radius (easy), and then figure out start/end angles\n\nfunction drawArc(state: IProgramState, a: Vec3, b: Vec3, color: Vec4, mtx: Mat4f, thick: number) {\n    let dir = b.sub(a).normalize();\n    let bisect = Vec3.cross(dir, new Vec3(0, 0, 1)).normalize();\n    let center = a.lerp(b, 0.5).add(bisect.mul(a.dist(b) * -2.0));\n\n    let radius = a.dist(center);\n    let endAngle = Math.atan2(b.y - center.y, b.x - center.x);\n    let startAngle = Math.atan2(a.y - center.y, a.x - center.x);\n\n    if (endAngle < startAngle) {\n        endAngle += Math.PI * 2;\n    }\n    if (endAngle - startAngle > Math.PI) {\n        endAngle -= Math.PI * 2;\n    }\n\n    let lineOpts = makeLineOpts({ color, mtx, thick, dash: 0 });\n\n    let nPts = 32;\n    let pts = new Float32Array(3 * nPts);\n\n    for (let i = 0; i < nPts; i++) {\n        let t = i / (nPts - 1);\n        let angle = lerp(startAngle, endAngle, t);\n        let x = center.x + radius * Math.cos(angle);\n        let y = center.y + radius * Math.sin(angle);\n        pts[i * 3 + 0] = x;\n        pts[i * 3 + 1] = y;\n    }\n\n    drawLineSegs(state.render.lineRender, pts, lineOpts);\n\n    let tangent = new Vec3(Math.sin(endAngle), -Math.cos(endAngle));\n\n    let dirA = tangent.rotateAbout(new Vec3(0, 0, 1), -Math.PI * 0.25);\n    let dirB = tangent.rotateAbout(new Vec3(0, 0, 1), Math.PI * 0.25);\n\n    let arrowLen = 10;\n    addLine2(state.render.lineRender, b, b.mulAdd(dirA, arrowLen), lineOpts);\n    addLine2(state.render.lineRender, b, b.mulAdd(dirB, arrowLen), lineOpts);\n}\n","import { blockDimension, dimProps, findSubBlocks, splitGrid, splitGridAll, splitGridForHighlight } from \"./Annotations\";\nimport { drawDataFlow, getBlockValueAtIdx } from \"./components/DataFlow\";\nimport { BlKDepSpecial, IBlkCellDep, IBlkDef } from \"./GptModelLayout\";\nimport { IProgramState } from \"./Program\";\nimport { clamp, isNotNil } from \"@/src/utils/data\";\nimport { Dim, Vec3, Vec4 } from \"@/src/utils/vector\";\n\nexport function runMouseHitTesting(state: IProgramState) {\n\n    let mouse = state.mouse;\n\n    let canvasSize = state.render.size;\n\n    let ndcX = mouse.mousePos.x / canvasSize.x * 2 - 1;\n    let ndcY = 1 - (mouse.mousePos.y / canvasSize.y * 2);\n\n    let viewMtx = state.camera.viewMtx;\n    let viewMtxInv = viewMtx.invert();\n    let modelMtx = state.camera.modelMtx;\n    let modelMtxInv = modelMtx.invert();\n\n    function clipToWorld(v: Vec4) {\n        let v2 = viewMtxInv.mulVec4(v);\n        let v3 = modelMtxInv.mulVec4(v2);\n        return v3.projToVec3();\n    }\n\n    let clipSpaceA = new Vec4(ndcX, ndcY, -1, 1);\n    let clipSpaceB = new Vec4(ndcX, ndcY, 1, 1);\n\n    let worldA = clipToWorld(clipSpaceA);\n    let worldB = clipToWorld(clipSpaceB);\n    let dir = worldB.sub(worldA).normalize();\n\n    // state.display.lines.push(`dir: ${dir.toString()}`);\n\n    // addLine2(state.render.lineRender, midWorld, midWorld.add(new Vec3(100,0,0)), { color: new Vec4(1, 0, 0, 1), thick: 10, mtx: new Mat4f() });\n\n    let visibleCubes: [IBlkDef, IBlkDef][] = [];\n    function addCube(c: IBlkDef, mainCube: IBlkDef) {\n        if (c.subs) {\n            for (let sub of c.subs) {\n                addCube(sub, mainCube || c);\n            }\n        } else if (c.opacity > 0) {\n            visibleCubes.push([c, mainCube]);\n        }\n    }\n    for (let c of state.layout.cubes) {\n        addCube(c, c);\n    }\n\n    let minT = 0.0;\n    let minCube: [IBlkDef, IBlkDef] | null = null;\n\n    for (let [c, main] of visibleCubes) {\n        let tl = new Vec3(c.x, c.y, c.z);\n        let br = new Vec3(c.x + c.dx, c.y + c.dy, c.z + c.dz);\n\n        let t = rayAABBIntersect(tl, br, worldA, dir);\n\n        // console.log('t:', t);\n\n        if (t > 0 && (!minCube || t < minT)) {\n            minT = t;\n            minCube = [c, main];\n        }\n    }\n\n    if (minCube) {\n        let [c, main] = minCube;\n\n        let tl = new Vec3(c.x, c.y, c.z);\n        let pt = worldA.add(dir.mul(minT));\n\n        let pt2 = new Vec3(\n            clamp((pt.x - tl.x) / c.dx, 0, 1 - 0.1 / c.cx),\n            clamp((pt.y - tl.y) / c.dy, 0, 1 - 0.1 / c.cy),\n            clamp((pt.z - tl.z) / c.dz, 0, 1 - 0.1 / c.cz));\n\n        let pt3 = c.localMtx ? c.localMtx.mulVec3Proj(pt2) : pt2;\n\n        // the main block's index (useful for showing correct info against)\n        let ptIdx = new Vec3(\n            Math.floor(pt3.x * c.cx),\n            Math.floor(pt3.y * c.cy),\n            Math.floor(pt3.z * c.cz),\n        );\n\n        state.display.hoverTarget = { mainCube: main, subCube: c, mainIdx: ptIdx };\n\n        for (let label of state.layout.labels) {\n            for (let c of label.cubes) {\n                if (c === main) {\n                    label.visible = 1.0;\n                }\n            }\n        }\n\n        blockDimension(state, state.layout, main, Dim.X, main.dimX, 1.0);\n        blockDimension(state, state.layout, main, Dim.Y, main.dimY, 1.0);\n\n        highlightCellUnderMouse(state, main, c, pt2);\n        drawDependences(state, main, ptIdx);\n        drawDataFlow(state, main, ptIdx);\n    } else if (isNotNil(state.display.blkIdxHover)) {\n        for (let idx of state.display.blkIdxHover) {\n            let mainBlk = state.layout.cubes[idx];\n\n            iterVisibleSubCubes(mainBlk, (c) => {\n                c.highlight = 0.2;\n            });\n        }\n    }\n\n    if (isNotNil(state.display.dimHover)) {\n        let blks = state.walkthrough.dimHighlightBlocks;\n        for (let blk of blks ?? []) {\n            if (blk.dimX === state.display.dimHover) {\n                blockDimension(state, state.layout, blk, Dim.X, blk.dimX, 1.0);\n            }\n            if (blk.dimY === state.display.dimHover) {\n                blockDimension(state, state.layout, blk, Dim.Y, blk.dimY, 1.0);\n            }\n        }\n    }\n}\n\n\nexport function iterVisibleSubCubes(c: IBlkDef, cb: (c: IBlkDef) => void) {\n    if (c.subs) {\n        for (let sub of c.subs) {\n            iterVisibleSubCubes(sub, cb);\n        }\n    } else {\n        cb(c);\n    }\n}\n\nexport function highlightCellUnderMouse(state: IProgramState, mainBlk: IBlkDef, blk: IBlkDef, pt2: Vec3) {\n\n    iterVisibleSubCubes(mainBlk, (c) => {\n        c.highlight = 0.1;\n    });\n\n    // currently broken otherwise :(\n    if (blk === mainBlk) {\n        let ptLocalIdx = new Vec3(\n            pt2.x * blk.cx * blk.dx / mainBlk.dx,\n            pt2.y * blk.cy * blk.dy / mainBlk.dy,\n            pt2.z * blk.cz * blk.dz / mainBlk.dz,\n        );\n        // need to choose a primary axis (if it makes sense! usually the T axis)\n        // we then highlight that access a little bit\n        // probably need to do that in the GptModelLayout? It's not a super well-defined idea\n        let midX = splitGrid(state.layout, blk, Dim.X, ptLocalIdx.x, 0);\n        if (midX) {\n            midX.highlight = 0.15;\n            let midY = splitGrid(state.layout, midX, Dim.Y, ptLocalIdx.y, 0);\n            if (midY) {\n                let midZ = splitGrid(state.layout, midY, Dim.Z, ptLocalIdx.z, 0);\n                if (midZ) {\n                    midZ.highlight = 0.6;\n                }\n            }\n        }\n    }\n}\n\nexport function getDepSrcIdx(dep: IBlkCellDep, destIdx: Vec3) {\n    let mtx = dep.srcIdxMtx;\n    let hasXDot = mtx.g(0, 3) !== 0;\n    let hasYDot = mtx.g(1, 3) !== 0;\n    let srcIdx4 = mtx.mulVec4(Vec4.fromVec3(destIdx, 0));\n    let srcIdx = new Vec3(srcIdx4.x, srcIdx4.y, srcIdx4.z);\n    // let srcIdx = new Vec3(1, 1, srcIdx4.z);\n    let dotDim = hasXDot ? Dim.Y : Dim.X;\n    return { srcIdx, dotDim, otherDim: dotDim === Dim.X ? Dim.Y : Dim.X, isDot: hasXDot || hasYDot };\n}\n\nexport function getDepDotLen(blk: IBlkDef, destIdx: Vec3): number | null {\n    if (!blk.deps?.dot) {\n        return null;\n    }\n    let dotLen: number | null = null;\n    let triLimit = blk.deps.dot.find(d => d.src.deps?.lowerTri);\n    if (triLimit) {\n        let { srcIdx, dotDim } = getDepSrcIdx(triLimit, destIdx);\n        dotLen = srcIdx.getAt(dotDim);\n    }\n    return dotLen;\n}\n\n\n// function highlightAtIdxs(blk, idxs)\n\nexport function drawDependences(state: IProgramState, blk: IBlkDef, idx: Vec3) {\n    let layout = state.layout;\n    let deps = blk.deps;\n\n\n    function highlightAtPos(blk: IBlkDef, xyz: Vec3) {\n        let sub = splitGridForHighlight(layout, blk, Dim.X, xyz.x);\n        if (!sub) return;\n        sub = splitGridForHighlight(layout, sub, Dim.Y, xyz.y);\n        if (!sub) return;\n        sub = splitGridForHighlight(layout, sub, Dim.Z, xyz.z);\n        if (sub) sub.highlight = 1.5;\n    }\n\n    // highlightAtPos(blk, idx);\n\n\n    function high(blk, srcIdx) {\n        let sub = splitGridForHighlight(layout, blk, Dim.X, srcIdx.x);\n        if (!sub) return;\n        sub = splitGridForHighlight(layout, sub, Dim.Y, srcIdx.y);\n        if (!sub) return;\n        sub = splitGridForHighlight(layout, sub, Dim.Z, srcIdx.z);\n        if (sub) sub.highlight = 1.5;\n    }\n\n    // if (blk.idx2deps) {\n    //     let currentDeps = blk.idx2deps[idx.y];\n    //     currentDeps = currentDeps ? currentDeps[idx.x] : null;\n    //     if (currentDeps) {\n\n    //         for (let { dependentCube, local_idx } of currentDeps) {\n    //             high(dependentCube, new Vec3(local_idx[0], local_idx[1]))\n    //         }\n    //         console.log(idx, 'currentDeps', currentDeps)\n\n    //     } else {\n    //         console.error(idx.x, idx.y)\n\n    //     }\n    // }\n\n    if (!deps) {\n        return;\n    }\n\n\n\n    function drawDep(dep: IBlkCellDep, destIdx: Vec3, dotLen?: number | null) {\n        let { srcIdx, dotDim, otherDim, isDot } = getDepSrcIdx(dep, destIdx);\n\n        if (blk.deps?.special === BlKDepSpecial.InputEmbed && dep.src === state.layout.tokEmbedObj) {\n            let tokenIdx = getBlockValueAtIdx(state.layout.idxObj, new Vec3(destIdx.x, 0, destIdx.z));\n            isDot = false;\n            srcIdx.setAt(Dim.X, tokenIdx ?? 0);\n        }\n\n        if (isDot) {\n            if (dep.src.deps?.lowerTri) {\n                dotLen = dotLen ?? srcIdx.getAt(dotDim);\n            }\n            let sub = splitGridForHighlight(layout, dep.src, dotDim, srcIdx.getAt(dotDim));\n\n            if (sub && isNotNil(dotLen)) {\n                // only highlight up to dotLen\n                splitGrid(layout, sub, otherDim, dotLen, 0);\n                for (let parts of findSubBlocks(sub, otherDim, null, dotLen)) {\n                    parts.highlight = 0.5;\n                }\n            } else {\n                // console.log('BEFORE', blk.subs?.length)\n                splitGridAll(layout, blk, Dim.X)\n                // console.log('AFtER', blk.subs?.length)\n                if (sub) sub.highlight = 1.5;\n            }\n        } else {\n            console.log('srcIdx', srcIdx)\n            high(dep.src, srcIdx);\n        }\n    }\n\n    if (deps.dot) {\n        let dotLen = getDepDotLen(blk, idx);\n        // let i = 0;\n        for (let dep of deps.dot) {\n            // if (i > 0) {\n            drawDep(dep, idx, dotLen);\n            // }\n            // i++;\n        }\n    }\n    if (deps.add) {\n        for (let dep of deps.add) {\n            // for (let srcIdx in [new Vec3(0, 1, 1), new Vec3(0, 0, 0), new Vec3(0, 1, 1)]) {\n            //     let sub = splitGridForHighlight(layout, dep.src, Dim.X, srcIdx.x);\n            //     if (!sub) break;\n            //     sub = splitGridForHighlight(layout, sub, Dim.Y, srcIdx.y);\n            //     if (!sub) break;\n            //     sub = splitGridForHighlight(layout, sub, Dim.Z, srcIdx.z);\n            //     if (sub) sub.highlight = 1.5;\n            // }\n\n            high(dep.src, new Vec3(idx.x, idx.y));\n            high(dep.src, new Vec3(idx.x, idx.x));\n\n            // drawDep(dep, idx);\n        }\n    }\n\n\n}\n\nfunction rayAABBIntersect(tl: Vec3, br: Vec3, rayOrigin: Vec3, rayDir: Vec3) {\n    let tx1 = (tl.x - rayOrigin.x) / rayDir.x;\n    let tx2 = (br.x - rayOrigin.x) / rayDir.x;\n\n    let tmin = Math.min(tx1, tx2);\n    let tmax = Math.max(tx1, tx2);\n\n    let ty1 = (tl.y - rayOrigin.y) / rayDir.y;\n    let ty2 = (br.y - rayOrigin.y) / rayDir.y;\n\n    tmin = Math.max(tmin, Math.min(ty1, ty2));\n    tmax = Math.min(tmax, Math.max(ty1, ty2));\n\n    let tz1 = (tl.z - rayOrigin.z) / rayDir.z;\n    let tz2 = (br.z - rayOrigin.z) / rayDir.z;\n\n    tmin = Math.max(tmin, Math.min(tz1, tz2));\n    tmax = Math.min(tmax, Math.max(tz1, tz2));\n\n    return tmax >= tmin ? tmin : -1;\n}\n","import { IWalkthrough, Phase } from \"./Walkthrough\";\nimport { Colors, commentary, DimStyle, dimStyleColor, embed, ITimeInfo, IWalkthroughArgs, moveCameraTo, phaseTools, setInitialCamera } from \"./WalkthroughTools\";\nimport s from './Walkthrough.module.scss';\nimport { Dim, Vec3, Vec4 } from \"@/src/utils/vector\";\nimport { clamp, makeArray } from \"@/src/utils/data\";\nimport React, { useState } from \"react\";\nimport { useProgramState } from \"../Sidebar\";\nimport { dimProps, findSubBlocks, splitGrid } from \"../Annotations\";\nimport { useGlobalDrag } from \"@/src/utils/pointer\";\nimport { BlkSpecial, IBlkDef } from \"../GptModelLayout\";\nimport { IProgramState } from \"../Program\";\nimport { lerp } from \"@/src/utils/math\";\nimport { drawDependences } from \"../Interaction\";\nimport { drawDataFlow } from \"../components/DataFlow\";\n\n/*\nWe're mostly on the right track here I think.\n\nMain things that could do with improvement:\n\n - Make the camera movement more robust. It should basically be on rails when moving the slider.\n - We store the camera pos at the start of a given movement, and use that as a lerp, and also\n   have a default so we can do a reversal\n\n - Have a highlight-region animation in both the text and the model, to bring attention to a specific\n   point. Probably a rectangle with a rotating border. Could also include a shaded background on the text\n\n - Scroll the text to the next region to read\n\n - Have more pronounced (& consistent) delays between: camera movement/scroll -> higlight -> action\n   - Can probably combine the camera movement and the highlight into a single action, but still have\n     a delay between the highlight and the action\n\n - Generally lean on the new display features more. Might need to add a few more (e.g. animate the dot product)\n - Also probably need to do TeX style layout for maths in the html view :( Could probably reuse the code from the\n   3d layout? Just need to get the glyphs in via css/ttf, and then maybe use canvas for positioning? Hmm should\n   be able to use divs with abs positioning.\n\n - For stopping/starting, use t + dt to figure out when it was crossed, rather than storing the lastPauseTime etc\n\n*/\n\ninterface IIntroState {\n\n}\n\nfunction getIntroState(walkthrough: IWalkthrough): IIntroState {\n    return walkthrough.phaseData.get(Phase.Intro_Intro) as IIntroState;\n}\n\nexport function walkthroughIntro(args: IWalkthroughArgs) {\n    let { breakAfter, afterTime, c_str } = phaseTools(args.state);\n    let { state, layout, walkthrough: wt } = args;\n\n    if (wt.phase !== Phase.Intro_Intro) {\n        return;\n    }\n\n    setInitialCamera(state, new Vec3(184.744, 0.000, -636.820), new Vec3(296.000, 16.000, 13.500));\n\n    let c0 = commentary(wt, null, 0)`Welcome to the walkthrough of the GPT large language model! Here we'll explore the model _nano-gpt_, with a mere 85,000 parameters.\n\nIts goal is a simple one: take a sequence of six letters: ${embed(ExampleInputOutput)}\nand sort them in alphabetical order, i.e. to \"ABBBCC\".`;\n\n    if (c0.t > 0) {\n        for (let cube of layout.cubes) {\n            if (cube.t === 'i' && cube.access) {\n                cube.access.disable = true;\n            }\n        }\n        state.display.tokenIdxModelOpacity = makeArray(6, 0);\n    }\n\n    let t4 = afterTime(null, 1.5, 0.4);\n\n    moveCameraTo(args.state, t4, new Vec3(5.450, 0.000, 7.913), new Vec3(281.500, 12.500, 0.519));\n    let t6 = afterTime(null, 1.0, 0.2);\n\n    if (t4.active) {\n        state.display.topOutputOpacity = 0.2;\n    }\n\n    if (t6.active && t6.t < 1.0) {\n        let mixes = [0, 0, 0, 0, 0, 0];\n        for (let i = 0; i < 6; i++) {\n            // want to smoothly flash each token in turn (t6.t goes from 0-1, and each token should flash at 0.2, 0.4, 0.6, 0.8, 1.0 etc)\n            let highT = (i + 1.5) / 8;\n            mixes[i] = 1.0 - clamp(Math.abs(t6.t - highT) * 4, 0, 1);\n        }\n        state.display.tokenColors = { mixes, color2: dimStyleColor(DimStyle.Token) }; //  new Vec4(0.8, 0.2, 0.8) };\n    }\n\n    breakAfter();\n\n    let tokenStr = c_str('_token_', 0, DimStyle.Token);\n    let tokenIdxStr = c_str('_token index_', 0, DimStyle.TokenIdx);\n\n    commentary(wt, t6)`We call each of these letters a ${tokenStr}, and the set of the model's different tokens make up its _vocabulary_:${embed(TokenVocab)}\n\n    From this table, each token is assigned a number, its ${tokenIdxStr}. And now we can enter this sequence of numbers into the model:${embed(ExampleTokenValues)}\\n`;\n    breakAfter();\n\n    let t7 = afterTime(null, 1.5, 0.5);\n\n    if (t7.active) {\n        let opacity = makeArray(6, 0);\n        for (let i = 0; i < 6; i++) {\n            let highT = (i + 1.5) / 8;\n            opacity[i] = clamp((t7.t - highT) * 4, 0, 1);\n        }\n        state.display.tokenIdxColors = { mixes: opacity, color2: dimStyleColor(DimStyle.TokenIdx) };\n\n        let idxPos = t7.t * 6;\n\n        if (t7.t < 1.0) {\n            splitGrid(layout, layout.idxObj, Dim.X, idxPos, clamp(6 - idxPos, 0, 1));\n            for (let blk of findSubBlocks(layout.idxObj, Dim.X, null, Math.min(5, Math.floor(idxPos)))) {\n                if (blk.access) {\n                    blk.access.disable = false;\n                }\n            }\n        } else {\n            if (layout.idxObj.access) {\n                layout.idxObj.access.disable = false;\n            }\n        }\n    }\n\n    breakAfter();\n\n    let c5 = commentary(wt)`In the 3d view, each green cell represents a number being processed, and each blue cell is a weight. ${embed(GreenBlueCells)}\n    Each number in the sequence first gets turned into a 48 element vector (a size chosen for this particular model). This is called an _embedding_.`;\n    breakAfter(c5);\n\n    {\n        let t_camMove = afterTime(null, 1.0, 0.5);\n        let t_makeVecs = afterTime(null, 2.0, 0.5);\n\n        moveCameraTo(state, t_camMove, new Vec3(14.1, 0, -30.4), new Vec3(286, 14.5, 0.8));\n\n        if (t_makeVecs.active) {\n            let idxPos = t_makeVecs.t * 6;\n            let splitWidth = clamp(6 - idxPos, 0, 2);\n            let splitIdx = Math.min(5, Math.floor(idxPos));\n            if (t_makeVecs.t < 1.0) {\n                splitGrid(layout, layout.idxObj, Dim.X, idxPos, splitWidth);\n                for (let blk of findSubBlocks(layout.idxObj, Dim.X, null, splitIdx)) {\n                    if (blk.access) {\n                        blk.access.disable = false;\n                    }\n                }\n\n                splitGrid(layout, layout.residual0, Dim.X, idxPos, splitWidth);\n                for (let blk of findSubBlocks(layout.residual0, Dim.X, null, splitIdx)) {\n                    if (blk.access) {\n                        blk.access.disable = false;\n                    }\n                }\n            } else {\n                if (layout.residual0.access) {\n                    layout.residual0.access.disable = false;\n                }\n            }\n        }\n    }\n\n    breakAfter();\n    commentary(wt)`The embedding is then passed through the model, going through a series of layers, called transformers, before reaching the bottom.`;\n    breakAfter();\n\n    {\n\n        let t_firstResid = afterTime(null, 1.0, 0.5);\n        moveCameraTo(state, t_firstResid, new Vec3(-23.160, 0.000, -128.380), new Vec3(292.300, 26.800, 2.400));\n        let t_firstResidWalk = afterTime(null, 5.0, 0.5);\n\n        let processState = processUpTo(state, t_firstResidWalk, layout.blocks[0].attnResidual);\n\n        let t_firstTransformer = afterTime(null, 1.0, 0.5);\n        moveCameraTo(state, t_firstTransformer, new Vec3(-78.7, 0, -274.2), new Vec3(299.4, 14.7, 4.3));\n        let t_firstTransformerWalk = afterTime(null, 3.5, 0.5);\n        processUpTo(state, t_firstTransformerWalk, layout.blocks[0].mlpResidual, processState);\n\n        if (t_firstTransformer.active) {\n            layout.blocks[0].transformerLabel.visible = t_firstTransformer.t;\n        }\n\n        let t_fullFrame = afterTime(null, 1.0, 0.5);\n        moveCameraTo(state, t_fullFrame, new Vec3(-147, 0, -744.1), new Vec3(298.5, 23.4, 12.2));\n        let t_fullFrameWalk = afterTime(null, 5.0, 0.5);\n        processUpTo(state, t_fullFrameWalk, layout.ln_f.lnResid, processState);\n\n\n        // let t_endFrame = afterTime(null, 1.0, 0.5);\n        // moveCameraTo(state, t_endFrame, new Vec3(-18.3, 0, -1576), new Vec3(280.6, 9.7, 1.9));\n        // let t_endFrameWalk = afterTime(null, 2.0, 0.5);\n        // processUpTo(state, t_endFrameWalk, layout.ln_f.lnResid, processState);\n\n        let t_output = afterTime(null, 1.0, 0.5);\n        moveCameraTo(state, t_output, new Vec3(-58.4, 0, -1654.9), new Vec3(271.3, 6.4, 1.1));\n        // moveCameraTo(state, t_output, new Vec3(-53.9, 0, -1654.1), new Vec3(270.9, 6.2, 1.1));\n        let t_outputWalk = afterTime(null, 2.0, 0.5);\n        processUpTo(state, t_outputWalk, layout.logitsSoftmax, processState);\n\n        let t_outputToks = afterTime(null, 1.0, 0.5);\n\n        if (t_firstResid.active) {\n            let arr = makeArray(6, 0);\n\n            if (t_outputToks.active) {\n                for (let i = 0; i < 6; i++) {\n                    let highT = (i + 1.5) / 8;\n                    arr[i] = clamp((t_outputToks.t - highT) * 4, 0, 1);\n                }\n            }\n\n            // state.display.lines.push(arr.map(a => a.toFixed(2).padStart(4)).join(', '));\n            state.display.tokenOutputColors = { color1: new Vec4(0,0,0,0), color2: Vec4.fromHexColor('#000', 1), mixes: arr };\n        }\n    }\n\n    commentary(wt)`So what's the output? A prediction of the next token in the sequence. So at the 6th entry, we get probabilities that the next token is\n        going to be 'A', 'B', or 'C'.`\n\n    commentary(wt)`In this case, the model is pretty sure it's going to be 'A'. Now, we can feed this prediction back into the top of the model, and repeat\n    the entire process.`;\n\n    breakAfter();\n}\n\ninterface IProcessInfo {\n    lastBlockIdx: number;\n}\n\nexport function startProcessBefore(state: IProgramState, block: IBlkDef): IProcessInfo {\n    let activeBlocks = state.layout.cubes.filter(a => a.t !== 'w');\n\n    return {\n        lastBlockIdx: activeBlocks.indexOf(block) - 1,\n    };\n}\n\nexport function processUpTo(state: IProgramState, timer: ITimeInfo, block: IBlkDef, prevInfo?: IProcessInfo): IProcessInfo {\n\n    let activeBlocks = state.layout.cubes.filter(a => a.t !== 'w');\n\n    let firstIdx = prevInfo ? prevInfo.lastBlockIdx + 1 : 0;\n    let lastIdx = activeBlocks.indexOf(block);\n\n    // we weight the time on each block by the number of cells in the block, times by how many dependent cells it has\n    // although to make this less extreme, we take a fractional power of this\n    let cellCounts = activeBlocks\n        .filter((_, i) => i >= firstIdx && i <= lastIdx)\n        .map(a => (a.cx * a.cy) * Math.pow(a.deps?.dotLen ?? 1, 0.25));\n    let totalCells = cellCounts.reduce((a, b) => a + b, 0);\n\n    let accCell = 0;\n    let currIdx = firstIdx;\n    let subPos = 0; // 0 -> 1\n    for (let i = firstIdx; i <= lastIdx; i++) {\n        let blockFract = cellCounts[i - firstIdx] / totalCells;\n        accCell += blockFract;\n        if (timer.t < accCell) {\n            currIdx = i;\n            subPos = (timer.t - (accCell - blockFract)) / blockFract;\n            break;\n        }\n    }\n\n    let blk = activeBlocks[currIdx];\n\n    // default, but switched for attention matrix\n    let dim0 = Dim.X;\n    let dim1 = Dim.Y;\n    if (blk.transpose) {\n        dim0 = Dim.Y;\n        dim1 = Dim.X;\n    }\n\n    let { cx } = dimProps(blk, dim0);\n    let { cx: cy } = dimProps(blk, dim1);\n\n    let horizPos = lerp(0, cx, subPos);\n    let horizIdx = Math.floor(horizPos);\n\n    let vertPos = lerp(0, cy, horizPos - horizIdx);\n    let vertIdx = Math.floor(vertPos);\n\n    let blockPos = new Vec3().withSetAt(dim0, horizIdx).withSetAt(dim1, vertIdx); // new Vec3(horizIdx, vertIdx, 0);\n    let pinPos = new Vec3(Math.floor(cx / 2), 0, 0);\n\n    if (blk === state.layout.residual0) {\n        pinPos = new Vec3(cx * 2, -2, 0);\n    }\n\n    if (timer.t >= 1.0) {\n        currIdx = lastIdx;\n    }\n\n    for (let i = firstIdx; i < currIdx; i++) {\n        let blk = activeBlocks[i];\n        if (blk.access) {\n            blk.access.disable = false;\n        }\n    }\n\n    if (timer.active && timer.t < 1.0) {\n        drawDependences(state, blk, blockPos);\n        drawDataFlow(state, blk, blockPos, pinPos);\n\n        for (let label of state.layout.labels) {\n            for (let c of label.cubes) {\n                if (c === blk) {\n                    label.visible = 1.0;\n                }\n            }\n        }\n\n        blk.highlight = 0.3;\n\n        let column = splitGrid(state.layout, blk, dim0, horizPos, 0);\n        if (column) {\n            for (let col of findSubBlocks(blk, dim0, null, horizIdx)) {\n                if (col.access) {\n                    col.access.disable = false;\n                    col.highlight = 0.1;\n                }\n            }\n            column.highlight = 0.4;\n\n            let curr = splitGrid(state.layout, column, dim1, vertPos, 0);\n            for (let blk of findSubBlocks(column, dim1, null, vertIdx)) {\n                if (blk.access) {\n                    blk.access.disable = false;\n                }\n            }\n            if (curr) {\n                curr.highlight = 0.7;\n            }\n        }\n\n\n    } else if (timer.active) {\n        let blk = activeBlocks[lastIdx];\n        if (blk.access) {\n            blk.access.disable = false;\n        }\n    }\n\n    let info = prevInfo ?? { lastBlockIdx: currIdx };\n    info.lastBlockIdx = lastIdx;\n    return info;\n}\n\nconst ExampleInputOutput: React.FC = () => {\n    let state = useProgramState();\n    let cols = state.display.tokenColors;\n    let chars = 'CBABBC'.split('');\n\n    return <div className={s.tableWrap}>\n        <div>{chars.map((c, i) => {\n            let baseColor = dimStyleColor(DimStyle.Token);\n            if (cols) {\n                baseColor = Vec4.lerp(baseColor, cols.color2, cols.mixes[i]);\n            }\n            return <span key={i} style={{ color: baseColor.toHexColor() }}>{c} </span>;\n        })}</div>\n    </div>;\n};\n\nconst ExampleTokenValues: React.FC = () => {\n    let state = useProgramState();\n    let cols = state.display.tokenIdxColors;\n    let chars = 'CBABBC'.split('');\n\n     return <div className={s.tableWrap}>\n        <div>{chars.map((c, i) => {\n            let tokIdx = c.charCodeAt(0) - 'A'.charCodeAt(0);\n\n            let baseColor = dimStyleColor(DimStyle.TokenIdx);\n            if (cols) {\n                baseColor = Vec4.lerp(baseColor, cols.color2, cols.mixes[i]);\n            }\n            return <span key={i} style={{ color: baseColor.toHexColor() }}>{tokIdx} </span>;\n        })}</div>\n    </div>;\n};\n\nconst TokenVocab: React.FC = () => {\n\n    return <div className={s.tableWrap}>\n        <table className={s.table}>\n            <tbody>\n                <tr className={s.tokString} style={{ color: dimStyleColor(DimStyle.Token).toHexColor() }}>\n                    <th>token</th><td>A</td><td>B</td><td>C</td>\n                </tr>\n                <tr className={s.tokIndex} style={{ color: dimStyleColor(DimStyle.TokenIdx).toHexColor() }}>\n                    <th>index</th><td>0</td><td>1</td><td>2</td>\n                </tr>\n            </tbody>\n        </table>\n    </div>\n};\n\nconst GreenBlueCells: React.FC = () => {\n\n    let [blueNums, setBlueNums] = useState([-0.7, 0.7, -0.1]);\n    let [greenNums, setGreenNums] = useState([-0.7, 0.4, 0.8]);\n\n    let blueColor = new Vec4(0.3, 0.3, 1.0);\n    let greenColor = new Vec4(0.3, 0.9, 0.3);\n\n    return <div className={s.tableWrap}>\n        <div className={s.cellInfoCols}>\n            <div className={s.cellInfoCol}>\n                <Cell nums={greenNums} color={greenColor} mul={0.5} />\n                <Graph nums={greenNums} color={greenColor} setNums={setGreenNums} />\n                <div className={s.cellInfoText}>being processed</div>\n            </div>\n            <div className={s.cellInfoCol}>\n                <Cell nums={blueNums} color={blueColor} mul={1} />\n                <Graph nums={blueNums} color={blueColor} setNums={setBlueNums} />\n                <div className={s.cellInfoText}>weights</div>\n            </div>\n        </div>\n    </div>\n};\n\nconst Cell: React.FC<{ nums: number[], color: Vec4, mul?: number }> = ({ color, nums, mul }) => {\n\n    let grey = new Vec4(0.5, 0.5, 0.5, 1.0);\n    let cellLight = Vec4.lerp(color, grey, 0.9);\n    let cellDark = cellLight.mul(0.98);\n    cellDark.w = 1.0;\n\n    let cellColor = (n: number) => {\n        let weight = clamp(Math.abs(n), 0.0, 1.0);\n\n        let negColor = new Vec4(0.0, 0.0, 0.0);\n        let posColor = color;\n        let zeroColor = new Vec4(0.5, 0.5, 0.5);\n        if (n < 0.0) {\n            return Vec4.lerp(zeroColor, negColor, weight).toHexColor();\n        } else {\n            return Vec4.lerp(zeroColor, posColor, weight).toHexColor();\n        }\n    };\n\n    return <div className={s.cellArrayHoriz}>\n        {nums.map((n, i) => {\n            return <div className={s.cellRect} key={i} style={{ backgroundColor: (i % 2 === 0 ? cellLight : cellDark).toHexColor() }}>\n                <div className={s.cellCircle} style={{ backgroundColor: cellColor(n * (mul ?? 1.0)) }} />\n            </div>;\n        })}\n    </div>\n};\n\nconst Graph: React.FC<{\n    nums: number[],\n    color: Vec4,\n    max?: number,\n    setNums?: (nums: number[]) => void,\n}> = ({ color, nums, max, setNums }) => {\n    let [graphEl, setGraphEl] = useState<HTMLDivElement | null>(null);\n\n    let ticks = [-1, 0, 1];\n    let cellW = 30;\n    let dispColor = color.mul(1.0);\n    dispColor.w = 0.5;\n\n    interface IDragInitial {\n        index: number;\n        nums: number[];\n    }\n\n    let [, setDragStart] = useGlobalDrag<IDragInitial>(function handleMove(ev, ds) {\n        let dy = ev.clientY - ds.clientY;\n        let h = graphEl!.clientHeight * 0.5;\n        let nums = [...ds.data.nums];\n        nums[ds.data.index] = clamp(nums[ds.data.index] - dy / h, -1.0, 1.0);\n        setNums?.(nums);\n        ev.preventDefault();\n        ev.stopImmediatePropagation();\n    })\n\n    return <div className={s.graph} style={{ width: cellW * nums.length }} ref={setGraphEl}>\n\n        <div className={s.axisLeft} />\n\n        <div className={s.axisZero} />\n\n        {nums.map((n, i) => {\n            let nScaled = n / (max ?? 1.0);\n\n            return <div className={s.graphCol} key={i}>\n                <div className={s.graphBar} style={{\n                    backgroundColor: dispColor.toHexColor(),\n                    top: nScaled < 0 ? '50%' : `${(0.5 - nScaled/2) * 100}%`,\n                    height: `${(Math.abs(nScaled)/2) * 100}%`,\n                }} />\n                <div\n                    className={s.graphBarHit}\n                    onMouseDown={ev => {\n                        setDragStart(ev, { index: i, nums });\n                        ev.stopPropagation();\n                        ev.preventDefault();\n                    }}\n                    style={{\n                        top: `${(0.5 - nScaled/2) * 100}%`\n                    }} />\n                <div className={s.graphBarLabel} style={{\n                     bottom: nScaled < 0 ? '50%' : undefined,\n                        top: nScaled > 0 ? '50%' : undefined,\n                }}>\n                    {n.toFixed(1)}\n                </div>\n            </div>;\n        })}\n\n    </div>;\n\n};\n","import React from 'react';\nimport { Phase } from \"./Walkthrough\";\nimport { commentary, embed, IWalkthroughArgs, setInitialCamera } from \"./WalkthroughTools\";\nimport s from './Walkthrough.module.scss';\nimport { Vec3 } from '@/src/utils/vector';\n\nlet minGptLink = 'https://github.com/karpathy/minGPT';\nlet pytorchLink = 'https://pytorch.org/';\nlet andrejLink = 'https://karpathy.ai/';\nlet zeroToHeroLink = 'https://karpathy.ai/zero-to-hero.html';\n\nexport function walkthrough01_Prelim(args: IWalkthroughArgs) {\n    let { state, walkthrough: wt } = args;\n\n    if (wt.phase !== Phase.Intro_Prelim) {\n        return;\n    }\n\n    setInitialCamera(state, new Vec3(184.744, 0.000, -636.820), new Vec3(296.000, 16.000, 13.500));\n\n    let c0 = commentary(wt, null, 0)`\nBefore we delve into the algorithm's intricacies, let's take a brief step back.\n\nThis guide focuses on _inference_, not training, and as such is only a small part of the entire machine-learning process.\nIn our case, the model's weights have been pre-trained, and we use the inference process to generate output. This runs directly in your browser.\n\nThe model showcased here is part of the GPT (generative pre-trained transformer) family, which can be described as a \"context-based token predictor\".\nOpenAI introduced this family in 2018, with notable members such as GPT-2, GPT-3, and GPT-3.5 Turbo, the latter being the foundation of the widely-used ChatGPT.\nIt might also be related to GPT-4, but specific details remain unknown.\n\nThis guide was inspired by the ${embedLink('minGPT', minGptLink)} GitHub project, a minimal GPT implementation in ${embedLink('PyTorch', pytorchLink)}\ncreated by ${embedLink('Andrej Karpathy', andrejLink)}.\nHis YouTube series ${embedLink(\"Neural Networks: Zero to Hero\", zeroToHeroLink)} and the minGPT project have been invaluable resources in the creation of this\nguide. The toy model featured here is based on one found within the minGPT project.\n\nAlright, let's get started!\n`;\n\n}\n\nexport function embedLink(a: React.ReactNode, href: string) {\n    return embedInline(<a className={s.externalLink} href={href} target=\"_blank\" rel=\"noopener noreferrer\">{a}</a>);\n}\n\nexport function embedInline(a: React.ReactNode) {\n    return { insertInline: a };\n}\n\n\n// Another similar model is BERT (bidirectional encoder representations from transformers), a \"context-aware text encoder\" commonly\n// used for tasks like document classification and search.  Newer models like Facebook's LLaMA (large language model architecture), continue to use\n// a similar transformer architecture, albeit with some minor differences.\n","import { duplicateGrid, splitGrid } from \"../Annotations\";\nimport { getBlockValueAtIdx } from \"../components/DataFlow\";\nimport { IBlkDef } from \"../GptModelLayout\";\nimport { drawText, IFontOpts, measureText } from \"../render/fontRender\";\nimport { lerp } from \"@/src/utils/math\";\nimport { Mat4f } from \"@/src/utils/matrix\";\nimport { Dim, Vec3, Vec4 } from \"@/src/utils/vector\";\nimport { Phase } from \"./Walkthrough\";\nimport { commentary, DimStyle, IWalkthroughArgs, moveCameraTo, setInitialCamera } from \"./WalkthroughTools\";\nimport { processUpTo, startProcessBefore } from \"./Walkthrough00_Intro\";\n\nexport function walkthrough02_Embedding(args: IWalkthroughArgs) {\n    let { walkthrough: wt, state, tools: { c_str, c_blockRef, c_dimRef, afterTime, cleanup, breakAfter }, layout } = args;\n    let render = state.render;\n\n    if (wt.phase !== Phase.Input_Detail_Embedding) {\n        return;\n    }\n\n    setInitialCamera(state, new Vec3(15.654, 0.000, -80.905), new Vec3(287.000, 14.500, 3.199));\n    wt.dimHighlightBlocks = [layout.idxObj, layout.tokEmbedObj, layout.posEmbedObj, layout.residual0];\n\n    commentary(wt)`\nWe saw previously how the tokens are mapped to a sequence of integers using a simple lookup table.\nThese integers, the ${c_blockRef('_token indices_', state.layout.idxObj, DimStyle.TokenIdx)}, are the first and only time we see integers in the model.\nFrom here on out, we're using floats (decimal numbers).\n\nLet's take a look at how the 4th token (index 3) is used to generate the 4th column vector of our ${c_blockRef('_input embedding_', state.layout.residual0)}.`;\n    breakAfter();\n\n    let t_moveCamera = afterTime(null, 1.0);\n    let t0_splitEmbedAnim = afterTime(null, 0.3);\n\n    breakAfter();\n\n    commentary(wt)`\nWe use the token index (in this case ${c_str('B', DimStyle.Token)} = ${c_dimRef('1', DimStyle.TokenIdx)}) to select the 2nd column of the ${c_blockRef('_token embedding matrix_', state.layout.tokEmbedObj)} on the left.\nNote we're using 0-based indexing here, so the first column is at index 0.\n\nThis produces a column vector of size ${c_dimRef('_C_ = 48', DimStyle.C)}, which we describe as the token embedding.\n    `;\n    breakAfter();\n\n    let t1_fadeEmbedAnim = afterTime(null, 0.3);\n    let t2_highlightTokenEmbed = afterTime(null, 0.8);\n\n    breakAfter();\n\n    commentary(wt)`\nAnd since we're looking at our token ${c_str('B', DimStyle.Token)} in the 4th _position_ (t = ${c_dimRef('3', DimStyle.T)}), we'll take the 4th column of the ${c_blockRef('_position embedding matrix_', state.layout.posEmbedObj)}.\n\nThis also produces a column vector of size ${c_dimRef('_C_ = 48', DimStyle.C)}, which we describe as the position embedding.\n    `;\n    breakAfter();\n\n    let t4_highlightPosEmbed = afterTime(null, 0.8);\n\n    breakAfter();\n\n    commentary(wt)`\nNote that both of these position and token embeddings are learned during training (indicated by their blue color).\n\nNow that we have these two column vectors, we simply add them together to produce another column vector of size ${c_dimRef('_C_ = 48', DimStyle.C)}.\n`;\n\n    breakAfter();\n\n    let t3_moveTokenEmbed = afterTime(null, 0.8);\n    let t5_movePosEmbed = afterTime(null, 0.8);\n    let t6_plusSymAnim = afterTime(null, 0.8);\n    let t7_addAnim = afterTime(null, 0.8);\n    let t8_placeAnim = afterTime(null, 0.8);\n    let t9_cleanupInstant = afterTime(null, 0.0);\n    let t10_fadeAnim = afterTime(null, 0.8);\n\n    breakAfter();\n\n    commentary(wt)`\nWe now run this same process for all of the tokens in the input sequence, creating a set of vectors which incorporate both the token values and their positions.\n\n`;\n\n    breakAfter();\n\n    let t11_fillRest = afterTime(null, 5.0);\n\n    breakAfter();\n\n    commentary(wt)`\nFeel free to hover over individual cells on the ${c_blockRef('_input embedding_', state.layout.residual0)} matrix to see the computations and their sources.\n\nWe see that running this process for all the tokens in the input sequence produces a matrix of size ${c_dimRef('_T_', DimStyle.T)} x ${c_dimRef('_C_', DimStyle.C)}.\nThe ${c_dimRef('_T_', DimStyle.T)} stands for ${c_dimRef('_time_', DimStyle.T)}, i.e., you can think of tokens later in the sequence as later in time.\nThe ${c_dimRef('_C_', DimStyle.C)} stands for ${c_dimRef('_channel_', DimStyle.C)}, but is also referred to as \"feature\" or \"dimension\" or \"embedding size\". This length, ${c_dimRef('_C_', DimStyle.C)},\nis one of the several \"hyperparameters\" of the model, and is chosen by the designer to in a tradeoff between model size and performance.\n\nThis matrix, which we'll refer to as the ${c_blockRef('_input embedding_', state.layout.residual0)} is now ready to be passed down through the model.\nThis collection of ${c_dimRef('T', DimStyle.T)} columns each of length ${c_dimRef('C', DimStyle.C)} will become a familiar sight throughout this guide.\n`;\n\n    cleanup(t9_cleanupInstant, [t3_moveTokenEmbed, t5_movePosEmbed, t6_plusSymAnim, t7_addAnim, t8_placeAnim]);\n    cleanup(t10_fadeAnim, [t0_splitEmbedAnim, t1_fadeEmbedAnim, t2_highlightTokenEmbed, t4_highlightPosEmbed]);\n\n    moveCameraTo(state, t_moveCamera, new Vec3(7.6, 0, -33.1), new Vec3(290, 15.5, 0.8));\n\n    let residCol: IBlkDef = null!;\n    let exampleIdx = 3;\n    if ((t0_splitEmbedAnim.t > 0.0 || t10_fadeAnim.t > 0.0) && t11_fillRest.t === 0) {\n        splitGrid(layout, layout.idxObj, Dim.X, exampleIdx + 0.5, t0_splitEmbedAnim.t * 4.0);\n\n        layout.residual0.access!.disable = true;\n        layout.residual0.opacity = lerp(1.0, 0.1, t1_fadeEmbedAnim.t);\n\n        residCol = splitGrid(layout, layout.residual0, Dim.X, exampleIdx + 0.5, t0_splitEmbedAnim.t * 4.0)!;\n        residCol.highlight = 0.3;\n\n        residCol.opacity = lerp(1.0, 0.0, t1_fadeEmbedAnim.t);\n\n    }\n\n    let tokValue = getBlockValueAtIdx(layout.idxObj, new Vec3(exampleIdx, 0, 0)) ?? 1;\n\n\n    let tokColDupe: IBlkDef | null = null;\n    let posColDupe: IBlkDef | null = null;\n\n    if (t2_highlightTokenEmbed.t > 0.0) {\n        let tokEmbedCol = splitGrid(layout, layout.tokEmbedObj, Dim.X, tokValue + 0.5, t2_highlightTokenEmbed.t * 4.0)!;\n\n        tokColDupe = duplicateGrid(layout, tokEmbedCol);\n        tokColDupe.t = 'i';\n        tokEmbedCol.highlight = 0.3;\n\n        let startPos = new Vec3(tokEmbedCol.x, tokEmbedCol.y, tokEmbedCol.z);\n        let targetPos = new Vec3(residCol.x, residCol.y, residCol.z).add(new Vec3(-2.0, 0, 3.0));\n\n        let pos = startPos.lerp(targetPos, t3_moveTokenEmbed.t);\n\n        tokColDupe.x = pos.x;\n        tokColDupe.y = pos.y;\n        tokColDupe.z = pos.z;\n    }\n\n\n    if (t4_highlightPosEmbed.t > 0.0) {\n        let posEmbedCol = splitGrid(layout, layout.posEmbedObj, Dim.X, exampleIdx + 0.5, t4_highlightPosEmbed.t * 4.0)!;\n\n        posColDupe = duplicateGrid(layout, posEmbedCol);\n        posColDupe.t = 'i';\n        posEmbedCol.highlight = 0.3;\n\n        let startPos = new Vec3(posEmbedCol.x, posEmbedCol.y, posEmbedCol.z);\n        let targetPos = new Vec3(residCol.x, residCol.y, residCol.z).add(new Vec3(2.0, 0, 3.0));\n\n        let pos = startPos.lerp(targetPos, t5_movePosEmbed.t);\n\n        posColDupe.x = pos.x;\n        posColDupe.y = pos.y;\n        posColDupe.z = pos.z;\n    }\n\n    if (t6_plusSymAnim.t > 0.0 && tokColDupe && posColDupe && t7_addAnim.t < 1.0) {\n        for (let c = 0; c < layout.shape.C; c++) {\n            let plusCenter = new Vec3(\n                (tokColDupe.x + tokColDupe.dx + posColDupe.x) / 2,\n                tokColDupe.y + layout.cell * (c + 0.5),\n                tokColDupe.z + tokColDupe.dz / 2);\n\n            let isActive = t6_plusSymAnim.t > (c + 1) / layout.shape.C;\n            let opacity = lerp(0.0, 1.0, isActive ? 1 : 0);\n\n            let fontOpts: IFontOpts = { color: new Vec4(0, 0, 0, 1).mul(opacity), size: 1.5, mtx: Mat4f.fromTranslation(plusCenter) };\n            let w = measureText(render.modelFontBuf, '+', fontOpts);\n\n            drawText(render.modelFontBuf, '+', -w/2, -fontOpts.size/2, fontOpts);\n        }\n    }\n\n    let origResidPos = residCol ? new Vec3(residCol.x, residCol.y, residCol.z) : new Vec3();\n    let offsetResidPos = origResidPos.add(new Vec3(0.0, 0, 3.0));\n\n    if (t7_addAnim.t > 0.0 && tokColDupe && posColDupe) {\n        let targetPos = offsetResidPos;\n        let tokStartPos = new Vec3(tokColDupe.x, tokColDupe.y, tokColDupe.z);\n        let posStartPos = new Vec3(posColDupe.x, posColDupe.y, posColDupe.z);\n\n        let tokPos = tokStartPos.lerp(targetPos, t7_addAnim.t);\n        let posPos = posStartPos.lerp(targetPos, t7_addAnim.t);\n\n        tokColDupe.x = tokPos.x;\n        tokColDupe.y = tokPos.y;\n        tokColDupe.z = tokPos.z;\n        posColDupe.x = posPos.x;\n        posColDupe.y = posPos.y;\n        posColDupe.z = posPos.z;\n\n        if (t7_addAnim.t > 0.95) {\n            tokColDupe.opacity = 0.0;\n            posColDupe.opacity = 0.0;\n            residCol.opacity = 1.0;\n            residCol.highlight = 0.0;\n            residCol.access!.disable = false;\n            residCol.x = targetPos.x;\n            residCol.y = targetPos.y;\n            residCol.z = targetPos.z;\n        }\n    }\n\n    if (t8_placeAnim.t > 0.0) {\n        let startPos = offsetResidPos;\n        let targetPos = origResidPos;\n        let pos = startPos.lerp(targetPos, t8_placeAnim.t);\n        residCol.x = pos.x;\n        residCol.y = pos.y;\n        residCol.z = pos.z;\n    }\n\n    if (t9_cleanupInstant.t > 0.0 && residCol) {\n        residCol.opacity = 1.0;\n        residCol.highlight = 0.0;\n        residCol.access!.disable = false;\n    }\n\n    if (t11_fillRest.t > 0.0) {\n        layout.residual0.access!.disable = true;\n\n        let prevInfo = startProcessBefore(state, layout.residual0);\n        processUpTo(state, t11_fillRest, layout.residual0, prevInfo);\n    }\n    // new Vec3(-6.9, 0, -36.5), new Vec3(281.5, 5.5, 0.8)\n}\n","import React from \"react\";\nimport { findSubBlocks, splitGrid } from \"../Annotations\";\nimport { drawDataFlow } from \"../components/DataFlow\";\nimport { drawDependences } from \"../Interaction\";\nimport { clamp } from \"@/src/utils/data\";\nimport { lerp } from \"@/src/utils/math\";\nimport { Dim, Vec3 } from \"@/src/utils/vector\";\nimport { Phase } from \"./Walkthrough\";\nimport { processUpTo, startProcessBefore } from \"./Walkthrough00_Intro\";\nimport { commentary, DimStyle, IWalkthroughArgs, moveCameraTo, setInitialCamera } from \"./WalkthroughTools\";\n\nexport function walkthrough03_LayerNorm(args: IWalkthroughArgs) {\n    let { walkthrough: wt, layout, state, tools: { afterTime, c_str, c_blockRef, c_dimRef, breakAfter, cleanup } } = args;\n    let { C } = layout.shape;\n\n    if (wt.phase !== Phase.Input_Detail_LayerNorm) {\n        return;\n    }\n\n    let ln = layout.blocks[0].ln1;\n\n    setInitialCamera(state, new Vec3(-6.680, 0.000, -65.256), new Vec3(281.000, 9.000, 2.576));\n    wt.dimHighlightBlocks = [layout.residual0, ...ln.cubes];\n\n    commentary(wt, null, 0)`\n\nThe  ${c_blockRef('_input embedding_', state.layout.residual0)} matrix from the previous section is the input to our first Transformer block.\n\nThe first step in the Transformer block is to apply _layer normalization_ to this matrix. This is an\noperation that normalizes the values in each column of the matrix separately.`;\n    breakAfter();\n\n    let t_moveCamera = afterTime(null, 1.0);\n    let t_hideExtra = afterTime(null, 1.0, 1.0);\n    let t_moveInputEmbed = afterTime(null, 1.0);\n    let t_moveCameraClose = afterTime(null, 0.5);\n\n    breakAfter();\n    commentary(wt)`\nNormalization is an important step in the training of deep neural networks, and it helps improve the\nstability of the model during training.\n\nWe can regard each column separately, so let's focus on the 4th column (${c_dimRef('t = 3', DimStyle.T)}) for now.`;\n\n    breakAfter();\n    let t_focusColumn = afterTime(null, 0.5);\n\n    // mu ascii: \\u03bc\n    // sigma ascii: \\u03c3\n    breakAfter();\n    commentary(wt)`\nThe goal is to make the average value in the column equal to 0 and the standard deviation equal to 1. To do this,\nwe find both of these quantities (${c_blockRef('mean (\\u03bc)', ln.lnAgg1)} & ${c_blockRef('std dev (\\u03c3)', ln.lnAgg2)}) for the column and then subtract the average and divide by the standard deviation.`;\n\n    breakAfter();\n\n    let t_calcMuAgg = afterTime(null, 0.5);\n    let t_calcVarAgg = afterTime(null, 0.5);\n\n    // 1e-5 as 1x10^-5, but with superscript: 1x10<sup>-5</sup>\n\n    breakAfter();\n    commentary(wt)`\nThe notation we use here is E[x] for the average and Var[x] for the variance (of the column of length ${c_dimRef('C', DimStyle.C)}). The\nvariance is simply the standard deviation squared. The epsilon term (ε = ${<>1&times;10<sup>-5</sup></>}) is there to prevent division by zero.\n\nWe compute and store these values in our aggregation layer since we're applying them to all values in the column.\n\nFinally, once we have the normalized values, we multiply each element in the column by a learned\n${c_blockRef('weight (\\u03b3)', ln.lnSigma)} and then add a ${c_blockRef('bias (β)', ln.lnMu)} value, resulting in our ${c_blockRef('normalized values', ln.lnResid)}.`;\n\n    breakAfter();\n\n    let t_clean_aggs = afterTime(null, 0.2);\n    cleanup(t_clean_aggs, [t_calcMuAgg, t_calcVarAgg]);\n    let t_colSequence = afterTime(null, 2.0);\n\n    breakAfter();\n    commentary(wt)`\nWe run this normalization operation on each column of the ${c_blockRef('input embedding matrix', layout.residual0)}, and the result is\nthe ${c_blockRef('normalized input embedding', ln.lnResid)}, which is ready to be passed into the Self-Attention layer.\n`;\n\n    breakAfter();\n    let t_cleanupSplits = afterTime(null, 0.5);\n    cleanup(t_cleanupSplits, [t_focusColumn]);\n    if (t_cleanupSplits.t > 0) {\n        t_colSequence.t = 0;\n    }\n    let t_runAggFull = afterTime(null, 2.0);\n    let t_runNormFull = afterTime(null, 6.0);\n\n    moveCameraTo(state, t_moveCamera, new Vec3(21.2, 0, -102.9), new Vec3(281.5, 11, 1.7));\n\n    let exampleIdx = 3;\n    let ln1 = layout.blocks[0].ln1;\n    let inputBlock = layout.residual0;\n\n    inputBlock.highlight = lerp(0, 0.3, t_hideExtra.t);\n\n    let relevantBlocks = new Set([\n        layout.residual0,\n        ...ln1.cubes,\n    ]);\n\n    for (let blk of layout.cubes) {\n            if (!relevantBlocks.has(blk)) {\n            blk.opacity = lerp(1.0, 0.0, t_hideExtra.t);\n        }\n    }\n\n    for (let blk of relevantBlocks) {\n        if (blk != layout.residual0 && blk.t !== 'w') {\n            blk.access!.disable = true;\n        }\n    }\n\n    let startResidualY = layout.residual0.y;\n    let endResidulY = ln1.lnResid.y;\n    layout.residual0.y = lerp(startResidualY, endResidulY, t_moveInputEmbed.t);\n\n    if (t_moveInputEmbed.t >= 0.0) {\n        inputBlock.highlight = lerp(0.3, 0.0, t_moveInputEmbed.t);\n    }\n\n    moveCameraTo(state, t_moveCameraClose, new Vec3(-14.1, 0, -187.1), new Vec3(270, 4, 0.7));\n\n    let splitAmt = lerp(0.0, 2.0, t_focusColumn.t);\n    let splitPos = exampleIdx + 0.5;\n\n    let otherColOpacity = lerp(1.0, 0.3, t_focusColumn.t);\n    ln1.lnAgg1.opacity = otherColOpacity;\n    ln1.lnAgg2.opacity = otherColOpacity;\n    ln1.lnResid.opacity = otherColOpacity;\n    inputBlock.opacity = otherColOpacity;\n\n    if (t_focusColumn.t > 0) {\n        let aggMuCol = splitGrid(layout, ln1.lnAgg1, Dim.X, splitPos, splitAmt)!;\n        let aggVarCol = splitGrid(layout, ln1.lnAgg2, Dim.X, splitPos, splitAmt)!;\n        let residCol = splitGrid(layout, ln1.lnResid, Dim.X, splitPos, splitAmt)!;\n        let inputCol = splitGrid(layout, inputBlock, Dim.X, splitPos, splitAmt)!;\n        aggMuCol.opacity = 1.0;\n        aggVarCol.opacity = 1.0;\n        residCol.opacity = 1.0;\n        inputCol.opacity = 1.0;\n\n        let aggDestIdx = new Vec3(exampleIdx, 0, 0);\n        if (t_calcMuAgg.t > 0.0) {\n            let pinIdx = new Vec3(0, 10, 0);\n            drawDependences(state, ln1.lnAgg1, aggDestIdx);\n            drawDataFlow(state, ln1.lnAgg1, aggDestIdx, pinIdx);\n            aggMuCol.access!.disable = false;\n            inputCol.highlight = 0.3;\n        }\n\n        if (t_calcVarAgg.t > 0.0) {\n            let pinIdx = new Vec3(9, 9, 0);\n            drawDependences(state, ln1.lnAgg2, aggDestIdx);\n            drawDataFlow(state, ln1.lnAgg2, aggDestIdx, pinIdx);\n            aggVarCol.access!.disable = false;\n        }\n\n        if (t_colSequence.t > 0.0) {\n            aggMuCol.access!.disable = false;\n            aggVarCol.access!.disable = false;\n\n            let pinIdx = new Vec3(-10, 0, 0);\n\n            let cPos = t_colSequence.t * C;\n            let cIdx = clamp(Math.floor(cPos), 0, C - 1);\n            let destIdx = new Vec3(exampleIdx, cIdx, 0);\n            drawDependences(state, ln1.lnResid, destIdx);\n            drawDataFlow(state, ln1.lnResid, destIdx, pinIdx);\n\n            let targetCell = splitGrid(layout, residCol, Dim.Y, cIdx + 0.5, 0.0)!;\n            targetCell.highlight = 0.3;\n\n            findSubBlocks(residCol, Dim.Y, 0, cIdx).forEach((blk) => {\n                blk.access!.disable = false;\n            });\n        }\n    }\n\n    if (t_runAggFull.t > 0.0) {\n        try {\n            let processInfo = startProcessBefore(state, ln1.lnAgg1);\n            processUpTo(state, t_runAggFull, ln1.lnAgg2, processInfo);\n            processUpTo(state, t_runNormFull, ln1.lnResid, processInfo);\n        } catch (e) {\n            console.log(e);\n        }\n    }\n}\n","import React from 'react';\nimport { DimStyle, dimStyleColor } from '../walkthrough/WalkthroughTools';\nimport { useProgramState } from '../Sidebar';\nimport { IBlkDef } from '../GptModelLayout';\nimport { isNotNil } from '@/src/utils/data';\n\nexport const DimensionText: React.FC<{\n    dim: DimStyle,\n    children?: React.ReactNode,\n    style?: React.CSSProperties,\n}> = ({ dim, style, children }) => {\n    let state = useProgramState();\n\n    function setHover(isHover: boolean) {\n        state.display.dimHover = isHover ? dim : null;\n        state.markDirty();\n    }\n\n    let isHover = state.display.dimHover === dim;\n\n    return <span\n        style={{ ...style,\n            textShadow: isHover ? `0 0 0.5em ${dimStyleColor(dim).toHexColor()}` : undefined\n        }}\n        onMouseEnter={() => setHover(true)}\n        onMouseLeave={() => setHover(false)}\n        >\n            {children}\n        </span>;\n}\n\n\nexport const BlockText: React.FC<{\n    blk: IBlkDef | IBlkDef[],\n    children?: React.ReactNode,\n    style?: React.CSSProperties,\n}> = ({ blk, style, children }) => {\n    let state = useProgramState();\n    let blkArr = Array.isArray(blk) ? blk : [blk];\n    let firstBlk = blkArr[0];\n    let dimStyle = firstBlk.t === 'i' ? DimStyle.Intermediates : firstBlk.t === \"w\" ? DimStyle.Weights : DimStyle.Aggregates;\n    let color = dimStyleColor(dimStyle).toHexColor();\n\n    function setHover(isHover: boolean) {\n        state.display.blkIdxHover = isHover ? blkArr.map(a => a.idx) : null;\n        state.markDirty();\n    }\n\n    let hoverIdxs = state.display.blkIdxHover ?? [state.display.hoverTarget?.mainCube.idx].filter(isNotNil);\n\n    let isHover = hoverIdxs.length > 0 && hoverIdxs.includes(firstBlk.idx);\n\n    return <span\n        style={{\n            color: color,\n            textShadow: isHover ? `0 0 0.5em ${style?.color ?? color}` : undefined,\n            ...style,\n        }}\n        onMouseEnter={() => setHover(true)}\n        onMouseLeave={() => setHover(false)}\n        >\n            {children}\n        </span>;\n}\n","import React from 'react';\nimport { dimProps, duplicateGrid, findSubBlocks, splitGrid, splitGridAll } from \"../Annotations\";\nimport { drawDataFlow, getBlockValueAtIdx } from \"../components/DataFlow\";\nimport { BlkSpecial, getBlkDimensions, IBlkDef, setBlkPosition } from \"../GptModelLayout\";\nimport { drawDependences } from \"../Interaction\";\nimport { IProgramState } from \"../Program\";\nimport { drawText, IFontOpts, measureText } from \"../render/fontRender\";\nimport { clamp, makeArray } from \"@/src/utils/data\";\nimport { lerp, lerpSmoothstep } from \"@/src/utils/math\";\nimport { Mat4f } from \"@/src/utils/matrix\";\nimport { Dim, Vec3, Vec4 } from \"@/src/utils/vector\";\nimport { Phase } from \"./Walkthrough\";\nimport { processUpTo, startProcessBefore } from \"./Walkthrough00_Intro\";\nimport { embedInline } from \"./Walkthrough01_Prelim\";\nimport { Colors, commentary, DimStyle, dimStyleColor, IWalkthroughArgs, moveCameraTo, setInitialCamera } from \"./WalkthroughTools\";\nimport { BlockText } from '../components/CommentaryHelpers';\nimport clsx from 'clsx';\n\nexport function walkthrough04_SelfAttention(args: IWalkthroughArgs) {\n    let { walkthrough: wt, layout, state, tools: { afterTime, c_str, c_blockRef, c_dimRef, breakAfter, cleanup } } = args;\n    let { C, A, nHeads } = layout.shape;\n\n    if (wt.phase !== Phase.Input_Detail_SelfAttention) {\n        return;\n    }\n\n    let block0 = layout.blocks[0];\n    let head2 = block0.heads[2];\n\n    setInitialCamera(state, new Vec3(-125.258, 0.000, -178.805), new Vec3(294.000, 12.800, 2.681));\n    wt.dimHighlightBlocks = [layout.residual0, block0.ln1.lnResid, ...head2.cubes];\n\n    commentary(wt, null, 0)`\nThe self-attention layer is perhaps the heart of the Transformer and of GPT. It's the phase where the\ncolumns in our input embedding matrix \"talk\" to each other. Up until now, and in all other phases,\nthe columns can be regarded independently.\n\nThe self-attention layer is made up of several heads, and we'll focus on one of them for now.`;\n    breakAfter();\n    let t_moveCamera = afterTime(null, 1.0);\n    let t_highlightHeads = afterTime(null, 2.0);\n    let t_moveCamera2 = afterTime(null, 1.0);\n    let t_focusHeads = focusSelfAttentionHeadTimers(args, 3.0);\n\n    breakAfter();\n    commentary(wt)`\nThe first step is to produce three vectors for each of the ${c_dimRef('T', DimStyle.T)} columns from the ${c_blockRef('normalized input embedding matrix', block0.ln1.lnResid)}.\nThese vectors are the Q, K, and V vectors:\n\n${embedInline(<ul>\n    <li>Q: <BlockText blk={head2.qBlock}>Query vector</BlockText></li>\n    <li>K: <BlockText blk={head2.kBlock}>Key vector</BlockText></li>\n    <li>V: <BlockText blk={head2.vBlock}>Value vector</BlockText></li>\n</ul>)}\n\nTo produce one of these vectors, we perform a matrix-vector multiplication with a bias added. Each\noutput cell is some linear combination of the input vector. E.g. for the ${c_blockRef('Q vectors', head2.qBlock)}, this is done with a dot product between\na row of the ${c_blockRef('Q-weight matrix', head2.qWeightBlock)} and a column of the ${c_blockRef('input matrix', block0.ln1.lnResid)}.`;\n    breakAfter();\n\n    let t_focusQCol = afterTime(null, 1.0);\n    let t_qIterColDot = afterTime(null, 3.0);\n\n    breakAfter();\n    commentary(wt)`\nThe dot product operation, which we'll see a lot of, is quite simple: We pair each element from\nthe first vector with the corresponding element from the second vector, multiply the pairs together\nand then add the results up.`;\n    breakAfter();\n\n    let t_moveDotCells = afterTime(null, 2.0, 0.5);\n    let t_dotCellsZoomClose = afterTime(null, 1.0, 0.5);\n    let t_collapseDotCellsA = afterTime(null, 2.0);\n    let t_collapseDotCellsB = afterTime(null, 2.0, 0.5);\n    let t_dotCellsZoomOut = afterTime(null, 1.0, 0.5);\n    let t_addBias = afterTime(null, 2.0, 0.5);\n    let t_moveToDest = afterTime(null, 0.5);\n\n    breakAfter();\n    commentary(wt)`\n\nThis is a general and simple way of ensuring each output element can be influenced by all the\nelements in the input vector (where that influence is determined by the weights). Hence its frequent\nappearance in neural networks.\n\nWe repeat this operation for each output cell in the Q, K, V vectors:`;\n    breakAfter();\n\n    let t_revertFocusCol = afterTime(null, 0.25, 0.5);\n    cleanup(t_revertFocusCol, [t_focusQCol]);\n    let t_processQkv = afterTime(null, 5.0);\n\n    breakAfter();\n    commentary(wt)`\nWhat do we do with our Q (query), K (key), and V (value) vectors? The naming\ngives us a hint: \"key\" and \"value\" are reminiscent of a dictionary in software, with keys mapping to\nvalues. Then \"query\" is what we use to look up the value.\n\n${embedInline(<div className='ml-4'>\n    <div className='mt-1 text-center italic'>Software analogy</div>\n    <div className='text-sm mt-1 mb-1 text-gray-600'>Lookup table:</div>\n    <div className='font-mono'>{'table = { \"key0\": \"value0\", \"key1\": \"value1\", ... }'}</div>\n    <div className='text-sm mt-1 mb-1 text-gray-600'>Query Process:</div>\n    <div className='font-mono'>{'table[\"key1\"] => \"value1\"'}</div>\n</div>)}\n\nIn the case of self-attention, instead of returning a single entry, we return some weighted\ncombination of the entries. To find that weighting, we take a dot product between a Q vector and each\nof the K vectors. We normalize that weighting, before finally using it to multiply with the\ncorresponding V vector, and then adding them all up.\n\n${embedInline((() => {\n    let keyCol = dimStyleColor(DimStyle.Intermediates);\n    let valCol = dimStyleColor(DimStyle.A);\n    let qCol = dimStyleColor(DimStyle.Aggregates);\n\n    return <div className='ml-4'>\n        <div className='mt-1 text-center italic'>Self Attention</div>\n        <div className='text-sm mt-2 mb-1 text-gray-600'>Lookup table:</div>\n        <div className='font-mono flex items-center'>K:\n            <div className='mx-2 my-1'>{makeTextVector(keyCol)}</div>\n            <div className='mx-2 my-1'>{makeTextVector(keyCol)}</div>\n            <div className='mx-2 my-1'>{makeTextVector(keyCol)}</div>\n        </div>\n        <div className='font-mono flex items-center'>V:\n            <div className='mx-2 my-1'>{makeTextVector(valCol)}</div>\n            <div className='mx-2 my-1'>{makeTextVector(valCol)}</div>\n            <div className='mx-2 my-1'>{makeTextVector(valCol)}</div>\n        </div>\n        <div className='text-sm mt-2 mb-1 text-gray-600'>Query Process:</div>\n        <div className='font-mono flex items-center'>\n            <div className='flex items-center'>Q: <div className='mx-2 my-1'>{makeTextVector(qCol)}</div></div>\n        </div>\n        <div className='font-mono flex items-center -ml-2 mt-2'>\n            <div className='flex items-center mx-2'>w0 = <div className='m-1'>{makeTextVector(qCol)}</div>.<div className='m-1'>{makeTextVector(keyCol)}</div></div>\n            <div className='flex items-center mx-2'>w1 = <div className='m-1'>{makeTextVector(qCol)}</div>.<div className='m-1'>{makeTextVector(keyCol)}</div></div>\n            <div className='flex items-center mx-2'>w2 = <div className='m-1'>{makeTextVector(qCol)}</div>.<div className='m-1'>{makeTextVector(keyCol)}</div></div>\n        </div>\n        <div className='font-mono flex items-center my-2'>\n            [w0n, w1n, w2n] =&nbsp;<span className='italic'>normalization</span>([w0, w1, w2])\n        </div>\n        <div className='font-mono flex items-center'>\n            result =\n            w0n * <div className='ml-2 mr-2 my-1'>{makeTextVector(valCol)}</div>&nbsp;+&nbsp;\n            w1n * <div className='ml-2 mr-2 my-1'>{makeTextVector(valCol)}</div>&nbsp;+&nbsp;\n            w2n * <div className='ml-2 mr-2 my-1'>{makeTextVector(valCol)}</div>\n        </div>\n\n    </div>;\n})())}\n\nFor a more concrete example, let's look at the 6th column (${c_dimRef('t = 5', DimStyle.T)}), from which\nwe will query from:`;\n    breakAfter();\n\n    let t_focusQKVCols = afterTime(null, 1.0);\n\n    breakAfter();\n// It would like to find relevant information from other columns and extract their values. The other\n// columns each have a K (key) vector, which represents the information that that column has, and our\n// Q (query) vector is what information is relevant to us.\n    commentary(wt)`\nThe {K, V} entries of our lookup are the 6 columns in the past, and the Q value is the current time.\n\nWe first calculate the dot product between the ${c_blockRef('Q vector', head2.qBlock)} of the current column (${c_dimRef('t = 5', DimStyle.T)}) and the ${c_blockRef('K vectors', head2.kBlock)}\nof each of the those previous columns. These are then stored in the corresponding row (${c_dimRef('t = 5', DimStyle.T)})\nof the ${c_blockRef('attention matrix', head2.attnMtx)}.`;\n    breakAfter();\n\n    let t_processAttnRow = afterTime(null, 3.0);\n\n    breakAfter();\n    commentary(wt)`\nThese dot products are a way of measuring the similarity between the two vectors. If they're very\nsimilar, the dot product will be large. If they're very different, the dot product will be small or\nnegative.\n\nThe idea of only using the query against past keys makes this _causal_ self-attention. That is,\ntokens can't \"see into the future\".\n\nAnother element is that after we take the dot product, we divide by sqrt(${c_dimRef('A', DimStyle.A)}), where\n${c_dimRef('A', DimStyle.A)} is the length of the Q/K/V vectors. This scaling is done to prevent large values from\ndominating the normalization (softmax) in the next step.\n\nWe'll mostly skip over the softmax operation (described later); suffice it to say, each row is normalized to sum\nto 1.`;\n    breakAfter();\n\n    let t_processAttnSmAggRow = afterTime(null, 1.0);\n    let t_processAttnSmRow = afterTime(null, 2.0);\n\n    breakAfter();\n    commentary(wt)`\nFinally, we can produce the output vector for our column (${c_dimRef('t = 5', DimStyle.T)}). We look at the (${c_dimRef('t = 5', DimStyle.T)}) row of the\n${c_blockRef('normalized self-attention matrix', head2.attnMtxSm)} and for each element, multiply the corresponding ${c_blockRef('V vector', head2.vBlock)} of the\nother columns element-wise.`;\n    breakAfter();\n\n    let t_zoomVOutput = afterTime(null, 0.4, 0.5);\n    // multi-step process here, displaying the multiplication of each element of the row with each column of V\n    let t_expandVCols = afterTime(null, 1.0, 0.5);\n    let t_moveAttnVals = afterTime(null, 1.0, 0.5);\n    let t_applyMultiplies = afterTime(null, 1.0, 0.5);\n    let t_applyAdds = afterTime(null, 1.0, 0.5);\n    let t_placeVOutput = afterTime(null, 1.0, 0.5);\n    let t_finalizeVOutput = afterTime(null, 0.5, 0.5);\n\n    breakAfter();\n    commentary(wt)`\nThen we can add these up to produce the output vector. Thus, the output vector will be dominated by\nV vectors from columns that have high scores.\n\nNow we know the process, let's run it for all the columns.`;\n\n    breakAfter();\n\n    let t_processRemainZoom = afterTime(null, 0.5, 0.5);\n    cleanup(t_processRemainZoom, [t_focusQKVCols]);\n    let t_processRemain = afterTime(null, 8.0);\n\n    breakAfter();\n    commentary(wt)`\nAnd that's the process for a head of the self-attention layer. So the main goal of self-attention is\nthat each column wants to find relevant information from other columns and extract their values, and\ndoes so by comparing its _query_ vector to the _keys_ of those other columns. With the added restriction\nthat it can only look in the past.\n`;\n\n// Running this process for all the columns produces our self-attention matrix, which is a square\n// matrix, T x T, and due to the causal nature of the process, is a lower triangular matrix.\n\n    moveCameraTo(state, t_moveCamera, new Vec3(-192.1, 0, -214.8), new Vec3(293.5, 49, 2.3));\n    moveCameraTo(state, t_moveCamera2, new Vec3(-92.7, 0, -219), new Vec3(286, 12.8, 1.4));\n\n\n    if (t_highlightHeads.t > 0.0) {\n        block0.selfAttendLabel.visible = lerp(0, 1, t_highlightHeads.t * 10);\n        let headPos = t_highlightHeads.t * nHeads;\n        let headIdx = clamp(Math.floor(headPos), 0, nHeads - 1);\n        let headFrac = headPos - headIdx;\n\n        let labelOpacity = lerp(0.0, 1.0, headFrac / 0.3); // * lerp(1.0, 0.0, (1.0 - headFrac) / 0.3);\n\n        let head = block0.heads[headIdx];\n        head.headLabel.visible = labelOpacity;\n\n        for (let blk of head.headLabel.cubes) {\n            blk.highlight = labelOpacity * 0.4;\n        }\n    }\n\n    if (t_focusHeads.t0_dissolveHeads.t > 0.0) {\n        let head = block0.heads[2];\n        let t = t_focusHeads.t0_dissolveHeads.t;\n        for (let blk of head.headLabel.cubes) {\n            blk.highlight = lerp(1.0, 0.0, t * 4) * 0.4;\n        }\n        head2.qBlock.access!.disable = true;\n        head2.kBlock.access!.disable = true;\n        head2.vBlock.access!.disable = true;\n    }\n\n    focusSelfAttentionHead(args, t_focusHeads);\n\n    moveCameraTo(state, t_dotCellsZoomClose, new Vec3(-53, 0, -155.5), new Vec3(274.1, 8.5, 0.4));\n    moveCameraTo(state, t_dotCellsZoomOut, new Vec3(-92.7, 0, -219), new Vec3(286, 12.8, 1.4));\n\n    let exampleIdx = 3;\n    if (t_focusQCol.t > 0) {\n        let otherOpacity = lerp(1.0, 0.2, t_focusQCol.t);\n        head2.qBlock.opacity = otherOpacity;\n        head2.kBlock.opacity = otherOpacity;\n        head2.vBlock.opacity = otherOpacity;\n        block0.ln1.lnResid.opacity = otherOpacity;\n\n        let splitAmt = lerp(0.0, 2.0, t_focusQCol.t);\n        let qCol = splitGrid(layout, head2.qBlock, Dim.X, exampleIdx + 0.5, splitAmt)!;\n        let inputCol = splitGrid(layout, block0.ln1.lnResid, Dim.X, exampleIdx + 0.5, splitAmt)!;\n\n        qCol.opacity = 1.0;\n        inputCol.opacity = 1.0;\n\n        if (t_qIterColDot.t > 0) {\n            let aPos = t_qIterColDot.t * A;\n            let aIdx = clamp(Math.floor(aPos), 0, A - 1);\n            let destIdx = new Vec3(exampleIdx, aIdx, 0);\n            let pinIdx = new Vec3(exampleIdx, 0, 0);\n\n            drawDependences(state, head2.qBlock, destIdx);\n            drawDataFlow(state, head2.qBlock, destIdx, pinIdx);\n            splitGrid(layout, qCol, Dim.Y, aIdx + 0.5, 0);\n            for (let b of findSubBlocks(qCol, Dim.Y, null, aIdx)) {\n                b.access!.disable = false;\n            }\n            inputCol.highlight = 0.3;\n        }\n\n        let targetTop = new Vec3(inputCol.x - 26, inputCol.y, inputCol.z + 5);\n        let addTarget = new Vec3(targetTop.x + layout.cell, targetTop.y - layout.cell * 12, targetTop.z);\n        let biasTarget = new Vec3(addTarget.x - layout.cell * 3, addTarget.y, addTarget.z);\n\n        if (t_moveDotCells.t > 0 && t_moveToDest.t === 0.0) {\n            let qWeightRow = findSubBlocks(head2.qWeightBlock, Dim.Y, A - 1, null)[0];\n\n            let qCells = splitGridAll(layout, qWeightRow, Dim.X);\n            let inCells = splitGridAll(layout, inputCol, Dim.Y);\n\n            let cellMovePct = 0.5;\n            let prevCY = 0;\n            for (let c = 0; c < C; c++) {\n                let cPos = c / (C - 1);\n                let startT = (1.0 - cellMovePct) * (1.0 - cPos);\n                let cellMoveT = inverseLerp(startT, startT + cellMovePct, t_moveDotCells.t);\n\n                let qInitial = getBlkDimensions(qCells[c]);\n                let qFinal = targetTop.add(new Vec3(0, c * layout.cell * 1.2));\n\n                let inInitial = getBlkDimensions(inCells[c]);\n                let inFinal = targetTop.add(new Vec3(layout.cell * 2, c * layout.cell * 1.2));\n\n                if (t_dotCellsZoomOut.t > 0) {\n                    qFinal = inFinal = new Vec3(targetTop.x + layout.cell, targetTop.y - layout.cell * 12, qFinal.z);\n                }\n\n                // animate the cells from the initial grid position to be lined up next to each other\n                setBlkPosition(qCells[c], qInitial.tl.lerp(qFinal, cellMoveT));\n                setBlkPosition(inCells[c], inInitial.tl.lerp(inFinal, cellMoveT));\n\n                let transitionPt = 0.15;\n                let collapsDotCellsT = lerp(0.0, transitionPt, t_collapseDotCellsA.t) + lerp(0, 1-transitionPt, t_collapseDotCellsB.t);\n\n                let startT2 = 0.9 * cPos;\n                let cellTimesSymT = inverseLerp(startT2, startT2 + 0.1, collapsDotCellsT);\n\n                // move the cells together in the times/add operation, with them ending up in the same place\n                if (cellTimesSymT > 0.0 && t_dotCellsZoomOut.t == 0.0) {\n                    let qCurr = getBlkDimensions(qCells[c]);\n                    let inCurr = getBlkDimensions(inCells[c]);\n\n                    let qCellPos = new Vec3(\n                        lerp(qCurr.tl.x, addTarget.x, cellTimesSymT * 2.0),\n                        lerp(qCurr.tl.y, addTarget.y, cellTimesSymT),\n                        qCurr.tl.z\n                    );\n                    let inCellPos = new Vec3(\n                        lerp(inCurr.tl.x, addTarget.x, cellTimesSymT * 2.0),\n                        lerp(inCurr.tl.y, addTarget.y, cellTimesSymT),\n                        qCurr.tl.z\n                    );\n\n                    setBlkPosition(qCells[c], qCellPos);\n                    setBlkPosition(inCells[c], inCellPos);\n\n                    if (c > 0 && cellTimesSymT > 0.0) {\n\n                        let midPt = new Vec3(\n                            lerp(qCurr.br.x, inCurr.tl.x, 0.5),\n                            lerp(prevCY, qCellPos.y, 0.5),\n                            qCurr.tl.z + layout.cell/2);\n\n                        let mtx = Mat4f.fromTranslation(midPt);\n                        let fontOpts: IFontOpts = { color: Colors.Black, size: 1.5, mtx };\n                        let w = measureText(state.render.modelFontBuf, \"+\", fontOpts);\n                        drawText(state.render.modelFontBuf, \"+\", -w/2, -fontOpts.size/2, fontOpts);\n                    }\n                    prevCY = qCellPos.y + layout.cell;\n                }\n\n                // draw times symbol between blocks (provided they're next to each other)\n                // done after the other operations so that they are always positioned correctly\n                if (cellMoveT >= 1.0) {\n                    drawSymbolBetweenBlocks(args, qCells[c], inCells[c], Dim.X, \"x\", { size: 1.5, color: Colors.Black });\n                }\n            }\n\n            // move the bias block next to the resulting dotprod cell, draw a plus between them, and then join them together\n            if (t_addBias.t >= 0.0) {\n                let qBiasCell = findSubBlocks(head2.qBiasBlock, Dim.Y, A - 1, null)[0];\n\n                let qBiasInitial = getBlkDimensions(qBiasCell);\n                let qBiasPos = qBiasInitial.tl.lerp(biasTarget, inverseLerp(0, 0.4, t_addBias.t));\n                setBlkPosition(qBiasCell, qBiasPos);\n\n                let moveTogetherT = inverseLerp(0.6, 1.0, t_addBias.t);\n                qBiasInitial = getBlkDimensions(qBiasCell);\n                qBiasPos = qBiasInitial.tl.lerp(addTarget, moveTogetherT);\n                setBlkPosition(qBiasCell, qBiasPos);\n\n                if (t_addBias.t > 0.4) {\n                    drawSymbolBetweenBlocks(args, qBiasCell, qCells[qCells.length - 1], Dim.X, \"+\", { size: 1.5, color: Colors.Black });\n                }\n            }\n        }\n\n        // move the resulting dotprod cell to the final destination\n        if (t_moveToDest.t > 0) {\n            let qWeightRow = findSubBlocks(head2.qWeightBlock, Dim.Y, A - 1, null)[0];\n            let qBiasCell = findSubBlocks(head2.qBiasBlock, Dim.Y, A - 1, null)[0];\n            qBiasCell.opacity = t_moveToDest.t;\n            qWeightRow.opacity = t_moveToDest.t;\n            inputCol.opacity = t_moveToDest.t;\n\n            let qResultCell = findSubBlocks(qCol, Dim.Y, A - 1, null)[0];\n            let qResultInitial = getBlkDimensions(qResultCell);\n            let qResultPos = qResultInitial.tl.lerp(addTarget, 1.0 - t_moveToDest.t);\n\n            setBlkPosition(qResultCell, qResultPos);\n        }\n    }\n\n    // simple run-through and process of each of the Q, K, V blocks\n    if (t_processQkv.t > 0) {\n        let processStart = startProcessBefore(state, head2.qBlock);\n        processUpTo(state, t_processQkv, head2.vBlock, processStart);\n    }\n\n    // highlight the example index column for the Q block, and previous columns for K and V\n    let attnExampleIdx = 5;\n    if (t_focusQKVCols.t > 0 && t_processRemain.t <= 0) {\n        let ignoreOpacity = lerp(1.0, 0.2, t_focusQKVCols.t);\n        head2.qBlock.opacity = ignoreOpacity;\n        head2.kBlock.opacity = ignoreOpacity;\n        head2.vBlock.opacity = ignoreOpacity;\n\n        let qCol = splitGrid(layout, head2.qBlock, Dim.X, attnExampleIdx + 0.5, 0)!;\n        splitGrid(layout, head2.kBlock, Dim.X, attnExampleIdx + 0.5, 0)!;\n        splitGrid(layout, head2.vBlock, Dim.X, attnExampleIdx + 0.5, 0)!;\n\n        let kBeforeCols = findSubBlocks(head2.kBlock, Dim.X, null, attnExampleIdx);\n        let vBeforeCols = findSubBlocks(head2.vBlock, Dim.X, null, attnExampleIdx);\n\n        for (let col of [...kBeforeCols, ...vBeforeCols, qCol]) {\n            col.opacity = 1.0;\n        }\n\n        head2.attnMtx.access!.disable = true;\n        head2.attnMtxSm.access!.disable = true;\n        head2.attnMtxAgg1.access!.disable = true;\n        head2.attnMtxAgg2.access!.disable = true;\n\n        head2.qBlock.opacity = 1.0;\n        head2.kBlock.opacity = 1.0;\n        head2.vBlock.opacity = 1.0;\n    }\n\n    moveCameraTo(state, t_focusQKVCols, new Vec3(-91.5, 0, -227.9), new Vec3(270.1, -38.4, 0.8));\n\n    if (t_processAttnRow.t > 0 && t_processRemain.t <= 0) {\n        let aIdx = clamp(Math.floor(t_processAttnRow.t * (attnExampleIdx + 1)), 0, attnExampleIdx);\n        let destIdx = new Vec3(aIdx, attnExampleIdx, 0);\n        let pinIdx = new Vec3(attnExampleIdx, 0, 0);\n\n        if (t_processAttnSmAggRow.t <= 0) {\n            drawDependences(state, head2.attnMtx, destIdx);\n            drawDataFlow(state, head2.attnMtx, destIdx, pinIdx);\n        }\n\n        let attnRow = splitGrid(layout, head2.attnMtx, Dim.Y, attnExampleIdx, 0)!;\n        splitGrid(layout, attnRow, Dim.X, aIdx, 0)!;\n        let attnRowStart = findSubBlocks(attnRow, Dim.X, null, aIdx);\n\n        for (let blk of attnRowStart) {\n            blk.access!.disable = false;\n        }\n    }\n\n    if (t_processAttnSmAggRow.t > 0 && t_processRemain.t <= 0) {\n        let agg0T = inverseLerp(0, 0.5, t_processAttnSmAggRow.t);\n        let agg1T = inverseLerp(0.5, 1.0, t_processAttnSmAggRow.t);\n        let hidePopup = t_processAttnSmRow.t > 0;\n        processDim(state, head2.attnMtxAgg2, Dim.Y, attnExampleIdx, agg0T, { pinIdx: new Vec3(5, 0, 0), clamp: true, hidePopup });\n\n        if (agg1T > 0) {\n            processDim(state, head2.attnMtxAgg1, Dim.Y, attnExampleIdx, agg1T, { pinIdx: new Vec3(-12, 0, 0), clamp: true, hidePopup });\n        }\n    }\n\n    if (t_processAttnSmRow.t > 0 && t_processRemain.t <= 0) {\n        let hidePopup = t_zoomVOutput.t > 0;\n        processDim(state, head2.attnMtxSm, Dim.Y, attnExampleIdx, t_processAttnSmRow.t, { pinIdx: new Vec3(5, 0, 0), clamp: true, maxIdx: attnExampleIdx + 1, hidePopup });\n    }\n\n    if (t_zoomVOutput.t > 0 && t_processRemain.t <= 0) {\n        head2.vOutBlock.access!.disable = true;\n    }\n\n    // Do the attn_sm times V vectors to get the output vectors animation\n    {\n        moveCameraTo(state, t_zoomVOutput, new Vec3(-91.9, 0, -267.9), new Vec3(270.1, -7.5, 0.7));\n\n        let topLeftPos = getBlkDimensions(head2.vBlock).tl.add(new Vec3(0, 4, 5));\n        let midLeftPos = topLeftPos.add(new Vec3(0, layout.cell * (A / 2 - 0.5)));\n\n        if (t_expandVCols.t > 0 && t_placeVOutput.t <= 0) {\n            let allVCols = [];\n            let vBeforeCols = findSubBlocks(head2.vBlock, Dim.X, null, attnExampleIdx);\n            for (let col of vBeforeCols) {\n                allVCols.push(...splitGridAll(layout, col, Dim.X));\n            }\n\n            let allAttnCells = [];\n            let attnRow = findSubBlocks(head2.attnMtxSm, Dim.Y, attnExampleIdx, attnExampleIdx)[0];\n            let attnCellsBefore = findSubBlocks(attnRow, Dim.X, null, attnExampleIdx);\n            for (let cell of attnCellsBefore) {\n                for (let subCell of splitGridAll(layout, cell, Dim.X)) {\n                    allAttnCells.push(duplicateGrid(layout, subCell));\n                }\n            }\n\n            for (let i = 0; i < attnExampleIdx + 1; i++) {\n                let attnVal = getBlockValueAtIdx(head2.attnMtxSm, new Vec3(i, attnExampleIdx, 0)) ?? 0.2;\n\n                let initColPos = getBlkDimensions(allVCols[i]).tl;\n                let destColPos = topLeftPos.add(new Vec3(i * layout.cell * 5, 0, 0));\n\n                setBlkPosition(allVCols[i], initColPos.lerp(destColPos, t_expandVCols.t));\n\n                let initAttnPos = getBlkDimensions(allAttnCells[i]).tl;\n                let destAttnPos = midLeftPos.add(new Vec3(i * layout.cell * 5 - 2 * layout.cell, 0));\n\n                setBlkPosition(allAttnCells[i], initAttnPos.lerp(destAttnPos, t_moveAttnVals.t));\n\n                if (t_applyMultiplies.t > 0) {\n                    initAttnPos = destAttnPos;\n                    destAttnPos = initAttnPos.add(new Vec3(layout.cell * 2, 0));\n                    setBlkPosition(allAttnCells[i], initAttnPos.lerp(destAttnPos, t_applyMultiplies.t));\n\n                    allAttnCells[i].opacity = 1.0 - t_applyMultiplies.t;\n                    allVCols[i].highlight = lerp(0.0, attnVal * 1.5, t_applyMultiplies.t);\n                }\n\n                if (t_moveAttnVals.t > 0.8 && t_applyMultiplies.t < 0.7) {\n                    drawSymbolBetweenBlocks(args, allVCols[i], allAttnCells[i], Dim.X, 'x', { color: Colors.Black, size: 1.5 });\n                }\n\n                if (t_applyAdds.t > 0) {\n                    initColPos = destColPos;\n                    destColPos = topLeftPos.add(new Vec3(0, 0, attnVal * 1.0));\n\n                    setBlkPosition(allVCols[i], initColPos.lerp(destColPos, t_applyAdds.t));\n                }\n\n                if (t_applyMultiplies.t > 0.6 && i > 0 && t_applyAdds.t < 0.7) {\n                    drawSymbolBetweenBlocks(args, allVCols[i - 1], allVCols[i], Dim.X, '+', { color: Colors.Black, size: 1.5 });\n                }\n            }\n        }\n\n        if (t_placeVOutput.t > 0 && t_finalizeVOutput.t <= 0) {\n            let prepareT = inverseLerp(0, 0.5, t_placeVOutput.t);\n\n            let vOutCol = splitGrid(layout, head2.vOutBlock, Dim.X, attnExampleIdx + 0.5, prepareT * 2.0)!;\n            vOutCol.access!.disable = true;\n            vOutCol.opacity = lerp(1.0, 0.0, prepareT);\n\n            for (let col of findSubBlocks(head2.vBlock, Dim.X, null, attnExampleIdx)) {\n                col.opacity = t_placeVOutput.t;\n            }\n\n            let vOutColDupe = duplicateGrid(layout, vOutCol);\n            vOutColDupe.access!.disable = false;\n            vOutColDupe.opacity = 1.0;\n\n            let colInitialPos = topLeftPos;\n            let colFinalPos = getBlkDimensions(vOutCol).tl;\n\n            setBlkPosition(vOutColDupe, colInitialPos.lerp(colFinalPos, t_placeVOutput.t));\n        }\n\n        if (t_finalizeVOutput.t > 0) {\n            let splitAmt = lerp(1.0, 0.0, t_finalizeVOutput.t) * 2.0;\n            let vOutCol = splitGrid(layout, head2.vOutBlock, Dim.X, attnExampleIdx + 0.5, splitAmt)!;\n            vOutCol.access!.disable = false;\n        }\n    }\n\n    moveCameraTo(state, t_processRemainZoom, new Vec3(-99.7, 0, -230.1), new Vec3(275.6, -4.4, 1.2));\n\n    if (t_processRemain.t > 0) {\n        for (let blk of [head2.attnMtx, head2.attnMtxSm, head2.attnMtxAgg1, head2.attnMtxAgg2, head2.vOutBlock]) {\n            blk.access!.disable = true;\n        }\n\n        let processStart = startProcessBefore(state, head2.attnMtx);\n        processUpTo(state, t_processRemain, head2.vOutBlock, processStart);\n    }\n\n    // if (t_processAllAttn.t > 0) {\n    //     let processStart = startProcessBefore(state, head2.attnMtx);\n    //     processUpTo(state, t_processAllAttn, head2.attnMtx, processStart);\n    // }\n\n}\n\n// when t < edge0, returns 0\n// when t > edge1, returns 1\n// when t is between edge0 and edge1, returns a value between 0 and 1\n// note that edge1 must be greater than edge0\nexport function inverseLerp(edge0: number, edge1: number, t: number) {\n    return (clamp(t, edge0, edge1) - edge0) / (edge1 - edge0);\n}\n\nexport interface IProcessDimOpts {\n    pinIdx?: Vec3;\n    clamp?: boolean;\n    maxIdx?: number;\n    hidePopup?: boolean;\n}\n\nexport function processDim(state: IProgramState, block: IBlkDef, dim: Dim, destIdx: number, t: number, options: IProcessDimOpts = {}) {\n    let { layout } = state;\n    let { pinIdx, clamp: keep, maxIdx, hidePopup } = options;\n    let otherDim = dim === Dim.X ? Dim.Y : Dim.X;\n\n    let { cx: cxOther } = dimProps(block, otherDim);\n\n    pinIdx ||= new Vec3(0, 0, 0);\n\n    let rowCol = splitGrid(layout, block, dim, destIdx, 0);\n\n    if (!rowCol) {\n        return;\n    }\n\n    let maxPos = maxIdx ?? cxOther; // for attn matrix, reduce to the row number\n    let cellPos = t * maxPos;\n\n    if (keep) {\n        cellPos = clamp(cellPos, 0, maxPos - 1);\n    }\n\n    let cellIdx = Math.floor(cellPos);\n\n    if (cellIdx >= maxPos) {\n        return;\n    }\n\n    splitGrid(layout, rowCol, otherDim, cellIdx + 0.5, 0);\n\n    // cell!.highlight = 0.2;\n    let destIdxVec = new Vec3(0, 0, 0);\n    destIdxVec.setAt(dim, destIdx);\n    destIdxVec.setAt(otherDim, cellIdx);\n\n    if (rowCol && !hidePopup) {\n        drawDependences(state, block, destIdxVec);\n        drawDataFlow(state, block, destIdxVec, pinIdx);\n    }\n\n    for (let blk of findSubBlocks(rowCol, otherDim, null, cellIdx)) {\n        blk.access!.disable = false;\n    }\n}\n\nexport function focusSelfAttentionHeadTimers(args: IWalkthroughArgs, duration: number) {\n    let afterTime = args.tools.afterTime;\n\n    let totalTime = 1.5 * 2;\n    let timeScale = duration / totalTime;\n\n    let t0_dissolveHeads = afterTime(null, 1 * timeScale, 0.5 * timeScale);\n    let t2_alignqkv = afterTime(null, 1.0 * timeScale, 0.5 * timeScale);\n\n    return { t0_dissolveHeads, t2_alignqkv };\n}\n\nexport function focusSelfAttentionHead(args: IWalkthroughArgs, timers: ReturnType<typeof focusSelfAttentionHeadTimers>) {\n    let { layout } = args;\n    let { t0_dissolveHeads, t2_alignqkv } = timers;\n\n    let targetHeadIdx = 2;\n    let targetHead = layout.blocks[0].heads[targetHeadIdx];\n\n    let block = layout.blocks[0];\n    {\n        for (let headIdx = 0; headIdx < block.heads.length; headIdx++) {\n            if (headIdx == targetHeadIdx) {\n                continue;\n            }\n            for (let cube of block.heads[headIdx].cubes) {\n                cube.opacity = lerpSmoothstep(1.0, 0.0, t0_dissolveHeads.t);\n            }\n        }\n    }\n\n    {\n        let headZ = targetHead.attnMtx.z;\n        let targetHeadZ = block.ln1.lnResid.z;\n        let deltaZ = lerpSmoothstep(0, (targetHeadZ - headZ), t2_alignqkv.t);\n        for (let cube of targetHead.cubes) {\n            cube.z += deltaZ;\n        }\n    }\n\n    {\n        let qkv = [\n            [targetHead.qBlock, targetHead.qWeightBlock, targetHead.qBiasBlock],\n            [targetHead.kBlock, targetHead.kWeightBlock, targetHead.kBiasBlock],\n            [targetHead.vBlock, targetHead.vWeightBlock, targetHead.vBiasBlock],\n        ];\n        let targetZ = block.ln1.lnResid.z;\n        let strideY = targetHead.qBlock.dy + layout.margin;\n        let baseY = targetHead.qBlock.y;\n        let qkvYPos = [-strideY * 2, -strideY, 0];\n\n        for (let i = 0; i < 3; i++) {\n            let y = lerpSmoothstep(qkv[i][0].y, baseY + qkvYPos[i], t2_alignqkv.t);\n            let z = lerpSmoothstep(qkv[i][0].z, targetZ, t2_alignqkv.t);\n            for (let cube of qkv[i]) {\n                cube.y = y;\n                cube.z = z;\n            }\n        }\n\n        let blockMidY = (blk: IBlkDef) => blk.y + blk.dy / 2;\n\n        let resid0Idx = layout.cubes.indexOf(block.ln1.lnResid);\n        let yDelta = lerpSmoothstep(0, blockMidY(block.ln1.lnResid) - blockMidY(targetHead.kBlock), t2_alignqkv.t);\n\n        for (let i = 0; i < resid0Idx; i++) {\n            let targetOpacity = 0.2;\n            layout.cubes[i].opacity = lerpSmoothstep(1.0, targetOpacity, t2_alignqkv.t);\n        }\n\n        let afterAttn = false;\n        for (let i = resid0Idx + 1; i < layout.cubes.length; i++) {\n            let cube = layout.cubes[i];\n            cube.y += yDelta;\n            if (afterAttn) {\n                cube.opacity = Math.min(lerpSmoothstep(1.0, 0.2, t2_alignqkv.t), cube.opacity ?? 1.0);\n            }\n            afterAttn = afterAttn || cube === targetHead.vOutBlock;\n        }\n    }\n\n}\n\nexport function drawSymbolBetweenBlocks(args: IWalkthroughArgs, block1: IBlkDef, block2: IBlkDef, dim: Dim, symbol: string, opts: { color: Vec4, size: number }) {\n    let { color, size } = opts;\n\n    let block1Dim = getBlkDimensions(block1);\n    let block2Dim = getBlkDimensions(block2);\n\n    let midPt: Vec3;\n\n    if (dim === Dim.X) {\n        midPt = new Vec3(\n            lerp(block1Dim.br.x, block2Dim.tl.x, 0.5),\n            (block1Dim.tl.y + block1Dim.br.y + block2Dim.tl.y + block2Dim.br.y) * 0.25,\n            block1Dim.tl.z + args.layout.cell / 2)\n    } else {\n        midPt = new Vec3(\n            (block1Dim.tl.x + block1Dim.br.x + block2Dim.tl.x + block2Dim.br.x) * 0.25,\n            lerp(block1Dim.br.y, block2Dim.tl.y, 0.5),\n            block1Dim.tl.z + args.layout.cell / 2);\n    }\n\n    let mtx = Mat4f.fromTranslation(midPt);\n    let fontOpts: IFontOpts = { color, size, mtx };\n    let w = measureText(args.state.render.modelFontBuf, symbol, fontOpts);\n    drawText(args.state.render.modelFontBuf, symbol, -w/2, -fontOpts.size/2, fontOpts);\n}\n\nfunction makeTextVector(col: Vec4, count: number = 3) {\n    let bgColor = new Vec4(col.x, col.y, col.z, 0.5);\n    return <div className='flex flex-col pb-[2px]'>\n        {makeArray(3, 0).map((_, i) => {\n            return <div key={i} className={\"w-3 h-3 border-2 mb-[-2px]\"} style={{ borderColor: col.toHexColor(), backgroundColor: bgColor.toHexColor() }} />;\n        })}\n    </div>;\n}\n","import { Vec3 } from \"@/src/utils/vector\";\nimport { Phase } from \"./Walkthrough\";\nimport { commentary, IWalkthroughArgs, setInitialCamera } from \"./WalkthroughTools\";\n\nexport function walkthrough05_Softmax(args: IWalkthroughArgs) {\n    let { walkthrough: wt, state } = args;\n\n    if (wt.phase !== Phase.Input_Detail_Softmax) {\n        return;\n    }\n\n    setInitialCamera(state, new Vec3(-24.350, 0.000, -1702.195), new Vec3(283.100, 0.600, 1.556));\n\n    let c0 = commentary(wt, null, 0)`\n\nThe softmax operation is used as part of self-attention, as seen in the previous section, and it\nwill also appear at the very end of the model.\n\nIts goal is to take a vector and normalize its values so that they sum to 1.0. However, it's not as\nsimple as dividing by the sum. Instead, each input value is first exponentiated.\n\n  a = exp(x_1)\n\nThis has the effect of making all values positive. Once we have a vector of our exponentiated\nvalues, we can then divide each value by the sum of all the values. This will ensure that the sum\nof the values is 1.0. Since all the exponentiated values are positive, we know that the resulting\nvalues will be between 0.0 and 1.0, which provides a probability distribution over the original values.\n\nThat's it for softmax: simply exponentiate the values and then divide by the sum.\n\nHowever, there's a slight complication. If any of the input values are quite large, then the\nexponentiated values will be very large. We'll end up dividing a large number by a very large number,\nand this can cause issues with floating-point arithmetic.\n\nOne useful property of the softmax operation is that if we add a constant to all the input values,\nthe result will be the same. So we can find the largest value in the input vector and subtract it\nfrom all the values. This ensures that the largest value is 0.0, and the softmax remains numerically\nstable.\n\nLet's take a look at the softmax operation in the context of the self-attention layer. Our input\nvector for each softmax operation is a row of the self-attention matrix (but only up to the diagonal).\n\nLike with layer normalization, we have an intermediate step where we store some aggregation values\nto keep the process efficient.\n\nFor each row, we store the max value in the row and the sum of the shifted & exponentiated values.\nThen, to produce the corresponding output row, we can perform a small set of operations: subtract the\nmax, exponentiate, and divide by the sum.\n\nWhat's with the name \"softmax\"? The \"hard\" version of this operation, called argmax, simply finds\nthe maximum value, sets it to 1.0, and assigns 0.0 to all other values. In contrast, the softmax\noperation serves as a \"softer\" version of that. Due to the exponentiation involved in softmax, the\nlargest value is emphasized and pushed towards 1.0, while still maintaining a probability distribution\nover all input values. This allows for a more nuanced representation that captures not only the most\nlikely option but also the relative likelihood of other options.\n`;\n\n}\n","import { Vec3 } from \"@/src/utils/vector\";\nimport { Phase } from \"./Walkthrough\";\nimport { commentary, DimStyle, IWalkthroughArgs, moveCameraTo, setInitialCamera } from \"./WalkthroughTools\";\nimport { lerp, lerpSmoothstep } from \"@/src/utils/math\";\nimport { processUpTo, startProcessBefore } from \"./Walkthrough00_Intro\";\n\nexport function walkthrough06_Projection(args: IWalkthroughArgs) {\n    let { walkthrough: wt, state, layout, tools: { breakAfter, afterTime, c_blockRef, c_dimRef, cleanup } } = args;\n\n    if (wt.phase !== Phase.Input_Detail_Projection) {\n        return;\n    }\n\n    setInitialCamera(state, new Vec3(-73.167, 0.000, -270.725), new Vec3(293.606, 2.613, 1.366));\n    let block = layout.blocks[0];\n    wt.dimHighlightBlocks = [...block.heads.map(h => h.vOutBlock), block.projBias, block.projWeight, block.attnOut];\n\n    let outBlocks = block.heads.map(h => h.vOutBlock);\n\n    commentary(wt, null, 0)`\n\nAfter the self-attention process, we have outputs from each of the heads. These outputs are the\nappropriately mixed V vectors, influenced by the Q and K vectors.\n\nTo combine the ${c_blockRef('output vectors', outBlocks)} from each head, we simply stack them on top of each other. So, for time\n${c_dimRef('t = 4', DimStyle.T)}, we go from 3 vectors of length ${c_dimRef('A = 16', DimStyle.A)} to 1 vector of length ${c_dimRef('C = 48', DimStyle.C)}.`;\n\n    breakAfter();\n\n    let t_fadeOut = afterTime(null, 1.0, 0.5);\n    // let t_zoomToStack = afterTime(null, 1.0);\n    let t_stack = afterTime(null, 1.0);\n\n    breakAfter();\n\n    commentary(wt)`\n\nIt's worth noting that in GPT, the length of the vectors within a head (${c_dimRef('A = 16', DimStyle.A)}) is equal to ${c_dimRef('C', DimStyle.C)} / num_heads.\nThis ensures that when we stack them back together, we get the original length, ${c_dimRef('C', DimStyle.C)}.\n\nFrom here, we perform the projection to get the output of the layer. This is a simple matrix-vector\nmultiplication on a per-column basis, with a bias added.`;\n\n    breakAfter();\n\n    let t_process = afterTime(null, 3.0);\n\n    breakAfter();\n\n    commentary(wt)`\n\nNow we have the output of the self-attention layer. Instead of passing this output directly to the\nnext phase, we add it element-wise to the input embedding. This process, denoted by the green\nvertical arrow, is called the _residual connection_ or _residual pathway_.\n`;\n\n    breakAfter();\n\n    let t_zoomOut = afterTime(null, 1.0, 0.5);\n    let t_processResid = afterTime(null, 3.0);\n\n    cleanup(t_zoomOut, [t_fadeOut, t_stack]);\n\n    breakAfter();\n\n    commentary(wt)`\n\nLike layer normalization, the residual pathway is important for enabling effective learning in deep\nneural networks.\n\nNow with the result of self-attention in hand, we can pass it onto the next section of the transformer:\nthe feed-forward network.\n`;\n\n    breakAfter();\n\n    if (t_fadeOut.active) {\n        for (let head of block.heads) {\n            for (let blk of head.cubes) {\n                if (blk !== head.vOutBlock) {\n                    blk.opacity = lerpSmoothstep(1, 0, t_fadeOut.t);\n                }\n            }\n        }\n    }\n\n    if (t_stack.active) {\n        let targetZ = block.attnOut.z;\n        for (let headIdx = 0; headIdx < block.heads.length; headIdx++) {\n            let head = block.heads[headIdx];\n            let targetY = head.vOutBlock.y + head.vOutBlock.dy * (headIdx - block.heads.length + 1);\n            head.vOutBlock.y = lerp(head.vOutBlock.y, targetY, t_stack.t);\n            head.vOutBlock.z = lerp(head.vOutBlock.z, targetZ, t_stack.t);\n        }\n    }\n\n    let processInfo = startProcessBefore(state, block.attnOut);\n\n    if (t_process.active) {\n        processUpTo(state, t_process, block.attnOut, processInfo);\n    }\n\n    moveCameraTo(state, t_zoomOut, new Vec3(-8.304, 0.000, -175.482), new Vec3(293.606, 2.623, 2.618));\n\n    if (t_processResid.active) {\n        processUpTo(state, t_processResid, block.attnResidual, processInfo);\n    }\n}\n","import React from \"react\";\nimport { Dim, Vec3 } from \"@/src/utils/vector\";\nimport { Phase } from \"./Walkthrough\";\nimport { commentary, DimStyle, dimStyleColor, IWalkthroughArgs, setInitialCamera } from \"./WalkthroughTools\";\nimport { dimProps, findSubBlocks, splitGrid } from \"../Annotations\";\nimport { lerp } from \"@/src/utils/math\";\nimport { IBlkDef, getBlkDimensions } from \"../GptModelLayout\";\nimport { processUpTo, startProcessBefore } from \"./Walkthrough00_Intro\";\nimport { drawDataFlow } from \"../components/DataFlow\";\nimport { drawDependences } from \"../Interaction\";\nimport { makeArray, makeArrayRange } from \"@/src/utils/data\";\n\nexport function walkthrough07_Mlp(args: IWalkthroughArgs) {\n    let { walkthrough: wt, state, layout, tools: { afterTime, c_blockRef, c_dimRef, breakAfter, cleanup } } = args;\n\n    if (wt.phase !== Phase.Input_Detail_Mlp) {\n        return;\n    }\n\n    let block = layout.blocks[0];\n\n    setInitialCamera(state, new Vec3(-154.755, 0.000, -460.042), new Vec3(289.100, -8.900, 2.298));\n    wt.dimHighlightBlocks = [block.ln2.lnResid, block.mlpAct, block.mlpFc, block.mlpFcBias, block.mlpFcWeight, block.mlpProjBias, block.mlpProjWeight, block.mlpResult, block.mlpResidual];\n\n    commentary(wt)`\n\nThe next half of the transformer block, after the self-attention, is the MLP (multi-layer\nperceptron). A bit of a mouthful, but here it's a simple neural network with two layers.\n\nLike with self-attention, we perform a ${c_blockRef('layer normalization', block.ln2.lnResid)} before the vectors enter the MLP.\n\nIn the MLP, we put each of our ${c_dimRef('C = 48', DimStyle.C)} length column vectors (independently) through:\n\n1. A ${c_blockRef('linear transformation', block.mlpFcWeight)} with a ${c_blockRef('bias', block.mlpFcBias)} added, to a vector of length ${c_dimRef('4 * C', DimStyle.C4)}.\n\n2. A GELU activation function (element-wise)\n\n3. A ${c_blockRef('linear transformation', block.mlpProjWeight)} with a ${c_blockRef('bias', block.mlpProjBias)} added, back to a vector of length ${c_dimRef('C', DimStyle.C)}\n\nLet's track one of those vectors:\n`;\n    breakAfter();\n\n    let t0_fadeOut = afterTime(null, 1.0);\n\n    breakAfter();\n\ncommentary(wt)`\nWe first run through the matrix-vector multiplication with bias added, expanding the vector to length ${c_dimRef('4 * C', DimStyle.C4)}. (Note that the output matrix is transposed here.\nThis is purely for vizualization purposes.)\n`;\n    breakAfter();\n\n    let t1_process = afterTime(null, 3.0);\n\n    breakAfter();\n\ncommentary(wt)`\nNext, we apply the GELU activation function to each element of the vector. This is a key part of any neural network, where we introduce some non-linearity into the model. The specific function used, GELU,\nlooks a lot like a ReLU function (computed as ${<code>max(0, x)</code>}), but it has a smooth curve rather than a sharp corner.\n\n${<ReluGraph />}\n\n`;\n    breakAfter();\n\n    let t2_process = afterTime(null, 3.0);\n\n    breakAfter();\n\ncommentary(wt)`\nWe then project the vector back down to length ${c_dimRef('C', DimStyle.C)} with another matrix-vector multiplication with bias added.\n`;\n    breakAfter();\n\n    let t3_process = afterTime(null, 3.0);\n\n    breakAfter();\n\ncommentary(wt)`\nLike in the self-attention + projection section, we add the result of the MLP to its input, element-wise.\n`;\n    breakAfter();\n\n    let t4_process = afterTime(null, 3.0);\n\n    breakAfter();\ncommentary(wt)`\nWe can now repeat this process for all of the columns in the input.`;\n\n    breakAfter();\n\n    let t5_cleanup = afterTime(null, 1.0, 0.5);\n    cleanup(t5_cleanup, [t0_fadeOut]);\n    let t6_processAll = afterTime(null, 6.0);\n\n    breakAfter();\n\ncommentary(wt)`\nAnd that's the MLP completed. We now have the output of the transformer block, which is ready to be passed to the next block.\n`;\n\n    let targetIdx = 3;\n    let inputBlk = block.ln2.lnResid;\n    let mlp1Blk = block.mlpFc;\n    let mlp2Blk = block.mlpAct;\n    let mlpRes = block.mlpResult;\n    let mlpResid = block.mlpResidual;\n\n    function dimExceptVector(blk: IBlkDef, axis: Dim, disable: boolean) {\n        if (t0_fadeOut.t === 0 || t6_processAll.t > 0) {\n            return;\n        }\n\n        if (disable) {\n            blk.access!.disable = true;\n        }\n\n        let col = splitGrid(layout, blk, axis, targetIdx + 0.5, lerp(0.0, 1.0, t0_fadeOut.t))!;\n\n        for (let sub of blk.subs!) {\n            sub.opacity = lerp(1.0, 0.2, t0_fadeOut.t);\n        }\n\n        col.opacity = 1.0;\n\n        return col!;\n    }\n\n    dimExceptVector(inputBlk, Dim.X, false);\n    let mlp1Col = dimExceptVector(mlp1Blk, Dim.Y, true);\n    let mlp2Col = dimExceptVector(mlp2Blk, Dim.Y, true);\n    let mlpResCol = dimExceptVector(mlpRes, Dim.X, true);\n    let mplResIdCol = dimExceptVector(mlpResid, Dim.X, true);\n\n    function processVector(blk: IBlkDef, col: IBlkDef | undefined, t: number, pinIdx: Vec3) {\n        if (t === 0) {\n            return;\n        }\n\n        let dim0 = blk.transpose ? Dim.Y : Dim.X;\n        let dim1 = blk.transpose ? Dim.X : Dim.Y;\n        let { cx: numCells } = dimProps(blk, dim1);\n\n        let xPos = Math.floor(lerp(0, numCells, t));\n\n        let destIdx = new Vec3().setAt(dim0, targetIdx).setAt(dim1, xPos).round_();\n\n        if (col) {\n            let row = splitGrid(layout, col, dim1, xPos, 0.0);\n            for (let a of findSubBlocks(col, dim1, 0, xPos)) {\n                a.access!.disable = false;\n            }\n        }\n\n        if (t < 1.0) {\n            drawDataFlow(state, blk, destIdx, pinIdx);\n            drawDependences(state, blk, destIdx);\n        } else if (col) {\n            col!.access!.disable = false;\n        }\n    }\n\n    processVector(mlp1Blk, mlp1Col, t1_process.t, new Vec3(40));\n    processVector(mlp2Blk, mlp2Col, t2_process.t, new Vec3(mlp1Blk.cx / 2, -15));\n    processVector(mlpRes, mlpResCol, t3_process.t, new Vec3(mlpRes.cx / 2, -15));\n    processVector(mlpResid, mplResIdCol, t4_process.t, new Vec3(mlpRes.cx / 2, -15));\n\n    if (t5_cleanup.t > 0.4) {\n        mlp1Blk.access!.disable = true;\n        mlp2Blk.access!.disable = true;\n        mlpRes.access!.disable = true;\n        mlpResid.access!.disable = true;\n    }\n\n    if (t6_processAll.t > 0) {\n        let prevInfo = startProcessBefore(state, inputBlk);\n        processUpTo(state, t6_processAll, mlpResid, prevInfo);\n    }\n}\n\n\nconst ReluGraph: React.FC = () => {\n\n    let fnRelu = (x: number) => Math.max(0, x);\n    let fnGelu = (x: number) => x * 0.5 * (1 + Math.tanh(Math.sqrt(2 / Math.PI) * (x + 0.044715 * Math.pow(x, 3))));\n\n    function createMapping(range0: number, range1: number, domain0: number, domain1: number) {\n        let m = (range1 - range0) / (domain1 - domain0);\n        let b = range0 - m * domain0;\n        return (x: number) => m * x + b;\n    }\n\n    let w = 200;\n    let h = 160;\n\n    let halfW = 3.2;\n    let halfH = halfW * h / w;\n    let hOffset = 1.1;\n\n    let xScale = createMapping(0, w, -halfW, halfW);\n    let yScale = createMapping(h, 0, -halfH + hOffset, halfH + hOffset);\n\n    let xPts = makeArrayRange(100, -halfW, halfW);\n\n    function makePath(fn: (x: number) => number) {\n        let path = \"\";\n        for (let x of xPts) {\n            let y = fn(x);\n            path += (path ? 'L' : 'M') + `${xScale(x)},${yScale(y)} `;\n        }\n        return path;\n    }\n\n    let vertTickVals = [-1, 1, 2, 3];\n\n    let vertTicks = vertTickVals.map(a => {\n        return { x: xScale(0), y: yScale(a), label: a };\n    });\n\n    let horizTickVals = [-3, -2, -1, 1, 2, 3];\n    let horizTicks = horizTickVals.map(a => {\n        return { x: xScale(a), y: yScale(0), label: a };\n    });\n\n    let tickColor = \"gray\";\n\n    return <div className=\"flex justify-center my-2\">\n        <svg viewBox={`0 0 ${w} ${h}`} width={w} height={h} className=\"bg-slate-200 rounded\">\n            <line x1={xScale(-halfW)} x2={xScale(halfW)} y1={yScale(0)} y2={yScale(0)} stroke={\"gray\"} strokeWidth={1} />\n            <line x1={xScale(0)} x2={xScale(0)} y1={yScale(-halfH + hOffset)} y2={yScale(halfH + hOffset)} stroke={\"gray\"} strokeWidth={1} />\n            {/* <path d={makePath(fnRelu)} stroke={\"blue\"} fill=\"none\" strokeWidth={1} /> */}\n            <path d={makePath(fnGelu)} stroke={dimStyleColor(DimStyle.Intermediates).toHexColor()} fill=\"none\" strokeWidth={3} />\n            {vertTicks.map((a, i) => <g key={i} transform={`translate(${a.x}, ${a.y})`}>\n                <line x1={-5} x2={5} y1={0} y2={0} stroke={tickColor} strokeWidth={1} />\n                <text x={10} y={5} fontSize={10} fill={tickColor}>{a.label}</text>\n            </g>)}\n            {horizTicks.map((a, i) => <g key={i} transform={`translate(${a.x}, ${a.y})`}>\n                <line x1={0} x2={0} y1={-5} y2={5} stroke={tickColor} strokeWidth={1} />\n                <text x={0} y={18} fontSize={10} textAnchor=\"middle\" fill={tickColor}>{a.label}</text>\n            </g>)}\n        </svg>\n    </div>;\n};\n","import { Vec3 } from \"@/src/utils/vector\";\nimport { Phase } from \"./Walkthrough\";\nimport { commentary, IWalkthroughArgs, setInitialCamera } from \"./WalkthroughTools\";\n\nexport function walkthrough08_Transformer(args: IWalkthroughArgs) {\n    let { walkthrough: wt, state } = args;\n\n    if (wt.phase !== Phase.Input_Detail_Transformer) {\n        return;\n    }\n\n    setInitialCamera(state, new Vec3(-135.531, 0.000, -353.905), new Vec3(291.100, 13.600, 5.706));\n\n    let c0 = commentary(wt, null, 0)`\n\nAnd that's a complete transformer block!\n\nThese form the bulk of any GPT model and are repeated a number of times, with the output of one\nblock feeding into the next, continuing the residual pathway.\n\nAs is common in deep learning, it's hard to say exactly what each of these layers is doing, but we\nhave some general ideas: the earlier layers tend to focus on learning\nlower-level features and patterns, while the later layers learn to recognize and understand\nhigher-level abstractions and relationships. In the context of natural language processing, the\nlower layers might learn grammar, syntax, and simple word associations, while the higher layers\nmight capture more complex semantic relationships, discourse structures, and context-dependent meaning.\n\n`;\n\n}\n","import { Vec3 } from \"@/src/utils/vector\";\nimport { Phase } from \"./Walkthrough\";\nimport { commentary, IWalkthroughArgs, setInitialCamera } from \"./WalkthroughTools\";\n\nexport function walkthrough09_Output(args: IWalkthroughArgs) {\n    let { walkthrough: wt, state } = args;\n\n    if (wt.phase !== Phase.Input_Detail_Output) {\n        return;\n    }\n\n    setInitialCamera(state, new Vec3(-20.203, 0.000, -1642.819), new Vec3(281.600, -7.900, 2.298));\n\n    let c0 = commentary(wt, null, 0)`\n\nFinally, we come to the end of the model. The output of the final transformer block is passed through\na layer normalization, and then we use a linear transformation (matrix multiplication), this time without a bias.\n\nThis final transformation takes each of our column vectors from length C to length nvocab. Hence,\nit's effectively producing a score for each word in the vocabulary for each of our columns. These\nscores have a special name: logits.\n\nThe name \"logits\" comes from \"log-odds,\" i.e., the logarithm of the odds of each token. \"Log\" is\nused because the softmax we apply next does an exponentiation to convert to \"odds\" or probabilities.\n\nTo convert these scores into nice probabilities, we pass them through a softmax operation. Now, for\neach column, we have a probability the model assigns to each word in the vocabulary.\n\nIn this particular model, it has effectively learned all the answers to the question of how to sort\nthree letters, so the probabilities are heavily weighted toward the correct answer.\n\nWhen we're stepping the model through time, we use the last column's probabilities to determine the\nnext token to add to the sequence. For example, if we've supplied six tokens into the model, we'll\nuse the output probabilities of the 6th column.\n\nThis column's output is a series of probabilities, and we actually have to pick one of them to use\nas the next in the sequence. We do this by \"sampling from the distribution.\" That is, we randomly\nchoose a token, weighted by its probability. For example, a token with a probability of 0.9 will be\nchosen 90% of the time.\n\nThere are other options here, however, such as always choosing the token with the highest probability.\n\nWe can also control the \"smoothness\" of the distribution by using a temperature parameter. A higher\ntemperature will make the distribution more uniform, and a lower temperature will make it more\nconcentrated on the highest probability tokens.\n\nWe do this by dividing the logits (the output of the linear transformation) by the temperature before\napplying the softmax. Since the exponentiation in the softmax has a large effect on larger numbers,\nmaking them all closer together will reduce this effect.\n`;\n\n}\n","import { addSourceDestCurveLine, blockDimension, blockIndex, drawTextOnModel, findSubBlocks, indexMappingLines, renderIndexes, splitGrid, TextAlignHoriz, TextAlignVert } from \"../Annotations\";\nimport { ICamera, ICameraPos } from \"../Camera\";\nimport { IBlkDef } from \"../GptModelLayout\";\nimport { IProgramState } from \"../Program\";\nimport { IRenderView } from \"../render/modelRender\";\nimport { drawThread } from \"../render/threadRender\";\nimport { SavedState } from \"../SavedState\";\nimport { oneHotArray } from \"@/src/utils/data\";\nimport { lerp, lerpSmoothstep } from \"@/src/utils/math\";\nimport { Dim, Vec3, Vec4 } from \"@/src/utils/vector\";\nimport { DimStyle, dimStyleColor, hideFromBlock, ICommentary, ICommentaryRes, IPhaseGroup, ITimeInfo, IWalkthroughArgs, moveCameraTo, phaseTools } from \"./WalkthroughTools\";\nimport { walkthroughIntro } from \"./Walkthrough00_Intro\";\nimport { walkthrough01_Prelim } from \"./Walkthrough01_Prelim\";\nimport { walkthrough02_Embedding } from \"./Walkthrough02_Embedding\";\nimport { walkthrough03_LayerNorm } from \"./Walkthrough03_LayerNorm\";\nimport { walkthrough04_SelfAttention } from \"./Walkthrough04_SelfAttention\";\nimport { walkthrough05_Softmax } from \"./Walkthrough05_Softmax\";\nimport { walkthrough06_Projection } from \"./Walkthrough06_Projection\";\nimport { walkthrough07_Mlp } from \"./Walkthrough07_Mlp\";\nimport { walkthrough08_Transformer } from \"./Walkthrough08_Transformer\";\nimport { walkthrough09_Output } from \"./Walkthrough09_Output\";\n\n\n/**\n\nThoughts about the walkthrough:\n\n- Linking text events to the visual actions doesn't work well.\n- Attention needs to flip between them directly. Much better to do a chunk of text, then [Spacebar], then action.\n  Can still do aligned highlights though, but focused on the model, and linking back to the text.\n  This also works well with hover on either. The color-coding helps a lot anyway.\n\n- Better to do all this text in html, it adds searchability, and supports more things. _However_, probably\n  difficult to do TeX fonts. Although maybe that's a bit excessive anyway.\n\n- Can show a reasonable amount of text: Limit to half a screen on mobile, say.\n\n- Fast but smooth transitions, with a pause in between, is much better.\n- Slow, linked transitions is kinda nauseating.\n\n- Need more controls! Mainly jumping between phases, and selecting times on phases.\n- Can compute the latest time on each phase by keeping track of the events. Can keep this in an array for\n  display as well.\n- Need to push back into react-land at the end of each frame. (commentary; stats; etc)\n- Probably need to query all the phases up front somehow. Could have a pass where we don't actually\n  update anything, but read off info for each one. A pain for the in-place updates though. Likely to break\n  things. Easier to just have a list of them and info like titles.\n- Hmm, do want to expand to total time, hmm.\n\n- Need a bunch more annotations/effects yet\n  - Get the trails working well\n  - Want a descriptor of how a cell is computed (x, y from these; mul by a, b from these, plus this; all added, [t])\n  - It applies to everything, and could allow for 'draw for this 1 cell', 'draw for this col/row of cells'.\n  - Curved arrows and flows with thickness\n    - Arrows for showing embedding mapping, and for linking src & sink\n    - Flows for the residual pathway: wide transparent no-width path, with glowing more-solid sides\n      - Basically wide arrows\n      - Also need side bit coming off of it for when it's copied\n      - Not as wide as the actual block; keep it maybe half-T thick\n      - Some indication of flow\n  - Highlight block or row/column\n\n */\n\n\nexport type IWalkthrough = ReturnType<typeof initWalkthrough>;\n\nexport function initWalkthrough() {\n    return {\n        phase: SavedState.state?.phase ?? Phase.Intro_Intro,\n        time: SavedState.state?.phaseTime ?? 0,\n        viewDt: 0,\n        dt: 0,\n        prevTime: 0,\n        prevPhase: Phase.None,\n        running: false,\n        speed: 1,\n        cameraInitial: null as ICameraPos | null,\n        commentary: null as ICommentaryRes | null,\n        times: [] as (ITimeInfo | ICommentary)[],\n        phaseLength: 0,\n        dimHighlightBlocks: null as IBlkDef[] | null,\n        markDirty: () => { }, // bit of a hack to get it to WalkthroughSidebar\n        phaseData: new Map<Phase, any>(),\n        phaseTransitiveData: null as any,\n        phaseList: [{\n            groupId: PhaseGroup.Intro,\n            title: 'Introduction',\n            phases: [\n                { id: Phase.Intro_Intro, title: 'Overview' },\n                { id: Phase.Intro_Prelim, title: 'Preliminary' },\n            ],\n        }, {\n            groupId: PhaseGroup.Detailed_Input,\n            title: 'Detailed',\n            phases: [\n                { id: Phase.Input_Detail_Embedding, title: 'Embedding' },\n                { id: Phase.Input_Detail_LayerNorm, title: 'Layer Norm' },\n                { id: Phase.Input_Detail_SelfAttention, title: 'Self Attention' },\n                { id: Phase.Input_Detail_Projection, title: 'Projection' },\n                { id: Phase.Input_Detail_Mlp, title: 'MLP' },\n                { id: Phase.Input_Detail_Transformer, title: 'Transformer' },\n                { id: Phase.Input_Detail_Softmax, title: 'Softmax' },\n                { id: Phase.Input_Detail_Output, title: 'Output' },\n            ],\n        }] as IPhaseGroup[],\n    };\n}\n\ninterface ICameraData {\n    initialCaptured?: ICameraPos;\n    target: ICameraPos;\n}\n\nexport enum PhaseGroup {\n    Intro,\n    Detailed_Input,\n}\n\nexport enum Phase {\n    None,\n\n    Intro_Intro,\n    Input_First,\n    Input_Detail_Tables,\n    Input_Detail_TokEmbed,\n    LayerNorm1,\n    Intro_Prelim,\n    Input_Detail_Embedding,\n    Input_Detail_LayerNorm,\n    Input_Detail_SelfAttention,\n    Input_Detail_Softmax,\n    Input_Detail_Projection,\n    Input_Detail_Mlp,\n    Input_Detail_Transformer,\n    Input_Detail_Output,\n}\n\nexport function phaseToGroup(wt: IWalkthrough) {\n    return wt.phaseList.find(g => g.phases.find(p => p.id === wt.phase))!;\n}\n\n\nexport function runWalkthrough(state: IProgramState, view: IRenderView) {\n    let wt = state.walkthrough;\n    wt.viewDt = view.dt;\n\n    if (wt.running) {\n        let dtSeconds = view.dt / 1000 * wt.speed;\n        wt.time += dtSeconds;\n        wt.dt = dtSeconds;\n\n        if (wt.time > wt.phaseLength) {\n            wt.running = false;\n            wt.time = wt.phaseLength;\n        }\n\n        view.markDirty();\n    }\n\n    SavedState.state = { phase: wt.phase, phaseTime: wt.time, camera: state.camera };\n\n    if (wt.prevPhase !== wt.phase) {\n        wt.phaseTransitiveData = null;\n    }\n\n    wt.cameraInitial = null;\n    wt.times = [];\n    wt.phaseLength = 0;\n    wt.dimHighlightBlocks = null;\n\n    let wtArgs: IWalkthroughArgs = { state, layout: state.layout, tools: phaseTools(state), walkthrough: wt };\n\n    let groupId = phaseToGroup(wt).groupId;\n    if (groupId === PhaseGroup.Intro) {\n        walkthroughIntro(wtArgs);\n        walkthrough01_Prelim(wtArgs);\n    } else if (groupId === PhaseGroup.Detailed_Input) {\n        walkthroughDetailed(wtArgs);\n        walkthrough02_Embedding(wtArgs);\n        walkthrough03_LayerNorm(wtArgs);\n        walkthrough04_SelfAttention(wtArgs);\n        walkthrough05_Softmax(wtArgs);\n        walkthrough06_Projection(wtArgs);\n        walkthrough07_Mlp(wtArgs);\n        walkthrough08_Transformer(wtArgs);\n        walkthrough09_Output(wtArgs);\n    }\n\n    wt.prevPhase = wt.phase;\n    wt.prevTime = wt.time;\n}\n\nexport function walkthroughDetailed(args: IWalkthroughArgs) {\n    let { walkthrough: wt, tools: { c_str, afterTime, atTime, atEvent, commentary, commentaryPara, cleanup }, layout, state } = args;\n    let cam = state.camera;\n    let render = state.render;\n    let display = state.display;\n\n    switch (wt.phase) {\n\n    case Phase.Input_First: {\n        let t0 = c_str('', 0);\n        let c = commentary`These vectors now pass through the stages of the model, going through a series of transformers.${t0}`;\n        let t1 = atEvent(t0);\n        let t1a = afterTime(t1, 0.0, 2.0);\n        let t2 = afterTime(t1a, 5, 0.2);\n\n        if (!t2.active) {\n            cam.centerDesired = new Vec3(0, 0, -30);\n            cam.angleZDesired = 1.2;\n            cam.angleDesired = new Vec3(290, 20);\n        }\n\n        let blocks = layout.cubes.filter(b => b.t === 'i');\n        let pos = lerpSmoothstep(0, blocks.length, t2.t);\n        let idx = Math.floor(pos);\n        for (let i = Math.min(idx, blocks.length - 1); i >= 0; i--) {\n            if (!t2.active) {\n                break;\n            }\n            // blocks that are <= idx should have a falloff applied based on how much they're earlier than idx\n            let falloff = 1.0 - (pos - i) / 8;\n            if (falloff < 0) {\n                break;\n            }\n            let blk = blocks[i];\n            blk.highlight = falloff * 0.8;\n            // blk.access?.enable();\n        }\n        if (idx < blocks.length - 1) {\n            let blk = blocks[idx];\n            hideFromBlock(render, layout, blk);\n        }\n\n        break;\n    }\n\n    case Phase.Input_Detail_Tables: {\n\n        // practice drawing labels on tensors\n        let t0_showAll = atTime(0, 0.1, 0.2);\n        t0_showAll.t = 1.0;\n\n        let tokEmbed = layout.tokEmbedObj;\n        drawTextOnModel(render, 'token-embedding matrix', new Vec3(tokEmbed.x - layout.margin, tokEmbed.y + tokEmbed.dy / 4, 0), {\n            align: TextAlignHoriz.Right,\n            valign: TextAlignVert.Middle,\n            color: new Vec4(0,0,0,1).mul(t0_showAll.t),\n            size: 3,\n        });\n        let posEmbed = layout.posEmbedObj;\n        drawTextOnModel(render, 'position-embedding matrix', new Vec3(posEmbed.x + posEmbed.dx + layout.margin, tokEmbed.y + tokEmbed.dy / 4, 0), {\n            align: TextAlignHoriz.Left,\n            valign: TextAlignVert.Middle,\n            color: new Vec4(0,0,0,1).mul(t0_showAll.t),\n            size: 3,\n        });\n\n        blockDimension(state, layout, tokEmbed, Dim.X, DimStyle.n_vocab, t0_showAll.t);\n        blockDimension(state, layout, tokEmbed, Dim.Y, DimStyle.C, t0_showAll.t);\n\n        blockDimension(state, layout, posEmbed, Dim.X, DimStyle.T, t0_showAll.t);\n        blockDimension(state, layout, posEmbed, Dim.Y, DimStyle.C, t0_showAll.t);\n\n        blockDimension(state, layout, layout.residual0, Dim.X, DimStyle.T, t0_showAll.t);\n        blockDimension(state, layout, layout.residual0, Dim.Y, DimStyle.C, t0_showAll.t);\n\n    } break;\n    case Phase.Input_Detail_TokEmbed: {\n        let tStr = c_str('t', 1);\n        let c = commentary`Let's start at the top. To compute the vectors at each time ${tStr} we do a couple of steps:`;\n\n        moveCameraTo(state, atTime(0), new Vec3(0, 0, 0), new Vec3());\n\n        let t0_expandAt0 = atTime(0, 0.1, 0.2);\n        let t1_totEq3 = afterTime(t0_expandAt0, 1.0, 0.2);\n        let t2_expandSplit = afterTime(t1_totEq3, 0.1, 0.4);\n\n        let t3_showTokEmIdx = afterTime(t2_expandSplit, 0.2, 1.0);\n        let t4_highlightTokEmIdx = afterTime(t3_showTokEmIdx, 0.4, 1.0);\n        let t5_iter1Col = afterTime(t4_highlightTokEmIdx, 1.0, 1.0);\n        let t6_cleanup1 = afterTime(t5_iter1Col, 0.3, 1.0);\n\n        cleanup(t6_cleanup1, [t0_expandAt0, t2_expandSplit, t4_highlightTokEmIdx, t5_iter1Col]);\n\n        let t7_iterCols = afterTime(t6_cleanup1, 5.0, 0.0);\n\n        let exampleTIdx = 3;\n        let exampleTokIdx = layout.model?.inputBuf[exampleTIdx] ?? 1;\n\n        // blockDimension(state, layout, layout.residual0, Dim.X, DimStyle.T, 0.5);\n        if (t6_cleanup1.t < 1.0) {\n            let idx = lerp(0, 3, t1_totEq3.t);\n            let split = lerpSmoothstep(t0_expandAt0.t * 1.0, exampleTIdx, t2_expandSplit.t);\n            blockIndex(render, layout, layout.residual0, Dim.X, DimStyle.t, idx, split / 2, t0_expandAt0.t);\n            splitGrid(layout, layout.residual0, Dim.X, idx + 0.5, split);\n            splitGrid(layout, layout.idxObj   , Dim.X, idx + 0.5, split);\n        }\n\n        let embedMtx = c_str('token embedding matrix');\n        let tokCol = c_str('j');\n        commentaryPara(c)`\\n\\n1. From the ${embedMtx}, select the ${tokCol}'th column.`;\n\n        let embedOffColor = new Vec4(0.5,0.5,0.5).mul(0.6);\n\n        if (layout.model && t7_iterCols.t <= 0.0) {\n            let mixes = new Array(layout.tokEmbedObj.cx).fill(0.0);\n            mixes[layout.model!.inputBuf[exampleTIdx]] = t4_highlightTokEmIdx.t;\n            renderIndexes(render, layout, layout.tokEmbedObj, embedOffColor, t3_showTokEmIdx.t, exampleTIdx, 0, null, { color2: dimStyleColor(DimStyle.n_vocab), mixes });\n        }\n\n        if (layout.model && t4_highlightTokEmIdx.t > 0 && t6_cleanup1.t <= 1.0) {\n            splitGrid(layout, layout.tokEmbedObj, Dim.X, exampleTokIdx, 0);\n            findSubBlocks(layout.tokEmbedObj, Dim.X, exampleTokIdx, exampleTokIdx)[0].highlight = lerp(0, 0.2, t4_highlightTokEmIdx.t);\n            display.tokenColors = { color2: dimStyleColor(DimStyle.n_vocab), mixes: oneHotArray(layout.idxObj.cx, exampleTIdx, t4_highlightTokEmIdx.t) };\n            let padTop = layout.cell * 0.3;\n            let padBot = layout.cell * 0.3 + 3;\n            let color = dimStyleColor(DimStyle.n_vocab).mul(t4_highlightTokEmIdx.t);\n            indexMappingLines(render, layout, layout.idxObj, layout.tokEmbedObj, color, padTop, padBot, exampleTIdx, exampleTokIdx, 0.5);\n        }\n\n        if (layout.model && t7_iterCols.t < 1.0) {\n            hideFromBlock(render, layout, layout.residual0);\n        }\n\n        if (layout.model && t5_iter1Col.t > 0.0 && t6_cleanup1.t <= 0.0) {\n            let sub = findSubBlocks(layout.residual0, Dim.X, exampleTIdx, exampleTIdx)[0];\n            if (sub) {\n                sub.access = { ...sub.access!, src: layout.model.vocabEmbed.output, disable: false };\n                let yPos = t5_iter1Col.t * sub.cy;\n                let yIdx = Math.floor(yPos);\n                if (yIdx < sub.cy) {\n                    addSourceDestCurveLine(render, layout, layout.tokEmbedObj, layout.residual0, new Vec3(exampleTokIdx, yIdx, 0), new Vec3(exampleTIdx, yIdx, 0), new Vec4(1,0,0,1));\n                    drawThread(render.threadRender, layout, sub, Dim.Y, 0, 0, 1, yIdx + 1, new Vec4(1,0,0,1));\n                    drawThread(render.threadRender, layout, layout.tokEmbedObj, Dim.Y, exampleTokIdx, 0, 1, yIdx + 1, new Vec4(1,0,0,1));\n                    drawThread(render.threadRender, layout, layout.posEmbedObj, Dim.Y, exampleTIdx, 0, 1, yIdx + 1, new Vec4(1,0,0,1));\n                }\n\n                splitGrid(layout, sub, Dim.Y, yPos, 0.0);\n\n                for (let vertSubBelow of findSubBlocks(sub, Dim.Y, Math.floor(yPos) + 1, null)) {\n                    vertSubBelow.access = { ...sub.access, disable: true };\n                }\n            }\n        }\n\n        if (layout.model && t7_iterCols.active) {\n            let T = layout.idxObj.cx;\n            let C = layout.residual0.cy;\n\n            let tPos = t7_iterCols.t * T;\n            let tIdx = Math.floor(tPos);\n\n            let t_inner = tPos - tIdx;\n            let cPos = t_inner * C;\n\n            let tokIdx = layout.model.inputBuf[tIdx];\n\n            display.tokenColors = { color2: dimStyleColor(DimStyle.n_vocab), mixes: oneHotArray(T, tIdx, 1.0) };\n\n            splitGrid(layout, layout.residual0, Dim.X, tIdx + 0.5, 0.0);\n\n            let sub = findSubBlocks(layout.residual0, Dim.X, null, tIdx - 1);\n            for (let vertSubLeft of sub) {\n                vertSubLeft.access = { ...vertSubLeft.access!, disable: false };\n            }\n            let sub2 = findSubBlocks(layout.residual0, Dim.X, tIdx, tIdx)[0];\n            if (sub2) {\n                sub2.highlight = 0.2;\n                sub2.access = { ...sub2.access!, disable: false };\n                let yPos = cPos + 0.5;\n\n                let yIdx = Math.floor(cPos);\n                let curveColor = new Vec4(1,0,0,1).mul(0.3);\n                addSourceDestCurveLine(render, layout, layout.tokEmbedObj, layout.residual0, new Vec3(tokIdx, yIdx, 0), new Vec3(tIdx, yIdx, 0), curveColor);\n                addSourceDestCurveLine(render, layout, layout.posEmbedObj, layout.residual0, new Vec3(tIdx, yIdx, 0), new Vec3(tIdx, yIdx, 0), curveColor);\n\n                drawThread(render.threadRender, layout, layout.residual0, Dim.Y, tIdx, 0, 1, yIdx + 1, new Vec4(1,0,0,1));\n                drawThread(render.threadRender, layout, layout.tokEmbedObj, Dim.Y, tokIdx, 0, 1, yIdx + 1, new Vec4(1,0,0,1));\n                drawThread(render.threadRender, layout, layout.posEmbedObj, Dim.Y, tIdx, 0, 1, yIdx + 1, new Vec4(1,0,0,1));\n\n                splitGrid(layout, sub2, Dim.Y, yPos, 0.0);\n\n                for (let colSubBelow of findSubBlocks(sub2, Dim.Y, Math.floor(cPos) + 1, null)) {\n                    colSubBelow.access = { ...colSubBelow.access!, disable: true };\n                }\n            }\n\n\n            let mixes = oneHotArray(layout.tokEmbedObj.cx, tokIdx, 1.0);\n            renderIndexes(render, layout, layout.tokEmbedObj, embedOffColor, t3_showTokEmIdx.t, 3, 0, null, { color2: dimStyleColor(DimStyle.n_vocab), mixes });\n\n            let padTop = layout.cell * 0.3;\n            let padBot = layout.cell * 0.3 + 3;\n            let color = dimStyleColor(DimStyle.n_vocab).mul(t3_showTokEmIdx.t);\n            indexMappingLines(render, layout, layout.idxObj, layout.tokEmbedObj, color, padTop, padBot, tIdx, tokIdx, 0.5);\n\n            let tokSub = splitGrid(layout, layout.tokEmbedObj, Dim.X, tokIdx + 0.5, 0);\n            // let tokSub = findSubBlocks(layout.tokEmbedObj, Dim.X, tokIdx, tokIdx)[0];\n            if (tokSub) {\n                tokSub.highlight = 0.2;\n            }\n\n            let posSub = splitGrid(layout, layout.posEmbedObj, Dim.X, tIdx + 0.5, 0);\n            // let posSub = findSubBlocks(layout.posEmbedObj, Dim.X, tIdx, tIdx)[0];\n            if (posSub) {\n                posSub.highlight = 0.2;\n            }\n        }\n\n        // fallthrough to continue once the commentary is done\n    } break;\n\n    }\n}\n","import React, { memo, useCallback, useLayoutEffect, useState } from 'react';\nimport { BoundingBox3d, Vec3 } from '@/src/utils/vector';\nimport s from './TocDiagram.module.scss';\nimport * as d3Color from 'd3-color';\nimport { isNotNil } from '@/src/utils/data';\nimport { Phase } from '../walkthrough/Walkthrough';\nimport clsx from 'clsx';\nimport { jumpToPhase } from '../Commentary';\nimport { useProgramState } from '../Sidebar';\nimport { Subscriptions } from '@/src/utils/hooks';\n\nenum ElType {\n    Cell,\n    PosEmbed,\n    Block,\n    Gap,\n}\n\ninterface IEl {\n    type: ElType;\n    id?: string;\n    label?: string | string[];\n    gapType?: 'exit' | 'multihead' | 'add';\n    height: number;\n    width?: number;\n    items?: IEl[];\n    color?: string;\n    padX?: number;\n    padY?: number;\n    marginY?: number;\n    arrow?: boolean;\n    special?: 'transformer' | 'llm';\n\n    posPx?: Vec3;\n    sizePx?: Vec3;\n}\n\ninterface IEntryGroup {\n    groupName: string;\n    entries: IEntryInfo[];\n}\n\ninterface IEntryInfo {\n    id: Phase;\n    title: string;\n    ids: string[];\n    groupIds: boolean;\n}\n\nexport const TocDiagram: React.FC<{\n    activePhase: Phase | null;\n    onEnterPhase?: (phase: Phase) => void;\n}> = ({ activePhase, onEnterPhase }) => {\n    let [entryManager] = useState(() => new EntryManager());\n    // used for measuring text\n    let [diagramEl, setDiagramEl] = useState<SVGElement | null>(null);\n    let [canvas, setCanvas] = useState<HTMLCanvasElement | null>(null);\n    let progState = useProgramState();\n    useLayoutEffect(() => {\n        setCanvas(document.createElement('canvas')!);\n    }, []);\n\n    let [hoverId, setHoverId] = useState<Phase | null>(null);\n\n    let setHover = useCallback((ev: React.MouseEvent, id: Phase, hover: boolean) => {\n         setHoverId(hover ? id : null);\n    }, []);\n\n    let [activeId, setActiveId] = useState<Phase | null>(null);\n\n    let setActive = useCallback((ev: React.MouseEvent, id: Phase, active: boolean) => {\n        jumpToPhase(progState.walkthrough, id);\n        onEnterPhase?.(id);\n        setActiveId(active ? id : null);\n    }, [progState.walkthrough, onEnterPhase]);\n\n    activeId = activePhase ?? activeId;\n\n    let colors = {\n        ln: '#e9f29e',\n        multihead: '#f2d59e',\n        feedForward: '#9ef2f2',\n        tokEmbed: '#f0a8fc',\n        linear: '#a8c3fc',\n        softmax: '#a8fcaf',\n        line: '#000',\n        focus: '#338',\n    };\n\n    let widthStd = 4;\n    let widthMultihead = 7;\n    let widthFeedForward = 5;\n    let smallGap = 0.5;\n    let plusGap = 1.0;\n    let exitGap = 0.8;\n\n    let structure: IEl = {\n        type: ElType.Block, height: 0, color: '#eee', special: 'llm', padX: 2.0, padY: 1.0, id: 'llm', items: [\n            { type: ElType.Cell, label: 'tok embed', height: 1, width: 4, color: colors.tokEmbed, id: 'tokEmbed' },\n            { type: ElType.PosEmbed, height: 1.8, id: 'posEmbed' },\n            { type: ElType.Block, height: 0, padX: 3, padY: 0, color: '#ddd', special: 'transformer', id: 'transformer', items: [\n                { type: ElType.Gap, height: 1.2, gapType: 'exit', arrow: true },\n                { type: ElType.Cell, height: 1, label: 'layer norm', width: widthStd, color: colors.ln, id: 'ln1' },\n                { type: ElType.Gap, height: exitGap, gapType: 'multihead', arrow: true },\n                { type: ElType.Cell, height: 2, label: ['multi-head, causal', 'self-attention'], width: widthMultihead, color: colors.multihead, id: 'selfAttend' },\n                { type: ElType.Gap, height: plusGap, gapType: 'add' },\n                { type: ElType.Gap, height: exitGap, gapType: 'exit', arrow: true },\n                { type: ElType.Cell, height: 1, label: 'layer norm', width: widthStd, color: colors.ln, id: 'ln2' },\n                { type: ElType.Gap, height: smallGap, arrow: true },\n                { type: ElType.Cell, height: 2, label: ['feed', 'forward'], width: widthFeedForward, color: colors.feedForward, id: 'feedForward' },\n                { type: ElType.Gap, height: plusGap, gapType: 'add' },\n            ] },\n            { type: ElType.Gap, height: smallGap, arrow: true },\n            { type: ElType.Cell, height: 1, label: 'layer norm', width: widthStd, color: colors.ln, id: 'lnf' },\n            { type: ElType.Gap, height: smallGap, arrow: true },\n            { type: ElType.Cell, label: 'linear', height: 1, width: widthStd, color: colors.linear, id: 'linear' },\n            { type: ElType.Gap, height: smallGap, arrow: true },\n            { type: ElType.Cell, label: 'softmax', height: 1, width: widthStd, color: colors.softmax, id: 'softmaxOut' },\n        ]\n    };\n\n    let entries: IEntryInfo[] = [];\n    let entryGroups: IEntryGroup[] = [];\n\n    function makeEntry(id: Phase, title: string, ids: string[] = [], groupIds: boolean = false) {\n        let entry = { id, title, ids, groupIds };\n        entries.push(entry);\n        entryGroups[entryGroups.length - 1].entries.push(entry);\n    }\n\n    entryGroups.push({ groupName: 'Intro', entries: [] });\n    makeEntry(Phase.Intro_Intro, 'Introduction', []);\n    makeEntry(Phase.Intro_Prelim, 'Preliminaries', []);\n\n    entryGroups.push({ groupName: 'Components', entries: [] });\n    makeEntry(Phase.Input_Detail_Embedding, 'Embedding', ['tokEmbed', 'posEmbed'], true);\n    makeEntry(Phase.Input_Detail_LayerNorm, 'Layer Norm', ['ln1', 'ln2', 'lnf']);\n    makeEntry(Phase.Input_Detail_SelfAttention, 'Self Attention', ['selfAttend']);\n    makeEntry(Phase.Input_Detail_Projection, 'Projection', ['selfAttend']);\n    makeEntry(Phase.Input_Detail_Mlp, 'MLP', ['feedForward']);\n    makeEntry(Phase.Input_Detail_Transformer, 'Transformer', ['transformer']);\n    makeEntry(Phase.Input_Detail_Softmax, 'Softmax', ['softmaxOut']);\n    makeEntry(Phase.Input_Detail_Output, 'Output', ['lnf', 'linear', 'softmaxOut'], true);\n\n    function calcSizes(el: IEl): void {\n        el.padX = el.padX ?? 0;\n        el.padY = el.padY ?? 0;\n\n         if (el.type === ElType.Block) {\n            let sizePx = new Vec3(0, el.padY! * 2 * sizeScale);\n            for (let item of el.items!) {\n                calcSizes(item);\n                sizePx.x = Math.max(sizePx.x, item.sizePx!.x);\n                sizePx.y += item.sizePx!.y;\n            }\n            sizePx.x += el.padX! * sizeScale;\n            el.sizePx = sizePx;\n        } else {\n\n            if (el.type === ElType.Gap) {\n                el.width = 0;\n            } else if (el.type === ElType.PosEmbed) {\n                el.width = 10;\n            }\n\n            el.width = el.width ?? 1;\n            el.height = el.height ?? 1;\n            el.sizePx = new Vec3(el.width * sizeScale, el.height * sizeScale);\n        }\n    }\n\n    function calcPosition(el: IEl, offset: Vec3) {\n        el.posPx = offset;\n        if (el.type === ElType.Block) {\n            let midX = el.sizePx!.x / 2;\n            let posPx = new Vec3(el.padX! * sizeScale, el.padY! * sizeScale);\n            for (let item of el.items!) {\n                calcPosition(item, new Vec3(midX - item.sizePx!.x / 2, posPx.y));\n                posPx.y += item.sizePx!.y;\n            }\n        }\n    }\n\n    let sizeScale = 20;\n    let fontSize = 11;\n\n    calcSizes(structure);\n    calcPosition(structure, new Vec3(10 + 0.5, 90 + 0.5));\n\n    interface IElGlobalBounds {\n        el: IEl;\n        bounds: BoundingBox3d;\n    }\n\n    function findByIdBounds(id: string): BoundingBox3d | null {\n        return findById(id)?.bounds ?? null;\n    }\n\n    function getElGlobalBounds(el: IEl, offset: Vec3): BoundingBox3d {\n        let posGlobal = el.posPx!.add(offset);\n        return new BoundingBox3d(posGlobal, posGlobal.add(el.sizePx!));\n    }\n\n    function findById(id: string, offset?: Vec3, el?: IEl): IElGlobalBounds | null {\n        offset = offset ?? new Vec3(0, 0);\n        el = el ?? structure;\n        if (el.id === id) {\n            return { el, bounds: getElGlobalBounds(el, offset) };\n        }\n\n        if (el.items) {\n            for (let item of el.items) {\n                let res = findById(id, el.posPx!.add(offset), item);\n                if (res) {\n                    return res;\n                }\n            }\n        }\n        return null;\n    }\n\n    function elIsHoveredOrActive(el: IEl): boolean | null {\n        let targetId = isNotNil(hoverId) ? hoverId : activeId;\n        let entry = entries.find(e => e.id === targetId);\n        if (!entry) {\n            return null;\n        }\n        let isHover = entry.ids.includes(el.id ?? '');\n        return isHover;\n    }\n\n    function renderPlus(pos: Vec3, key: string) {\n        let plusLen = 4;\n        return <g key={key}>\n            <circle cx={pos.x} cy={pos.y} r={6} stroke='#000000' fill='white' />;\n            <line x1={pos.x - plusLen} y1={pos.y} x2={pos.x + plusLen} y2={pos.y} stroke='#000000' strokeWidth={1} />;\n            <line x1={pos.x} y1={pos.y - plusLen} x2={pos.x} y2={pos.y + plusLen} stroke='#000000' strokeWidth={1} />;\n        </g>;\n    }\n\n    function renderArrow(to: Vec3, from: Vec3, key: string) {\n        let dir = to.sub(from).normalize();\n        let dirProp = new Vec3(dir.y, -dir.x);\n        let arrowLen = 5;\n        let arrowWidth = 4;\n        let left = to.mulAdd(dir, -arrowLen).mulAdd(dirProp, -arrowWidth / 2);\n        let right = to.mulAdd(dir, -arrowLen).mulAdd(dirProp, arrowWidth / 2);\n        let path = `M${left.x},${left.y} L${to.x},${to.y} L${right.x},${right.y}Z`;\n        return <g key={key}>\n            <path d={path} fill={colors.line} className={s.dataPath} />\n        </g>;\n    }\n\n    function renderEl(el: IEl, idx: number) {\n        let pos = el.posPx!;\n        let size = el.sizePx!;\n        let transform = `translate(${pos.x}, ${pos.y})`;\n        let fill = el.color ?? '#00000000';\n        let stroke = d3Color.color(fill)?.darker(0.5).toString();\n\n        function renderResiduals() {\n            let from = el.items!.filter(a => a.gapType === 'exit');\n            let to = el.items!.filter(a => a.gapType === 'add');\n            let segs: React.ReactNode[] = [];\n            for (let i = 0; i < from.length; i++) {\n                let fromItem = from[i];\n                let toItem = to[i];\n                let fromY = fromItem.posPx!.y + 0.25 * fromItem.sizePx!.y;\n                let toY = toItem.posPx!.y + toItem.sizePx!.y / 2;\n                let fromX = fromItem.posPx!.x + fromItem.sizePx!.x;\n                let toX = toItem.posPx!.x + 8;\n                let xVert = size.x - 10;\n                let path = `M${fromX},${fromY} L${xVert},${fromY} L${xVert},${toY} L${toX+4},${toY}`;\n                segs.push(<path key={i} d={path} fill='none' strokeLinejoin='round' opacity={opacityDimmed} className={s.dataPath} />);\n                segs.push(renderArrow(new Vec3(toX, toY), new Vec3(toX + 10, toY), `residual-arrow-${i}`));\n            }\n            return segs;\n        }\n\n        let isHover = elIsHoveredOrActive(el);\n        let opacityDimmed = isHover === false && (isNotNil(hoverId) || isNotNil(activePhase)) ? 0.5 : 1.0;\n\n        let content: React.ReactNode = null;\n\n        switch (el.type) {\n            case ElType.Cell:\n                let label = Array.isArray(el.label) ? el.label : [el.label];\n\n                content = <>\n                    <rect className={s.cell} width={size.x} height={size.y} fill={el.color ?? '#00000000'} rx={3} ry={3} stroke={stroke} strokeWidth={1} />\n                    {label.map((l, i) => {\n                        return <text key={i} x={size.x / 2} y={(i + 0.75) * sizeScale} width={size.x} fontSize={fontSize} textAnchor='middle'>{l}</text>;\n                    })}\n                </>;\n                break;\n            case ElType.PosEmbed:\n                let center = el.sizePx!.mul(0.5);\n                let embedX = center.x - 40;\n                let textX = embedX - 14;\n\n                content = <>\n                    <line className={s.gap} x1={center.x} x2={center.x} y1={0} y2={size.y} stroke={colors.line} />\n                    <text fontSize={11} textAnchor='end' x={textX} y={center.y + 0.25 * fontSize}>pos embed</text>\n                    <circle cx={embedX} cy={center.y} r={10} stroke={colors.line} fill='none' />;\n                    <line x1={embedX + 14} x2={center.x - 10} y1={center.y} y2={center.y} stroke={colors.line} strokeWidth={1} />;\n                    <text textAnchor='middle' x={embedX} y={center.y + 5} fontSize={18}>~</text>\n                    {renderArrow(new Vec3(center.x - 8, center.y), new Vec3(center.x - 12, center.y), 'posEmbedArrow')}\n                    {renderPlus(center, 'posEmbed')}\n                </>;\n                break;\n            case ElType.Block:\n                let dashArray = el.special === 'llm' ? '2 2' : undefined;\n                content = <>\n                    <rect className={s.block} width={size.x} height={size.y} fill={el.color ?? '#000000'} rx={3} ry={3} strokeDasharray={dashArray} stroke={stroke} />\n                    {el.items!.map((item, i) => renderEl(item, i))}\n                    {renderResiduals()}\n                    {el.special === 'transformer' && <text fontSize={13} textAnchor='start' x={4} y={14} fill={'#555'}>transformer i</text>}\n                    {el.special === 'llm' && <text fontSize={13} textAnchor='start' x={4} y={14} fill={'#333'}>LLM</text>}\n                </>;\n                opacityDimmed = 1.0;\n                break;\n            case ElType.Gap:\n                function renderMultihead(xPos: number) {\n                    let topY = Math.round(0.3 * size.y);\n                    let path = `M${size.x/2},${topY} L${xPos},${topY} L${xPos},${size.y - 2}`;\n                    return <>\n                        <path d={path} stroke={'black'} fill='none' className={s.dataPath} />\n                        {renderArrow(new Vec3(xPos, size.y), new Vec3(xPos, size.y-10), 'multihead-arrow')}\n                    </>;\n                }\n\n                content = <>\n                    <line className={s.gap} x1={0} y1={0} x2={0} y2={size.y} stroke={'black'} />\n                    {el.gapType === 'add' && renderPlus(new Vec3(size.x / 2, size.y / 2), 'add')}\n                    {el.arrow && renderArrow(new Vec3(size.x / 2, size.y), new Vec3(size.x / 2, 0), '0')}\n                    {el.gapType === 'multihead' && <>{renderMultihead(size.x / 2 - 30)}{renderMultihead(size.x / 2 + 30)}</>}\n                </>;\n                break;\n        }\n\n        return <g key={idx} transform={transform} opacity={opacityDimmed}>\n            {content}\n        </g>;\n    }\n\n    function renderExampleText() {\n        if (!canvas) {\n            return null;\n        }\n        let ctx = canvas.getContext('2d')!;\n        ctx.font = '16px Merriweather';\n\n        let textSegs = ['How', ' to', ' predict'];\n        let ids = [2437, 284, 4331];\n\n        let colors = [\n            'rgba(107,64,216,.3)',\n            'rgba(104,222,122,.4)',\n            'rgba(244,172,54,.4)',\n            'rgba(239,65,70,.4)',\n            'rgba(39,181,234,.4)',\n        ];\n\n\n        let widths: number[] = [];\n        let offsets = [0];\n        for (let seg of textSegs) {\n            widths.push(ctx.measureText(seg).width + 1);\n            offsets.push(offsets[offsets.length - 1] + widths[widths.length - 1]);\n        }\n\n        let egTextSegs = [' text', ' tokens', ' words'];\n        let egPct = [0.8, 0.5, 0.3];\n        let egIds = [2420, 16326, 2456];\n        let egWidths = egTextSegs.map(seg => ctx.measureText(seg).width + 1);\n\n        let egColor = colors[widths.length];\n        let egPosX = offsets[offsets.length - 1];\n        let egMaxWidth = Math.max(...egWidths);\n        let egTopY = -10;\n        let egIdWidth = 28;\n\n        let totalWidth = egPosX + egMaxWidth + egIdWidth + 6;\n        let x = structure.sizePx!.x / 2 - totalWidth / 2 + 20.5;\n        let y = 20;\n\n        let node = <g transform={`translate(${x} ${y})`}>\n            {textSegs.map((seg, i) => {\n                return <React.Fragment key={i}>\n                    <rect x={offsets[i]} y={0} width={widths[i] + 1} height={20} fill={colors[i]} />\n                    <text x={offsets[i]} y={16} fontSize={14}>{seg.replaceAll(' ', '\\xa0')}</text>\n                    <text x={offsets[i] + widths[i] / 2} y={30} fontSize={9} textAnchor='middle' fill={'#338a'}>{ids[i]}</text>\n                </React.Fragment>;\n            })}\n            {egTextSegs.map((seg, i) => {\n                return <React.Fragment key={i}>\n                    <rect x={egPosX} y={egTopY + 20 * i} width={egWidths[i] + 1} height={20} fill={egColor} />\n                    <text x={egPosX} y={egTopY + 20 * i + 16} fontSize={12} fillOpacity={egPct[i]}>{seg.replaceAll(' ', '\\xa0')}</text>\n                    <text x={egPosX + egMaxWidth + egIdWidth} y={egTopY + 20 * i + 13} fontSize={9} textAnchor='end' fill={'#338a'}>{egIds[i]}</text>\n                </React.Fragment>;\n            })}\n            <rect x={egPosX+1} y={egTopY+1} width={egMaxWidth + egIdWidth + 4} height={20 * egTextSegs.length - 2} fill={'none'} stroke={egColor} strokeDasharray={'4,4'} />\n        </g>;\n\n        return {\n            node,\n            inputPos: new Vec3(x, y + 40),\n            inputWidth: egPosX,\n            outputPos: new Vec3(x + egPosX, y + egTopY + 20 * egTextSegs.length + 2),\n            outputWidth: egMaxWidth + egIdWidth + 4,\n        };\n    }\n\n    let exampleInfo = renderExampleText();\n\n    function renderInputLines() {\n        let target = findByIdBounds('tokEmbed');\n        if (!exampleInfo || !target) {\n            return null;\n        }\n\n        let insetMain = 4;\n        let inset = 4;\n\n        let left = exampleInfo.inputPos.x + insetMain;\n        let right = exampleInfo.inputPos.x + exampleInfo.inputWidth - insetMain;\n        let top = Math.round(exampleInfo.inputPos.y);\n        let bot = top + 10;\n        let path = `M${left},${top} L${left + inset},${bot} L${right - inset},${bot} L${right},${top}`;\n        let center = (left + right) / 2;\n        let endPt = new Vec3(target.center().x, target.min.y);\n        let horizY = endPt.y - 10;\n\n        let path2 = `M${center},${bot} L${center},${horizY} L${endPt.x},${horizY} L${endPt.x},${endPt.y - 2}`;\n\n        return <>\n            <path d={path + path2} className={s.dataPath} />\n            {renderArrow(endPt, new Vec3(endPt.x, endPt.y - 10), 'multihead-arrow')}\n        </>;\n    }\n\n    function renderOutputLine() {\n        let softmaxOut = findByIdBounds('softmaxOut');\n        let llmTarget = findByIdBounds('llm');\n        if (!exampleInfo || !softmaxOut || !llmTarget) {\n            return null;\n        }\n\n        let startPt = new Vec3(softmaxOut.center().x, softmaxOut.max.y);\n        let botY = startPt.y + 10;\n        let rightX = llmTarget.max.x - 10;\n        let topY = llmTarget.min.y + 10;\n        let endPt = new Vec3(exampleInfo.outputPos.x + exampleInfo.outputWidth / 2, exampleInfo.outputPos.y);\n\n        let path = `M${startPt.x},${startPt.y} L${startPt.x},${botY} L${rightX},${botY} L${rightX},${topY} L${endPt.x},${topY} L${endPt.x},${endPt.y + 2}`;\n\n        return <>\n            <path d={path} className={s.dataPath} />\n            {renderArrow(endPt, new Vec3(endPt.x, endPt.y + 10), 'multihead-arrow')}\n        </>;\n    }\n\n    function getFocusBounds(entry: IEntryInfo): BoundingBox3d[] {\n        let idBounds = entry.ids.map(findByIdBounds).filter(isNotNil);\n\n        if (entry.groupIds) {\n            let box = new BoundingBox3d();\n            idBounds.forEach(b => box.combineInPlace(b));\n            return [box];\n        } else {\n            return idBounds;\n        }\n    }\n\n    function renderFocusBoxes() {\n        let focusId = hoverId ?? activeId;\n        let hoverEntry = entries.find(e => e.id === focusId);\n        return hoverEntry ? getFocusBounds(hoverEntry).map((bb, i) => renderFocusBox(bb, i)) : [];\n    }\n\n    function renderFocusBox(bb: BoundingBox3d, i: number) {\n        let innerPad = new Vec3(4, 4);\n        let tl = bb.min.sub(innerPad);\n        let br = bb.max.add(innerPad);\n        let pad = 30;\n\n        let color = colors.focus;\n\n        return <React.Fragment key={i}>\n            <defs>\n                <mask id={\"hole\" + i}>\n                    <rect x={tl.x - pad} y={tl.y - pad} width={br.x - tl.x + 2 * pad} height={br.y - tl.y + 2 * pad} fill={'white'} />\n                    <rect x={tl.x} y={tl.y} width={br.x - tl.x} height={br.y - tl.y} fill=\"black\"/>\n                </mask>\n            </defs>\n            <rect x={tl.x} y={tl.y} width={br.x - tl.x} height={br.y - tl.y} fill={color}\n                mask={`url(#hole${i})`}\n                style={{ filter: `drop-shadow(0px 0px 5px ${color})`}}\n                />\n            <rect x={tl.x} y={tl.y} width={br.x - tl.x} height={br.y - tl.y} fill={'none'} stroke={'#338a'} strokeWidth={2} strokeDasharray={'8,4'} />\n        </React.Fragment>;\n    }\n\n    function renderTocToDigramLines() {\n        if (!diagramEl) {\n            return null;\n        }\n\n        let svgRect = diagramEl.getBoundingClientRect();\n\n        let offsetLeft = getElGlobalBounds(structure, new Vec3(0, 0)).max.x + 10;\n        let offsetInc = 4;\n        let i = 0;\n        let result: React.ReactNode[] = [];\n\n        for (let entry of entries) {\n            let phase = entry.id;\n            let tocEl = entryManager.entries.get(phase);\n            if (!tocEl) {\n                continue;\n            }\n            let tocRect = tocEl.getBoundingClientRect();\n\n            let endPt = new Vec3(tocRect.left - svgRect.left - 4, tocRect.top - svgRect.top + tocRect.height / 2);\n\n            let allBounds = getFocusBounds(entry);\n\n            if (allBounds.length === 0) {\n                continue;\n            }\n\n            let yPts = [...allBounds.map(b => b.center().y), endPt.y];\n            let minY = Math.min(...yPts);\n            let maxY = Math.max(...yPts);\n            let midX = offsetLeft;\n            let mainPath = `M${midX},${minY} L${midX},${maxY} M${midX},${endPt.y} L${endPt.x},${endPt.y}`;\n            let isFocusEntry = hoverId ? entry.id === hoverId : entry.id === activeId;\n            let opacity = isFocusEntry ? 1.0 : 0.1;\n\n            let pathOpts = () => {\n                return { stroke: colors.focus, strokeWidth: 1, fill: 'none', strokeOpacity: opacity };\n            }\n\n            result.push(<path key={i++} {...pathOpts()} d={mainPath} />);\n\n            for (let bound of getFocusBounds(entry)) {\n                let startPt = new Vec3(bound.max.x + 8, bound.center().y);\n                let path = `M${startPt.x},${startPt.y} L${midX},${startPt.y}`;\n                result.push(<path key={i++} {...pathOpts()} d={path} />);\n            }\n\n            offsetLeft += offsetInc;\n        }\n\n        return result;\n    }\n\n    let height = getElGlobalBounds(structure, new Vec3(0, 0))!.max.y + 10;\n\n    let titleAbove = false;\n\n    return <div>\n        {titleAbove && <div className={s.tocTitle}>Table of Contents</div>}\n        <div className={s.tocDiagram}>\n            <svg viewBox={`0 0 310 ${height}`} width={'310px'} height={height} ref={setDiagramEl}>\n                {exampleInfo?.node}\n                {renderEl(structure, 0)}\n                {renderInputLines()}\n                {renderOutputLine()}\n                {renderFocusBoxes()}\n                {renderTocToDigramLines()}\n            </svg>\n            <div className={s.toc}>\n                {!titleAbove && <div className={s.tocTitle}>Table of Contents</div>}\n                {entryGroups.map((group, i) => {\n\n                    return <React.Fragment key={i}>\n                        <div className={s.tocGroupTitle}>{group.groupName}</div>\n                        {group.entries.map((entry, j) => {\n                            return <MenuEntry\n                                key={j}\n                                entryManager={entryManager}\n                                title={entry.title}\n                                id={entry.id}\n                                active={entry.id === activeId}\n                                hover={entry.id === hoverId}\n                                setHover={setHover}\n                                setActive={setActive}\n                            />;\n                        })}\n                </React.Fragment>;\n                })}\n            </div>\n        </div>\n    </div>;\n};\n\nclass EntryManager {\n    subscriptions = new Subscriptions();\n    entries = new Map<Phase, HTMLDivElement | null>();\n    setEl(id: Phase, ref: HTMLDivElement | null) {\n        if (ref) {\n            this.entries.set(id, ref);\n            return () => {\n                this.entries.delete(id);\n            }\n        } else {\n            this.entries.delete(id);\n        }\n    }\n}\n\nexport const MenuEntry: React.FC<{\n    entryManager: EntryManager,\n    title: string,\n    id: Phase,\n    active: boolean,\n    hover: boolean,\n    setHover: (ev: React.MouseEvent, id: Phase, hover: boolean) => void,\n    setActive: (ev: React.MouseEvent, id: Phase, active: boolean) => void,\n}> = memo(function MenuEntry({ entryManager, id, title, active, hover, setHover, setActive }) {\n\n    let setDivRef = useCallback((div: HTMLDivElement | null) => {\n        entryManager.setEl(id, div);\n    }, [entryManager, id]);\n\n\n    function handleClick(ev: React.MouseEvent) {\n        setActive(ev, id, !active);\n    }\n\n    function handleHover(ev: React.MouseEvent, hover: boolean) {\n        setHover(ev, id, hover);\n    }\n\n    return <div\n        ref={setDivRef}\n        className={clsx(\"cursor-pointer p-1 pl-3 \" + s.menuEntry, active && \"bg-blue-200\", hover && \"bg-blue-800 text-white\")}\n        onClick={handleClick}\n        onMouseEnter={ev => handleHover(ev, true)}\n        onMouseLeave={ev => handleHover(ev, false)}\n    >\n        {title}\n    </div>;\n});\n","import React, { ReactNode, isValidElement, useEffect, useLayoutEffect, useMemo, useRef, useState } from 'react';\nimport s from './Commentary.module.scss';\nimport { PhaseTimelineHoriz } from './PhaseTimeline';\nimport { useProgramState } from './Sidebar';\nimport { clamp } from '@/src/utils/data';\nimport { lerp, lerpSmoothstep } from '@/src/utils/math';\nimport { phaseToGroup, IWalkthrough, Phase } from './walkthrough/Walkthrough';\nimport { eventEndTime, ICommentary, isCommentary, ITimeInfo } from './walkthrough/WalkthroughTools';\nimport { FontAwesomeIcon } from '@fortawesome/react-fontawesome';\nimport { faArrowDown, faChevronLeft, faChevronRight, faPause, faPlay } from '@fortawesome/free-solid-svg-icons';\nimport clsx from 'clsx';\nimport { TocDiagram } from './components/TocDiagram';\nimport { BlockText, DimensionText } from './components/CommentaryHelpers';\nimport { useRequestAnimationFrame } from '../utils/hooks';\n\nexport function jumpToPhase(wt: IWalkthrough, phaseId: Phase) {\n    wt.time = 0;\n    wt.phase = phaseId;\n    wt.running = false;\n    wt.markDirty();\n}\n\nexport function jumpPhase(wt: IWalkthrough, phaseDelta: number) {\n    let group = phaseToGroup(wt);\n    let groupIdx = wt.phaseList.indexOf(group);\n    let phaseGroupIdx = group.phases.findIndex(p => p.id === wt.phase);\n    let newPhaseGroupIdx = phaseGroupIdx + phaseDelta;\n\n    if (newPhaseGroupIdx < 0) {\n        if (groupIdx > 0) {\n            let newGroup = wt.phaseList[groupIdx - 1];\n            wt.phase = newGroup.phases[newGroup.phases.length - 1].id;\n        }\n    } else if (newPhaseGroupIdx >= group.phases.length) {\n        if (groupIdx < wt.phaseList.length - 1) {\n            let newGroup = wt.phaseList[groupIdx + 1];\n            wt.phase = newGroup.phases[0].id;\n        }\n    } else {\n        wt.phase = group.phases[newPhaseGroupIdx].id;\n    }\n\n    console.log(`new phase is ${Phase[wt.phase]}`);\n\n    wt.time = 0;\n    wt.running = false;\n}\n\nexport const Commentary: React.FC = () => {\n    let progState = useProgramState();\n    let [parasEl, setParasEl] = React.useState<HTMLDivElement | null>(null);\n    // let [rangeInfo, setRangeInfo] = React.useState<{ start: number, end: number, width: number }>({ start: 0, end: 0, width: 1 });\n    let wt = progState.walkthrough;\n\n    function handleKeyDown(ev: React.KeyboardEvent) {\n        if (ev.key === ' ') {\n            ev.preventDefault(); // prevent scrolling\n        }\n    }\n\n    function handleContinueClick() {\n        if (wt.time >= wt.phaseLength) {\n            jumpPhase(wt, 1);\n            wt.time = 0;\n        } else {\n            wt.running = !wt.running;\n        }\n        progState.markDirty();\n    }\n\n    function handleAdvanceClick() {\n        if (wt.time >= wt.phaseLength) {\n            jumpPhase(wt, 1);\n            wt.time = 0;\n        } else {\n            wt.running = true;\n            let node = nodes.find(n => n.end > wt.time);\n            let speed = 15;\n            if (node) {\n                if (node.end > wt.time) {\n                    speed = (node.end - wt.time) * 2;\n                }\n            }\n            wt.speed = speed;\n        }\n        progState.markDirty();\n    }\n\n    function handlePhaseDeltaClick(delta: number) {\n        jumpPhase(wt, delta);\n        progState.markDirty();\n    }\n\n    let numTimes = wt.times.length;\n\n    let { nodes } = useMemo(() => {\n        let nodes: INode[] = [];\n        let prevIsTime = false;\n        for (let c of wt.times) {\n            if (isCommentary(c)) {\n                nodes.push({ commentary: c, isBreak: false, start: c.start, end: eventEndTime(c) });\n                prevIsTime = false;\n            } else {\n                !prevIsTime && nodes.push({ times: [], isBreak: false, start: c.start, end: c.start });\n                let lastNode = nodes[nodes.length - 1];\n                lastNode.times!.push(c);\n                lastNode.isBreak ||= !!c.isBreak;\n                lastNode.end = eventEndTime(c);\n                prevIsTime = true;\n            }\n        }\n        return { nodes };\n    }, [wt.times]);\n\n    let { prevBreak, nextBreak } = useMemo(() => {\n        let prevBreak = -1;\n        let nextBreak = -1;\n        let lastBreak = -1;\n        for (let i = 0; i < nodes.length + 1; i++) {\n            let node = nodes[i];\n            if (node?.isBreak || i === nodes.length) {\n                if (i === nodes.length || node.start >= wt.time) {\n                    nextBreak = lastBreak - 1;\n                    break;\n                }\n                prevBreak = lastBreak + 1;\n                lastBreak = i;\n            }\n        }\n        return { prevBreak, nextBreak };\n    }, [wt.time, nodes]);\n\n    interface IGuideLayout {\n        width: number;\n        height: number;\n        parentHeight: number;\n        childRanges: IChildRange[];\n    }\n\n    interface IChildRange {\n        top: number;\n        bottom: number;\n        height: number;\n        nodeId: number;\n        startT: number;\n        endT: number;\n    }\n\n    let [guideLayout, setGuideLayout] = useState<IGuideLayout>({ width: 0, height: 0, parentHeight: 0, childRanges: [] });\n\n    useLayoutEffect(() => {\n\n        function handleChildren() {\n            if (!parasEl?.children) return;\n\n            let parasBcr = parasEl.getBoundingClientRect();\n\n            let ranges: IChildRange[] = [];\n\n            for (let child of parasEl.children) {\n                let nid = parseInt(child.getAttribute('data-nid')!);\n                let c = nodes[nid];\n                if (!c) {\n                    continue;\n                }\n                let cStart = c.commentary?.start ?? c.times![0].start;\n                let cEnd = eventEndTime(c.commentary ?? c.times![c.times!.length - 1]);\n                let childBcr = child.getBoundingClientRect();\n\n                ranges.push({ top: childBcr.top - parasBcr.top, bottom: childBcr.bottom - parasBcr.top, nodeId: nid, startT: cStart, endT: cEnd, height: childBcr.height });\n            }\n            // console.log('handling resize event (or first time)', parasBcr.height);\n            setGuideLayout({\n                width: parasBcr.width - 40,\n                height: parasBcr.height,\n                parentHeight: parasEl.parentElement!.getBoundingClientRect().height,\n                childRanges: ranges,\n            });\n        }\n\n        if (parasEl) {\n            let observer = new ResizeObserver(handleChildren);\n            observer.observe(parasEl);\n            observer.observe(parasEl.parentElement!);\n            return () => {\n                observer.disconnect();\n            };\n        }\n\n    }, [nodes, parasEl, wt.phase, numTimes]);\n\n    interface IRangeInfo {\n        start: number;\n        end: number;\n        width: number;\n    }\n\n    let { rangeInfo, currPos } = useMemo(() => {\n        let rangeInfo: IRangeInfo = { start: 0, end: 0, width: 1 };\n        let currPos = 0;\n\n        for (let range of guideLayout.childRanges) {\n            if (range.startT <= wt.time && range.endT >= wt.time) {\n                currPos = range.bottom;\n                break;\n            }\n        }\n\n        let startPos = 0;\n        let endPos = 0;\n\n        function findChild(nid: number) {\n            return guideLayout.childRanges.find(c => c.nodeId === nid);\n        }\n\n        if (nodes.length > 0) {\n            let child = findChild(Math.max(0, prevBreak))!;\n            if (child) {\n                startPos = child.top;\n            }\n        }\n        if (nextBreak >= 0) {\n            let child = findChild(nextBreak)!;\n            if (child) {\n                endPos = child.bottom;\n            }\n        }\n\n        rangeInfo = { start: startPos, end: endPos, width: guideLayout.width };\n        return { rangeInfo, currPos };\n    }, [wt.time, guideLayout, nodes, prevBreak, nextBreak]);\n\n    let group = phaseToGroup(wt);\n    let phase = group?.phases.find(p => p.id === wt.phase)!;\n\n    // fast-scroll to top whenever phase changes (and then we'll scroll down smoothly as below)\n    useEffect(() => {\n        if (parasEl) {\n            parasEl.parentElement!.scrollTop = 0;\n        }\n    }, [parasEl, wt.phase]);\n\n    let prevPhase = useRef(-1);\n    let upToDate = wt.commentary?.commentaryList.length ?? 0 > 0;\n    // scroll to current position whenever it changes (rangeInfo.start)\n    useEffect(() => {\n        if (parasEl) { // && parasEl.parentElement!.getBoundingClientRect().height === guideLayout.parentHeight) {\n            let delta = 512; // parasEl.getBoundingClientRect().top - parasEl.parentElement!.getBoundingClientRect().top - 45;\n\n            if (prevPhase.current !== wt.phase) {\n                // parasEl.parentElement!.scrollTop = rangeInfo.start + delta;\n                prevPhase.current = wt.phase;\n            } else if (wt.time > 0) {\n                parasEl.parentElement!.scrollTo({ top: rangeInfo.start + delta, behavior: 'smooth' });\n            }\n        }\n    }, [rangeInfo.start, rangeInfo.end, currPos, parasEl, upToDate, guideLayout.height, guideLayout.parentHeight, wt.phase, wt.time]);\n\n    return <>\n        <div className={s.chapterControls}>\n            <button className={clsx(s.btn, s.prevNextBtn)} onClick={() => handlePhaseDeltaClick(-1)}>\n                <FontAwesomeIcon icon={faChevronLeft} />\n            </button>\n            <div className={s.chapterTitle}>Chapter: {phase.title}</div>\n            <button className={clsx(s.btn, s.prevNextBtn)} onClick={() => handlePhaseDeltaClick(1)}>\n                <FontAwesomeIcon icon={faChevronRight} />\n            </button>\n        </div>\n        <div className={s.walkthroughViewport}>\n            <div className={s.walkthroughText} tabIndex={0} onKeyDownCapture={handleKeyDown}>\n                <div className={s.tocBackground}>\n                    <TocDiagram activePhase={phase.id} />\n                </div>\n                <div className={s.divider} />\n                <div className={s.walkthroughParas} ref={setParasEl}>\n                    {walkthroughToParagraphs(wt, nodes)}\n                    <SectionHighlight key={nextBreak} top={rangeInfo.start} height={rangeInfo.end - rangeInfo.start} width={rangeInfo.width} />\n                    {!wt.running && <>\n                        <div className={s.dividerLine} style={{ top: currPos }} />\n                        <SpaceToContinueHint top={currPos} onClick={handleContinueClick} />\n                    </>}\n                </div>\n            </div>\n        </div>\n        <div className={s.controls}>\n            <button className={clsx(s.btn, \"flex-[2] bg-blue-300 border border-blue-600 hover:bg-blue-400\")} onClick={handleContinueClick}>\n                <div>Continue</div>\n            </button>\n            <button className={clsx(s.btn, \"ml-4 min-w-[100px] bg-white border border-blue-600 hover:bg-blue-200\")} onClick={handleAdvanceClick}>\n                <div>Skip</div>\n            </button>\n        </div>\n    </>;\n};\n\ninterface INode {\n    commentary?: ICommentary;\n    times?: ITimeInfo[];\n    isBreak: boolean;\n    start: number;\n    end: number;\n}\n\nexport function walkthroughToParagraphs(wt: IWalkthrough, nodes: INode[]) {\n\n    function genCommentary(c: ICommentary, t: number) {\n\n        let keyId = 0;\n        let paraKeyId = 0;\n        let res: React.ReactNode[] = [];\n        let paraItems: ReactNode[] = [];\n\n        function pushParagraph() {\n            if (paraItems.length) {\n                res.push(<p key={keyId++}>{paraItems}</p>);\n                paraItems = [];\n                paraKeyId = 0;\n            }\n        }\n\n        for (let i = 0; i < c.strings.length; i++) {\n\n            let strRaw = c.strings[i];\n            if (strRaw.trim()) {\n                let paras = strRaw.split('\\n\\n');\n                for (let j = 0; j < paras.length; j++) {\n                    let strPart = markupSimple(paras[j]);\n                    if (j > 0) {\n                        pushParagraph();\n                    }\n                    paraItems.push(<React.Fragment key={paraKeyId++}>{strPart}</React.Fragment>);\n                }\n            }\n\n            if (i < c.values.length) {\n                let val = c.values[i];\n                if (isValidElement(val)) {\n                    paraItems.push(<React.Fragment key={paraKeyId++}>{val}</React.Fragment>)\n                }\n                if (val.insertInline) {\n                    paraItems.push(<React.Fragment key={paraKeyId++}>{val.insertInline}</React.Fragment>);\n                }\n                if (val.insert) {\n                    pushParagraph();\n                    let fnVal = typeof val.insert === 'function' ? val.insert() : val.insert;\n                    let el = typeof fnVal === 'string' ? fnVal : React.createElement(fnVal as React.FC, { key: 'i' + i });\n                    res.push(el);\n                }\n                if (val.color) {\n                    let color = val.color.toHexColor();\n                    let content = markupSimple(val.str);\n                    if (val.dim) {\n                        paraItems.push(<DimensionText key={paraKeyId++} style={{ color }} dim={val.dim}>{content}</DimensionText>);\n                    } else if (val.blk) {\n                        paraItems.push(<BlockText key={paraKeyId++} style={{ color }} blk={val.blk}>{content}</BlockText>);\n                    } else {\n                        paraItems.push(<span key={paraKeyId++} style={{ color }}>{content}</span>);\n                    }\n                }\n            }\n        }\n        pushParagraph();\n\n        return res;\n    }\n\n    return <>\n        {nodes.map((n, i) => {\n            if (n.commentary) {\n                let c = n.commentary;\n                let displayFactor = c.duration === 0 ? (wt.time >= c.start ? 1 : 0) : clamp((wt.time - c.start) / c.duration, 0, 1);\n                let opacity = lerp(0.6, 1, displayFactor);\n                let blur = lerp(0, 0, displayFactor);\n                return <div key={i} style={{ opacity, filter: `blur(${blur}px)` }} data-nid={i}>\n                    {genCommentary(c, wt.time)}\n                </div>;\n            } else {\n                let times = n.times!;\n                let active = wt.time >= times[0].start;\n                let inRange = wt.time >= times[0].start && wt.time <= eventEndTime(times[times.length - 1]);\n                let opacity = active ? 1 : 0.6;\n                let blur = 0; // active ? 0 : 2;\n                let showLine = times.length > 1 || !times[0].isBreak;\n\n                function handlePlayPause() {\n                    if (wt.running) {\n                        wt.running = false;\n                        wt.markDirty();\n                    } else {\n                        wt.running = true;\n                        if (!inRange) {\n                            wt.time = times[0].start;\n                        }\n                    }\n                    wt.markDirty();\n                }\n\n                function handleArrowTo() {\n                    if (!inRange) {\n                        wt.time = times[0].start;\n                        wt.markDirty();\n                    }\n                }\n\n                return <div key={i} className={s.commentaryBreak} data-nid={i} style={{ opacity, filter: `blur(${blur}px)` }}>\n                    {showLine && <>\n                        <button className={clsx(s.jump, 'btn')} onClick={handleArrowTo}>\n                            <FontAwesomeIcon icon={faArrowDown} />\n                        </button>\n                        <button className={clsx(s.playPause, 'btn')} onClick={handlePlayPause}>\n                            <FontAwesomeIcon icon={wt.running && inRange ? faPause : faPlay} />\n                        </button>\n                        <PhaseTimelineHoriz times={n.times!} />\n                    </>}\n                </div>;\n            }\n        })}\n    </>;\n}\n\nfunction markupSimple(inputStr: string): React.ReactNode {\n    let italicLocs: number[] = [];\n    let boldLocs: number[] = [];\n\n    let prevC = '';\n    let idx = 0;\n    for (let c of inputStr) {\n        if (c === '_' && ((italicLocs.length % 2) === 1 || !prevC.match(/[a-zA-Z0-9]/))) {\n            italicLocs.push(idx);\n        // } else if (c === '*' && prevC !== '*') {\n        //     boldLocs.push(idx);\n        }\n        prevC = c;\n        idx++;\n    }\n\n    let nodesFlat: INode[] = [];\n    function addNodes(t: INode['t'], locs: number[]) {\n        for (let i = 0; i < Math.ceil(locs.length / 2); i++) {\n            nodesFlat.push({ t: t, start: locs[i * 2], end: (locs[i * 2 + 1] ?? inputStr.length) + 1 });\n        }\n    }\n\n    addNodes('i', italicLocs);\n    addNodes('b', boldLocs);\n\n    interface INode {\n        t: '' | 'b' | 'i';\n        start: number; // inclusive\n        end: number; // exclusive\n        children?: INode[];\n    }\n\n    function insertIntoTree(treeNode: INode, node: INode) {\n        // we know node is fully contained within treeNode. But what about treeNode's children?\n\n        // the children are distinct but form a partial cover of the treeNode\n        let prevEnd = treeNode.start;\n        let currStart = node.start;\n        let directNewChildren: INode[] = [];\n\n        for (let c of treeNode.children ?? []) {\n            if (currStart < c.start) {\n                directNewChildren.push({ ...node, start: currStart, end: c.start });\n                prevEnd = currStart;\n                currStart = c.start;\n            }\n            if (currStart < c.end && node.end > c.start) {\n                insertIntoTree(c, { ...node, start: Math.max(currStart, c.start), end: Math.min(node.end, c.end) });\n                currStart = Math.min(node.end, c.end);\n                prevEnd = node.end;\n            }\n        }\n        if (currStart < node.end) {\n            directNewChildren.push({ ...node, start: currStart, end: node.end });\n        }\n\n        if (directNewChildren.length > 0) {\n            treeNode.children = [...treeNode.children ?? [], ...directNewChildren];\n            treeNode.children.sort((a, b) => a.start - b.start);\n        }\n    }\n\n    let treeBase: INode = { t: '', start: 0, end: inputStr.length, children: [] };\n\n    for (let node of nodesFlat) {\n        insertIntoTree(treeBase, node);\n    }\n\n    function buildReactDom(node: INode, i: number) {\n        let pad = node.t === '' ? 0 : 1;\n        let res: ReactNode[] = [];\n        let children = node.children ?? []\n        let segStart = node.start + pad;\n        for (let i = 0; i < children.length + 1; i++) {\n            let segEnd = i < children.length ? children[i].start : node.end - pad;\n\n            if (segEnd > segStart) {\n                res.push(inputStr.slice(segStart, segEnd));\n            }\n\n            if (i < children.length) {\n                res.push(buildReactDom(children[i], i));\n                segStart = children[i].end;\n            }\n        }\n\n        if (node.t === 'b') {\n            return <b key={i}>{res}</b>;\n        } else if (node.t === 'i') {\n            return <i key={i}>{res}</i>;\n        } else {\n            return res;\n        }\n    }\n\n    return buildReactDom(treeBase, 0);\n}\n\nconst SpaceToContinueHint: React.FC<{\n    top: number;\n    onClick: React.MouseEventHandler,\n}> = ({ top, onClick }) => {\n\n    return <div className={\"absolute flex justify-center pointer-events-none top-0 left-0 right-0\"} style={{ top, transform: `translateY(20px)` }}>\n        <div className={\"flex-shrink py-2 px-4 bg-blue-200 shadow-md rounded-3xl pointer-events-auto text-black cursor-pointer\"} onClick={onClick}>\n             Press <span className={s.key}>Space</span> to continue\n        </div>\n    </div>;\n}\n\nconst SectionHighlight: React.FC<{\n    top: number;\n    height: number;\n    width: number;\n}> = ({ top, height, width }) => {\n    let [tick, setTick] = useState(0);\n\n    useRequestAnimationFrame(tick < 2, (dt) => {\n        setTick(tick + dt);\n    });\n\n    let rectPad = 12;\n    let svgW = width + rectPad * 2;\n    let svgH = height + rectPad * 2;\n\n    let pad = 3;\n    let x0 = pad;\n    let y0 = pad;\n    let x1 = svgW - pad;\n    let y1 = svgH - pad;\n\n    let strokeWidth = lerpSmoothstep(3, 0, tick);\n\n    if (height <= 0) {\n        return null;\n    }\n\n    return <div className={s.sectionHighlightWrap} style={{ top: top - rectPad, height: svgH, width: svgW, left: -rectPad }}>\n        <svg viewBox={`0 0 ${svgW} ${svgH}`} className={s.sectionHighlight}>\n            <rect x={x0} y={y0} width={x1 - x0} height={y1 - y0} fill=\"none\" stroke=\"blue\" strokeWidth={strokeWidth} opacity={strokeWidth} rx={5} ry={5} />\n            {/* <path d={`M ${x0} ${y0} L ${x1} ${y0} L ${x1} ${y1} L ${x0} ${y1} Z`} fill=\"none\" stroke=\"blue\" strokeWidth=\"3\" /> */}\n        </svg>\n    </div>;\n}\n","import s from './Sidebar.module.scss';\nimport React, { createContext, useContext, useState } from 'react';\nimport clsx from 'clsx';\nimport { IPhaseDef } from './walkthrough/WalkthroughSidebarTools';\nimport { PhaseTimeline } from './PhaseTimeline';\nimport { Commentary } from './Commentary';\nimport { IProgramState } from './Program';\nimport { Popup, PopupPos } from '@/src/utils/Portal';\nimport { useSubscriptions } from '../utils/hooks';\n\nexport const WalkthroughSidebar: React.FC = () => {\n    let progState = useProgramState();\n    let walkthrough = progState.walkthrough;\n    let camera = progState.camera;\n    let [menuVisible, setMenuVisible] = useState(false);\n    let [menuButtonEl, setMenuButtonEl] = useState<HTMLElement | null>(null);\n\n    function handlePhaseClick(ev: React.MouseEvent, phase: IPhaseDef) {\n        if (walkthrough.phase !== phase.id) {\n            walkthrough.phase = phase.id;\n            walkthrough.time = 0;\n            walkthrough.running = false;\n            progState.markDirty();\n        }\n        setMenuVisible(false);\n        ev.preventDefault();\n    }\n\n    function stepModel() {\n        console.log('stepping model');\n        progState.stepModel = true;\n        progState.markDirty();\n    }\n\n    let menu = <>\n        <div className={s.topSplit}>\n            <div className={s.toc}>\n                {walkthrough.phaseList.map((group, i) => {\n\n                    return <div key={group.groupId} className={s.phaseGroup}>\n                        <div className={s.phaseGroupTitle}>{group.title}</div>\n\n                        {group.phases.map((phase, j) => {\n                            let active = walkthrough.phase === phase.id;\n\n                            return <div key={phase.id} className={clsx(s.phase, active && s.active)} onClick={ev => handlePhaseClick(ev, phase)}>\n                                <div className={s.phaseTitle}>{phase.title}</div>\n                            </div>;\n                        })}\n                    </div>;\n                })}\n            </div>\n            {/* <div className={s.helpers}>\n                <div className={s.camStats}>\n                    (center, center) =\n                </div>\n                <div className={s.camStats}>\n                    new {camera.center.toString(1)}, new {camera.angle.toString(1)}\n                </div>\n            </div> */}\n        </div>\n    </>;\n\n    return <div className={s.walkthrough}>\n        <div className={s.split}>\n\n            <div className={s.timelineLeft}>\n                <PhaseTimeline />\n            </div>\n\n            <div className={s.content}>\n                {/* <div className={s.menuTopBar}>\n                    <div className={s.menu} ref={setMenuButtonEl} onClick={() => setMenuVisible(a => !a)}>Menu &gt;</div>\n                    {menuVisible && <Popup targetEl={menuButtonEl} placement={PopupPos.BottomLeft} className={s.mainMenu} closeBackdrop onClose={() => setMenuVisible(false)}>\n                        {menu}\n                    </Popup>}\n                    <div onClick={() => stepModel()}>Step</div>\n                </div> */}\n                <Commentary />\n            </div>\n\n        </div>\n    </div>;\n};\n\nexport let ProgramStateContext = createContext<IProgramState>(null!);\n\nexport function useProgramState() {\n    let context = useContext(ProgramStateContext);\n    useSubscriptions(context?.htmlSubs);\n    return context;\n}\n","import { IBlockLayerLink, IGptModelLink, ILayerNormLayerLink, IModelShape } from \"./GptModel\";\nimport { isNil } from \"@/src/utils/data\";\nimport { Mat4f } from \"@/src/utils/matrix\";\nimport { Dim, Vec3 } from \"@/src/utils/vector\";\nimport { IBufferTex } from \"@/src/utils/renderPhases\";\nimport { dimProps } from \"./Annotations\";\nimport { DimStyle } from \"./walkthrough/WalkthroughTools\";\nimport { IProgramState } from \"./Program\";\nimport { list } from \"postcss\";\n\nexport interface IBlkDef {\n    idx: number; // index in the layout.cubes array\n    t: 'w' | 'i' | 'a', // weights; intermediate value; aggregate (just LN & softmax)\n    x: number;\n    y: number;\n    z: number;\n    dx: number; // units: model-space\n    dy: number;\n    dz: number;\n    cx: number; // units: number of cells\n    cy: number;\n    cz: number;\n    access?: IBlkAccess;\n    deps?: IBlkDeps;\n    meinsumResult?: IBlkMeinsumResult;\n    dimX: DimStyle;\n    dimY: DimStyle;\n    name: string;\n    small: boolean; // small enough to not be worth rendering in large models\n    // implicit dimZ = DimStyle.Batch for t === 'i'\n\n    // fields that are post-added by the walk-through for various rendering configurations\n\n    localMtx?: Mat4f; // for creating blocks that are sub-parts of a block\n    // what to do for different axes?\n    rangeOffsetsX?: [number, number][]; // if this block has been split, map from [[s0, xOff], [s1, xOff], ...] to the original block\n    rangeOffsetsY?: [number, number][];\n    rangeOffsetsZ?: [number, number][];\n    highlight: number; // 0 - 1 (0 = no highlight, 1 = full highlight)\n    opacity: number; // 0 - 1 (0 = transparent, 1 = opaque)\n    special: BlkSpecial;\n    transpose?: boolean; // transpose the process direction\n    subs?: IBlkDef[]; // substitutes for this block (i.e. render these instead)\n    offX?: number; // offset from the original block\n    offY?: number;\n    offZ?: number;\n    sizeX?: number; // size of the sub block\n    sizeY?: number;\n    sizeZ?: number;\n}\n\nexport enum BlkSpecial {\n    None,\n    Attention,\n}\n\n// define how a cell is computed from other blocks\n// matrix-mulplication: cell(x, y, b) = sum_i(A[i, y] * B[x, i, b]) + C[0, y]\nexport interface IBlkDeps {\n    dot?: [IBlkCellDep, IBlkCellDep];\n    dotLen?: number;\n    add?: IBlkCellDep[];\n    special: BlKDepSpecial;\n    lowerTri?: boolean;\n}\n\nexport interface IBlkCellDep {\n    src: IBlkDef;\n    srcIdxMtx: Mat4f; // inputs: [x, y, b, [i]], outputs: [x, y, b]\n}\n\ninterface IBlkDepArgs {\n    dot?: [[IBlkDef, string], [IBlkDef, string]];\n    dotLen?: number;\n    add?: [IBlkDef, string][];\n    lowerTri?: boolean; // only use the lower triangle of the matrix (causal attention matrices)\n    special?: BlKDepSpecial;\n}\n\nexport interface IBlkMeinsumResult {\n    loopString: string | undefined\n}\n\nexport enum BlKDepSpecial {\n    None,\n    Softmax,\n    Gelu,\n    LayerNorm,\n    InputEmbed,\n    LayerNormMu,\n    LayerNormSigma,\n    SoftmaxAggMax,\n    SoftmaxAggExp,\n    Attention,\n}\n\nlet depIdxVars = '0xybi';\nfunction parseDepIdxStr(str: string): Mat4f {\n    let mtx = Mat4f.zeros();\n    for (let destI = 0; destI < str.length; destI++) {\n        let srcIdx = depIdxVars.indexOf(str[destI]);\n        if (srcIdx > 0) {\n            mtx.s(destI, srcIdx - 1, 1.0);\n        }\n    }\n    return mtx;\n}\n\nfunction depArgsToDeps(args: IBlkDepArgs): IBlkDeps {\n    let makeBlkDeps = (src: IBlkDef, depStr: string) => ({ src, srcIdxMtx: parseDepIdxStr(depStr) });\n    return {\n        dot: args.dot && args.dot.map(([src, depStr]) => makeBlkDeps(src, depStr)) as [IBlkCellDep, IBlkCellDep],\n        dotLen: args.dotLen,\n        add: args.add && args.add.map(([src, depStr]) => makeBlkDeps(src, depStr)),\n        special: args.special ?? BlKDepSpecial.None,\n        lowerTri: args.lowerTri,\n    };\n}\n\nexport function getBlkDimensions(blk: IBlkDef) {\n    let { x, y, z, dx, dy, dz } = blk;\n    return {\n        tl: new Vec3(x, y, z),\n        br: new Vec3(x + dx, y + dy, z + dz),\n    };\n}\n\nexport function setBlkPosition(blk: IBlkDef, pos: Vec3) {\n    blk.x = pos.x;\n    blk.y = pos.y;\n    blk.z = pos.z;\n}\n\nexport interface IBlkAccess {\n    src: IBufferTex;\n    channel: 'r' | 'g' | 'b';\n    scale: number;\n    mat: Mat4f; // actually using the first two columns for a 3x2 matrix: mapping (x, y, z) integer cell coord to (x, y) src tex coord\n    disable?: boolean;\n}\n\ninterface IBlkAccessDefArgs {\n    src?: IBufferTex;\n    channel?: 'r' | 'g' | 'b';\n    scale?: number;\n    x: number[];\n    y: number[];\n}\n\ninterface IBlkDefArgs {\n    t: 'w' | 'i' | 'a', // weights; intermediate value\n    xL?: number; // pos of Left edge\n    xR?: number; // Right\n    xM?: number; // Middle\n    zF?: number; // Front\n    zB?: number; // Back\n    zM?: number; // Middle\n    name?: string;\n    y: number;\n    cx: number; // units: number of cells\n    cz: number;\n    cy: number;\n    dimX: DimStyle;\n    dimY: DimStyle;\n    special?: BlkSpecial;\n    access?: IBlkAccessDefArgs;\n    deps?: IBlkDepArgs;\n    meinsumResult?: IBlkMeinsumResult;\n    small?: boolean;\n    hidden?: boolean;\n    transpose?: boolean;\n}\n\nexport interface IBlkLabel {\n    visible: number;\n    cubes: IBlkDef[];\n}\n\nexport interface IModelLayout {\n    cell: number;\n    height: number;\n    margin: number;\n    cubes: IBlkDef[];\n}\n\n\ninterface IBlockDescription {\n    frontUpLeft: Vec3,\n    frontDownLeft: Vec3,\n    frontUpRight: Vec3,\n    rearUpLeft: Vec3\n}\n\ninterface ICubeDescription {\n    coords: Vec3,\n    cx: number,\n    cy: number\n}\n\ninterface ITensorBlock {\n    cubes: ICubeDescription[],\n    blockDescription: IBlockDescription\n}\n\nfunction get_pad_lvl(n_dims: number): number {\n    //     3 -> 0\n    // 4,5,6 -> 1\n    // 7,8,9 -> 2\n    // ...\n    return Math.ceil(n_dims / 3) - 1\n}\n\nlet cell = 1.5;\nlet margin = 10;\nlet pad_lvl0 = 5;\nlet pad_multiplier = 3; // pad at lvl n = pad_lvl0*pad_multiplier^n\n\n\nfunction generateTensor(dims: number[], start: Vec3 = new Vec3(),): ITensorBlock {\n    if (!dims) return generateTensor([1, 1], start);\n    const n_dims = dims.length;\n\n    if (n_dims == 0) return generateTensor([1, 1], start);\n    if (n_dims == 1) return generateTensor([dims[0], 1], start);\n\n    if (n_dims == 2) {\n        const [M, N] = dims;\n\n        const cubes = [{\n            coords: start,\n            cy: M,\n            cx: N,\n        }];\n\n        const blockDescription = {\n            frontUpLeft: start,\n            frontDownLeft: start.add(new Vec3(0, M)),\n            frontUpRight: start.add(new Vec3(N)),\n            rearUpLeft: start.add(new Vec3(0, 0, -1))\n        }\n        return {\n            cubes,\n            blockDescription,\n        }\n    }\n\n    // recursive step\n    const dimN = dims[0];\n    const dimsNminusOne = dims.slice(1);\n\n    let cubes: any[] = [];\n\n    let blockStart = start.clone();\n\n    // do padding;\n    /*\n    we have axis rotation: \n        - 3rd dim along z axis | pad_lvl 0\n        * UPGRADE padding..\n        - 4th dim along y axis | pad_lvl 1\n        - 5th dim along x axis | pad_lvl 1\n        - 6th dim along z axis | pad_lvl 1\n        * UPGRADE padding..\n        - 7th dim along y axis | pad_lvl 2\n        ...\n    */\n\n\n    const pad_lvl = get_pad_lvl(n_dims);\n    const pad = pad_lvl0 * Math.pow(pad_multiplier, pad_lvl);\n\n    let ourBlockDescr: IBlockDescription = null;\n\n    for (let q = 0; q < dimN; q++) {\n        const block = generateTensor(dimsNminusOne, blockStart);\n        cubes = cubes.concat(block.cubes);\n\n        const d = block.blockDescription;\n\n        if (q == 0) ourBlockDescr = d;\n\n        if (n_dims % 3 == 0) {\n            // move z\n            blockStart = d.rearUpLeft.add(new Vec3(0, 0, -pad));\n            ourBlockDescr.rearUpLeft = d.rearUpLeft;\n        } else if (n_dims % 3 == 2) {\n            // move along x axis\n            blockStart = d.frontUpRight.add(new Vec3(pad));\n            ourBlockDescr.frontUpRight = d.frontUpRight;\n        } else {\n            // move y ax\n            blockStart = d.frontDownLeft.add(new Vec3(0, pad));\n            ourBlockDescr.frontDownLeft = d.frontDownLeft;\n        }\n\n    }\n\n    return {\n        cubes,\n        blockDescription: ourBlockDescr,\n    }\n\n}\n\n\nexport function cellPosition(layout: IModelLayout, blk: IBlkDef, dim: Dim, index: number) {\n    let { x, rangeOffsets } = dimProps(blk, dim);\n    let base = x + layout.cell * index;\n    if (!rangeOffsets) {\n        return base;\n    }\n    for (let [s, xOff] of rangeOffsets!) {\n        if (index < s) {\n            return base + xOff;\n        }\n    }\n    return base;\n}\n\nexport type IGptModelLayout = ReturnType<typeof genEinsumLayout>;\nexport type IGptLayerNormLayout = IGptModelLayout['ln_f'];\n\nexport interface IMeinsumRelation {\n    source: IBlkDef;\n\n}\n\nexport function genEinsumLayout(state: IProgramState, offset: Vec3 = new Vec3(0, 0, 0)) {\n\n    // work our way downwards from the top\n    // x is to the left and right\n    // y is positive going down, and the stack advances down from the top (at (0, 0, 0))\n    // z is coming out of the page\n\n    // a single batch of the residual pathway goes down the x-z plane\n    // weights & off-residual pathways are left & right of the residual pathway (i.e. along x)\n    // those blocks might have y-depth but that's OK: still have space to add batches\n    // x = 0 is just to the left of time-cell t=0\n    function mk(args: IBlkDefArgs): IBlkDef {\n        let xDef = [args.xL, args.xR, args.xM].map(a => +!isNil(a)).reduce((a, b) => a + b, 0);\n        let yDef = [args.zF, args.zB, args.zM].map(a => +!isNil(a)).reduce((a, b) => a + b, 0);\n        if (xDef !== 1 || yDef !== 1) {\n            throw new Error(`Must supply exactly 1 x arg & 1 y arg: ${JSON.stringify(args)}`);\n        }\n        let dx = args.cx * cell;\n        let dy = args.cz * cell;\n        let x = !isNil(args.xL) ? args.xL : !isNil(args.xR) ? args.xR - dx : args.xM! - dx / 2;\n        let z = !isNil(args.zB) ? args.zB : !isNil(args.zF) ? args.zF - dy : args.zM! - dy / 2;\n\n        function ensure4(a: number[]) {\n            return a.length === 4 ? a : [...a, 0];\n        }\n\n        return {\n            dx: args.cx * cell,\n            dy: args.cy * cell,\n            dz: args.cz * cell,\n            t: args.t,\n            x: x,\n            y: args.y,\n            z: z,\n            cx: args.cx,\n            cy: args.cy,\n            cz: args.cz,\n            dimX: args.dimX,\n            dimY: args.dimY,\n            name: args.name ?? \"<unknown>\",\n            access: args.access?.src ? {\n                channel: args.access.channel ?? 'r',\n                src: args.access.src,\n                scale: args.access.scale ?? 1.0,\n                mat: Mat4f.fromColMajor([...ensure4(args.access.x), ...ensure4(args.access.y), 0, 0, 0, 0, 0, 0, 0, 0]),\n            } : undefined,\n            deps: args.deps ? depArgsToDeps(args.deps) : undefined,\n            meinsumResult: args.meinsumResult,\n            opacity: args.hidden ? 0.0 : 1.0,\n            highlight: .0,\n            small: args.small ?? false,\n            special: args.special ?? BlkSpecial.None,\n            transpose: args.transpose,\n            idx: -1,\n        };\n    }\n\n    function mkLabel(init: number, cubes?: IBlkDef[]): IBlkLabel {\n        return { visible: 0, cubes: cubes ?? [] };\n    }\n\n    let cubes: IBlkDef[] = [];\n\n    let cell = 1.5;\n    let margin = 10;\n    let pad_lvl0 = 3;\n    let pad_multiplier = 3; // pad at lvl n = pad_lvl0*pad_multiplier^n\n    let dim3_cell = 0.1;\n\n\n    // const shapes = [[3, 8, 3, 8], [3, 8], [4, 3, 6], [16, 8], [8, 8]];\n    // const shapes = [\n    //     [2, 3, 2, 2, 2, 5, 8, 16],\n    //     [12, 40],\n    //     // [2, 3, 4, 5, 6],\n    // ];\n    const einsumState = state?.einsumStates ? state.einsumStates[state.currentEinsumState].state : null;\n    const operands = einsumState?.operands ? [...einsumState.operands] : [{ name: 'EMPTY', shape: [32, 32] }]; // TODO\n\n    let freeDims;\n    let inputDims;\n    let dimNames = [];\n    if (einsumState?.output) {\n        // console.log('einsumState.output', einsumState.output)\n        operands.push({ ...einsumState.output });\n        console.log(einsumState.output)\n\n        if (Array.isArray(einsumState.output.inputDims)) {\n            freeDims = einsumState.output.freeDims;\n            inputDims = einsumState.output.inputDims;\n\n            dimNames = [...inputDims, freeDims.join('')]\n        }\n\n    }\n\n    let xL = 0;\n    let zF = 0;\n    let y = 0;\n\n    let start_block_at = new Vec3();\n\n    for (let i = 0; i < operands.length; i++) {\n        const dims = operands[i].shape;\n        let meinsumResult: (IBlkMeinsumResult | undefined) = undefined;\n        let deps = null;\n        let idx2deps = null;\n\n        let thisOpDimNames;\n\n        if (dimNames && i < dimNames.length) {\n            thisOpDimNames = dimNames[i];\n            console.log(i, 'thisOpDimNames', thisOpDimNames)\n        }\n\n\n        if (operands.length > 1 && i == operands.length - 1) {\n            const last_cube = cubes[cubes.length - 1]\n            const first_cube = cubes[0]\n            // meinsumResult = { loopString: '3' }\n\n            // deps = { add: [[first_cube, 'xy']] }\n\n            let relmap = operands[i].relmap\n            // let lastMatrixRelmap = relmap.array[relmap.array.length - 1];\n            // for (let d = 1; d < relmap.shape.length - 2; d++) {\n            //     lastMatrixRelmap = lastMatrixRelmap[lastMatrixRelmap.length - 1];\n            // }\n\n            // if (relmap.shape.length )\n            // let lastMatrixRelmap = relmap.array\n\n            // idx2deps = {};\n\n\n\n            // for (let ii = 0; ii < lastMatrixRelmap.length; ii++) {\n            //     idx2deps[ii] = {}\n            //     for (let jj = 0; jj < lastMatrixRelmap[ii].length; jj++) {\n            //         idx2deps[ii][jj] = []\n\n            //         for (let additiveRelation of lastMatrixRelmap[ii][jj]) {\n            //             for (let { operand_i, local_idx } of additiveRelation) {\n            //                 // for (let { operand_i, local_idx } of lastMatrixRelmap[ii][jj]) {\n            //                 // TODO: scale to other dims\n            //                 const dependentCube = cubes[operand_i];\n\n            //                 idx2deps[ii][jj].push({ dependentCube, local_idx })\n            //             }\n            //         }\n            //         // console.log(idx2deps)\n            //     }\n            // }\n\n            // console.log('lastMatrixRelmap.length', lastMatrixRelmap.length, 'lastMatrixRelmap[0].length', lastMatrixRelmap[0].length, 'relmap.shape', relmap.shape, 'idx2deps', idx2deps)\n\n            // console.log('THE RESULT', state.einsumStates[state.currentEinsumState].state.output)\n        };\n\n        let name = operands[i].name;\n\n        if (!name) {\n            name = String.fromCharCode(65 + i) // 'A', 'B', 'C', ...\n        }\n\n        const block = generateTensor(dims, start_block_at);\n\n        const blockCubes = block.cubes.map(c => {\n            const cube = mk({\n                t: 'w',\n                xL: c.coords.x, zF: c.coords.z, y: c.coords.y,\n                cx: c.cx, cz: 1, cy: c.cy,\n                meinsumResult,\n                deps,\n\n                access: { x: [0, 1, 0], y: [1, 0, 0], scale: 10 },\n                dimX: DimStyle.A, dimY: DimStyle.B,\n                name,\n            })\n            // cube.idx2deps = idx2deps;\n            const customDimText: any = {};\n\n            if (thisOpDimNames) {\n                if (thisOpDimNames.length > 0)\n                    customDimText[Dim.X] = thisOpDimNames[thisOpDimNames.length - 1];\n                if (thisOpDimNames.length > 1)\n                    customDimText[Dim.Y] = thisOpDimNames[thisOpDimNames.length - 2];\n\n                if (thisOpDimNames.length == 1) {\n                    customDimText[Dim.Y] = thisOpDimNames[thisOpDimNames.length - 1];\n                    customDimText[Dim.X] = '1';\n                }\n            }\n\n\n            cube.customDimText = customDimText;\n            cubes.push(cube)\n        });\n\n        start_block_at = block.blockDescription.frontUpRight.add(new Vec3(10));\n    }\n\n    // console.log(cubes.map(cu => cu.meinsumResult))\n\n    // let embedLabel = mkLabel(y, cubes);\n\n    for (let i = 0; i < cubes.length; i++) {\n        cubes[i].idx = i;\n    }\n\n    // console.log(cubes[cubes.length - 1])\n\n    return {\n        cubes,\n        cell,\n        margin,\n\n        // embedLabel,\n        height: y,\n        labels: [],\n    };\n}\n","import { IBlkDef, IModelLayout } from \"../GptModelLayout\";\nimport { Mat4f } from \"@/src/utils/matrix\";\nimport { bindFloatAttribs, createFloatBuffer, createShaderProgram, ensureFloatBufferSize, IGLContext, resetFloatBufferMap, uploadFloatBuffer } from \"@/src/utils/shader\";\nimport { Vec3, Vec4 } from \"@/src/utils/vector\";\nimport { Colors } from \"../walkthrough/WalkthroughTools\";\nimport { modelViewUboText, UboBindings } from \"./sharedRender\";\n\n\nexport type IBlockRender = ReturnType<typeof initBlockRender>;\n\nexport function initBlockRender(ctx: IGLContext | null) {\n    if (!ctx) {\n        return null!;\n    }\n    let gl = ctx.gl;\n\n    let blockUboText = /*glsl*/`\n    layout (std140) uniform BlockUbo {\n        uniform vec3 u_offset;\n        uniform vec3 u_size;\n        uniform vec3 u_nCells;\n        uniform mat4 u_localPosMtx;\n        uniform vec4 u_baseColor;\n        uniform float u_highlight;\n    };`;\n\n    let blockAccessUboText = /*glsl*/`\n    layout (std140) uniform BlockAccessUbo {\n        layout(row_major) uniform mat4x2 u_accessMtx;\n        uniform float u_accessTexChannel;\n        uniform float u_accessTexScale;\n    };`;\n\n    let numBlocks = 1024;\n    let blockSize = (1 + 1 + 1 + 4 + 1 + 1) * 4 * 4;\n    let blockUbo = createFloatBuffer(gl, gl.UNIFORM_BUFFER, gl.createBuffer()!, numBlocks, blockSize, null);\n\n    let blockAccessSize = (2 + 1 + 1 + 1) * 4 * 4;\n    let blockAccessUbo = createFloatBuffer(gl, gl.UNIFORM_BUFFER, gl.createBuffer()!, numBlocks, blockAccessSize, null);\n\n    // non-instanced rendering VAO\n    let cubeGeom = genCubeGeom(gl);\n\n    // instanced rendering VAO\n    let instancedVao = gl.createVertexArray()!;\n    gl.bindVertexArray(instancedVao);\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, cubeGeom.vbo);\n    bindFloatAttribs(gl, cubeGeom.vbo, {}, [\n        { name: 'a_position', size: 3 },\n        { name: 'a_normal', size: 3 },\n    ]);\n\n    let instancedVbo = gl.createBuffer()!;\n    let instancedStrideBytes = bindFloatAttribs(gl, instancedVbo, { locOffset: 2, divisor: 1 }, [\n        { name: 'a_offset', size: 4 },\n        { name: 'a_size', size: 4 },\n        { name: 'a_nCells', size: 4 },\n        { name: 'a_localPosMtx0', size: 4 },\n        { name: 'a_localPosMtx1', size: 4 },\n        { name: 'a_localPosMtx2', size: 4 },\n        { name: 'a_localPosMtx3', size: 4 },\n        { name: 'a_baseColor', size: 4 },\n        { name: 'a_highlight', size: 1 },\n    ]);\n\n    let instancedFloatBuf = createFloatBuffer(gl, gl.ARRAY_BUFFER, instancedVbo, 1024, instancedStrideBytes, null);\n\n    // Create a dummy texture to bind to the access texture slot. Some drivers (e.g. my phone) will complain if we don't.\n    let dummyTexture = gl.createTexture()!;\n    gl.bindTexture(gl.TEXTURE_2D, dummyTexture);\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([0, 0, 0, 0]));\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n\n    function createVertShader(instanced: boolean) {\n        return /*glsl*/`#version 300 es\n        precision highp float;\n\n        ${modelViewUboText}\n\n        ${instanced ? '' : blockUboText}\n\n        ${blockAccessUboText}\n\n        layout(location = 0) in vec3 a_position;\n        layout(location = 1) in vec3 a_normal;\n        out vec3 v_normal;\n        out vec3 v_modelPos;\n        out vec3 v_blockPos;\n        out vec2 v_accessPos;\n        out vec3 v_cubePos;\n\n        ${instanced ? `\n            layout(location = 2) in vec4 a_offset;\n            layout(location = 3) in vec4 a_size;\n            layout(location = 4) in vec4 a_nCells;\n            layout(location = 5) in vec4 a_localPosMtx0;\n            layout(location = 6) in vec4 a_localPosMtx1;\n            layout(location = 7) in vec4 a_localPosMtx2;\n            layout(location = 8) in vec4 a_localPosMtx3;\n            layout(location = 9) in vec4 a_baseColor;\n            layout(location = 10) in float a_highlight;\n\n            out vec4 u_baseColor;\n            out float u_highlight;\n        ` : ''}\n\n        void main() {\n            ${instanced ? `\n                vec3 u_offset = a_offset.xyz;\n                vec3 u_size = a_size.xyz;\n                vec3 u_nCells = a_nCells.xyz;\n                mat4 u_localPosMtx = mat4(a_localPosMtx0, a_localPosMtx1, a_localPosMtx2, a_localPosMtx3);\n                u_baseColor = a_baseColor;\n                u_highlight = a_highlight;\n            ` : ''}\n\n            vec3 localPos = (u_localPosMtx * vec4(a_position, 1.0)).xyz;\n            vec3 model_pos = a_position * u_size + u_offset;\n            gl_Position = u_view * u_model * vec4(model_pos, 1);\n            v_normal = a_normal;\n            v_modelPos = model_pos;\n            v_blockPos = localPos * u_nCells;\n            v_accessPos = u_accessMtx * vec4(v_blockPos, 1.0);\n            v_cubePos = localPos;\n            ${instanced ? ` ` : ''}\n        }`;\n    }\n\n    function createFragShader(instanced: boolean) {\n        return /*glsl*/`#version 300 es\n        precision highp float;\n        in vec3 v_normal;\n        out vec4 o_color;\n        in vec3 v_blockPos;\n        in vec3 v_cubePos;\n        in vec3 v_modelPos;\n        in vec2 v_accessPos;\n        uniform vec3 u_camPos; // in model space\n\n        ${instanced ? `\n            in vec4 u_baseColor;\n            in float u_highlight;\n        ` : blockUboText}\n\n        ${blockAccessUboText}\n\n        uniform sampler2D u_accessSampler;\n\n        void main() {\n            ivec3 blockPos = ivec3(v_blockPos - v_normal * 0.1);\n\n            bool cellDark = (blockPos.x + blockPos.y + blockPos.z) % 2 == 0;\n\n            float maxDist = 4000.0;\n            float minDist = 600.0;\n            float dist = distance(u_camPos, v_modelPos);\n            float t = clamp((dist - minDist) / (maxDist - minDist), 0.0, 1.0);\n\n            vec3 baseColor = mix(u_baseColor.rgb, vec3(0.5, 0.5, 0.5), 0.5);\n            if (cellDark) {\n                baseColor *= mix(0.9, 1.0, t);\n            }\n\n            if (u_accessTexScale > 0.0 && dist < maxDist) { // have access texture\n                vec3 texBaseColor = mix(baseColor, vec3(0.5, 0.5, 0.5), 0.8);\n\n                vec3 d = fract(v_blockPos) - 0.5;\n                float r2 = 0.3*0.3;\n                bool insideX = d.y * d.y + d.z * d.z < r2;\n                bool insideY = d.x * d.x + d.z * d.z < r2;\n                bool insideZ = d.x * d.x + d.y * d.y < r2;\n                bool insideAny = insideX || insideY || insideZ;\n\n                if (insideAny) {\n                    ivec2 accessPos = ivec2(u_accessMtx * vec4(blockPos, 1.0));\n                    vec4 valVec = texelFetch(u_accessSampler, accessPos, 0) * u_accessTexScale;\n                    float val = u_accessTexChannel == 0.0 ? valVec.r : u_accessTexChannel == 1.0 ? valVec.g : valVec.b;\n\n                    float weight = clamp(abs(val), 0.0, 1.0);\n\n                    vec3 negColor = vec3(0.0, 0.0, 0.0);\n                    vec3 posColor = u_baseColor.rgb; // vec3(0.0, 1.0, 0.0);\n                    vec3 zeroColor = vec3(0.5, 0.5, 0.5);\n                    texBaseColor = mix(mix(zeroColor, negColor, weight), mix(zeroColor, posColor, weight), step(0.0, val));\n                }\n\n                baseColor = mix(texBaseColor, baseColor, t);\n            }\n\n            if (true) {\n                vec3 block16 = v_blockPos / 16.0;\n                vec3 pxPerBlock16 = 1.0 / fwidth(block16);\n                float strength16 = min(min(pxPerBlock16.x, pxPerBlock16.y), pxPerBlock16.z);\n                vec3 colorEdge = vec3(1.0, 1.0, 1.0);\n                vec3 color16 = vec3(1.0, 1.0, 1.0) * 0.7;\n                vec3 color256 = vec3(1.0, 1.0, 1.0);\n\n                // if we're zoomed out enough, show 256 & (256 * 16) grid lines\n                // the 16 grid lines are faded out by this point (fade out between 10px -> 1px)\n                if (strength16 < 2.0) {\n                    block16 = block16 / 16.0;\n                    pxPerBlock16 = 1.0 / fwidth(block16);\n                    strength16 = min(min(pxPerBlock16.x, pxPerBlock16.y), pxPerBlock16.z);\n                    color16 = color256;\n                    // orange\n                    color256 = vec3(1.0, 0.7, 0.4);\n                }\n\n                float visibility16 = smoothstep(2.0, 10.0, strength16); // below 10px between lines, fade out\n                vec3 block16Grid = 1.0 - abs(fract(block16 - 0.5) - 0.5) * pxPerBlock16;\n                float line16 = max(max(block16Grid.x, block16Grid.y), block16Grid.z) * visibility16;\n\n                vec3 block256 = block16 / 16.0;\n                vec3 block256Grid = 1.0 - abs(fract(block256 - 0.5) - 0.5) / fwidth(block256);\n                float line256 = max(max(block256Grid.x, block256Grid.y), block256Grid.z);\n\n                vec3 cube = v_cubePos - v_normal * 0.1;\n                vec3 cubeGrid = 1.0 - abs(fract(cube - 0.5) - 0.5) / fwidth(cube);\n                float lineCube = max(max(cubeGrid.x, cubeGrid.y), cubeGrid.z);\n\n                float bestPxPerBlock = min(min(pxPerBlock16.x, pxPerBlock16.y), pxPerBlock16.z);\n                float edgeWeight = smoothstep(0.0, 1.0, max(max(line16, lineCube), line256));\n                vec3 color = lineCube > 0.0 ? colorEdge : (line256 > 0.0 ? color256 : color16);\n                baseColor = mix(baseColor, color, edgeWeight);\n            }\n\n            vec3 color = mix(baseColor * 0.7, u_baseColor.rgb, u_highlight);\n\n            o_color = vec4(color, 1) * u_baseColor.a;\n        }`;\n    }\n\n    let shader = createShaderProgram(ctx, 'block', createVertShader(false), createFragShader(false),\n        ['u_camPos', 'u_accessSampler'],\n        { uboBindings: { 'ModelViewUbo': UboBindings.ModelView, 'BlockUbo': UboBindings.Block, 'BlockAccessUbo': UboBindings.BlockAccess } })!;\n\n    let instancedShader = createShaderProgram(ctx, 'block-instanced', createVertShader(true), createFragShader(true),\n        ['u_camPos', 'u_accessSampler'],\n        { uboBindings: { 'ModelViewUbo': UboBindings.ModelView, 'BlockAccessUbo': UboBindings.BlockAccess } })!;\n\n    let simpleShader = createShaderProgram(ctx, 'block-simple', /*glsl*/`#version 300 es\n        precision highp float;\n        ${modelViewUboText}\n        uniform vec3 u_size;\n        uniform vec3 u_offset;\n\n        layout(location = 0) in vec3 a_position;\n        void main() {\n            vec3 model_pos = a_position * u_size + u_offset;\n            gl_Position = u_view * u_model * vec4(model_pos, 1);\n        }\n    `, /*glsl*/`#version 300 es\n        precision highp float;\n        out vec4 o_color;\n        uniform vec4 u_baseColor;\n\n        void main() {\n            o_color = u_baseColor;\n        }\n    `, [\n        'u_size', 'u_offset', 'u_baseColor',\n    ], { uboBindings: { 'ModelViewUbo': UboBindings.ModelView } })!;\n\n    return {\n        gl,\n        cubeGeom,\n        shader,\n        simpleShader,\n        blockUbo,\n        blockAccessUbo,\n        dummyTexture,\n\n        /* specific to instanced rendering of the blocks. */\n        instancedShader,\n        instancedVao,\n        instancedFloatBuf,\n        instancedDataStale: true,\n        instancedNumBlocks: 0,\n    };\n}\n\n\nexport interface IGeom {\n    name: string;\n    vao: WebGLVertexArrayObject;\n    vbo: WebGLBuffer;\n    type: number; // gl.TRIANGLES etc\n    numVerts: number;\n}\n\nexport function genCubeGeom(gl: WebGL2RenderingContext): IGeom {\n    let faceVerts = [-1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, -1];\n\n    let faces = [\n        new Mat4f(),\n        Mat4f.fromAxisAngle(new Vec3(1, 0), Math.PI / 2),\n        Mat4f.fromAxisAngle(new Vec3(1, 0), Math.PI),\n        Mat4f.fromAxisAngle(new Vec3(1, 0), -Math.PI / 2),\n        Mat4f.fromAxisAngle(new Vec3(0, 1), Math.PI / 2),\n        Mat4f.fromAxisAngle(new Vec3(0, 1), -Math.PI / 2),\n    ];\n\n    // top left front is (0, 0, 0), bottom right back is (1, 1, 1)\n    let transform = Mat4f.fromTranslation(new Vec3(0.5, 0.5, 0.5)).mul(Mat4f.fromScale(new Vec3(.5, .5, .5)));\n    let arr = new Float32Array(6 * 6 * 3 * 2);\n    let j = 0;\n    for (let faceMtx of faces) {\n        for (let i = 0; i < 6; i++) {\n            let v = transform.mulVec3Proj(faceMtx.mulVec3Proj(new Vec3(faceVerts[i * 2], faceVerts[i * 2 + 1], -1)));\n            let n = faceMtx.mulVec3Proj(new Vec3(0, 0, -1));\n            arr[j++] = Math.round(v.x);\n            arr[j++] = Math.round(v.y);\n            arr[j++] = Math.round(v.z);\n            arr[j++] = n.x;\n            arr[j++] = n.y;\n            arr[j++] = n.z;\n        }\n    }\n\n    let vao = gl.createVertexArray()!;\n    gl.bindVertexArray(vao);\n    let vbo = gl.createBuffer()!;\n    gl.bindBuffer(gl.ARRAY_BUFFER, vbo);\n    gl.bufferData(gl.ARRAY_BUFFER, arr, gl.STATIC_DRAW);\n\n    bindFloatAttribs(gl, vbo, {}, [\n        { name: 'a_position', size: 3 },\n        { name: 'a_normal', size: 3 },\n    ]);\n\n    return { name: 'cube', vao, vbo, type: gl.TRIANGLES, numVerts: 36 };\n}\n\nexport function renderBlocksSimple(blockRender: IBlockRender, cubes: IBlkDef[]) {\n    let gl = blockRender.gl;\n    if (!blockRender.simpleShader.ready) {\n        return;\n    }\n    let locs = blockRender.simpleShader.locs;\n    let geom = blockRender.cubeGeom;\n    gl.useProgram(blockRender.simpleShader.program);\n    gl.bindVertexArray(geom.vao);\n\n    for (let cube of cubes) {\n        gl.uniform3f(locs.u_size, cube.dx, cube.dy, cube.dz);\n        gl.uniform3f(locs.u_offset, cube.x, cube.y, cube.z);\n        let baseColor = (cube.t === 'w' ? new Vec4(0.3, 0.3, 1.0, 1) : new Vec4(0.4, 0.8, 0.4, 1)).mul(cube.highlight);\n        gl.uniform4f(locs.u_baseColor, baseColor.x, baseColor.y, baseColor.z, baseColor.w);\n        gl.drawArrays(geom.type, 0, geom.numVerts);\n    }\n}\n\nexport function renderAllBlocks(blockRender: IBlockRender, layout: IModelLayout, modelMtx: Mat4f, camPos: Vec3, lightPosArr: Float32Array, lightColorArr: Float32Array) {\n    let gl = blockRender.gl;\n    let locs = blockRender.shader.locs;\n    let geom = blockRender.cubeGeom;\n\n    if (!blockRender.shader.ready) {\n        return;\n    }\n\n    gl.useProgram(blockRender.shader.program);\n\n    let camPosModel = modelMtx.mulVec3Proj(camPos);\n    gl.uniform3f(locs.u_camPos, camPosModel.x, camPosModel.y, camPosModel.z);\n\n    gl.uniform1i(locs.u_accessSampler, 0);\n    gl.enable(gl.BLEND);\n    gl.enable(gl.CULL_FACE);\n\n    gl.activeTexture(gl.TEXTURE0);\n    gl.bindVertexArray(geom.vao);\n\n    let cubes: IBlkDef[] = [];\n    let transparentCubes: IBlkDef[] = [];\n    function addCube(c: IBlkDef) {\n        if (c.subs) {\n            c.subs.forEach(addCube);\n        } else {\n            if (c.opacity < 0.8 && c.opacity > 0) {\n                transparentCubes.push(c);\n            } else if (c.opacity > 0.0) {\n                cubes.push(c);\n            }\n        }\n    }\n    layout.cubes.forEach(addCube);\n    let allCubes = [...cubes, ...transparentCubes];\n    let firstTransparent = cubes.length;\n\n    let blockUbo = blockRender.blockUbo.localBufs[0];\n    let blockAccessUbo = blockRender.blockAccessUbo.localBufs[0];\n\n    {\n        resetFloatBufferMap(blockRender.blockUbo);\n        ensureFloatBufferSize(blockUbo, cubes.length);\n        let blockBuf = blockUbo.buf;\n        for (let cube of allCubes) {\n            let baseOff = blockUbo.usedEls * blockUbo.strideFloats;\n            blockBuf[baseOff + 0] = cube.x;\n            blockBuf[baseOff + 1] = cube.y;\n            blockBuf[baseOff + 2] = cube.z;\n\n            blockBuf[baseOff + 4] = cube.dx;\n            blockBuf[baseOff + 5] = cube.dy;\n            blockBuf[baseOff + 6] = cube.dz;\n\n            blockBuf[baseOff + 8] = cube.cx;\n            blockBuf[baseOff + 9] = cube.cy;\n            blockBuf[baseOff + 10] = cube.cz;\n\n            blockBuf.set(cube.localMtx ?? new Mat4f(), baseOff + 12);\n\n            let color = (cube.t === 'w' ? Colors.Weights : cube.t === 'i' ? Colors.Intermediates : Colors.Aggregates);\n            let baseColor = new Vec4(color.x, color.y, color.z, cube.opacity);\n            baseColor.writeToBuf(blockBuf, baseOff + 28);\n\n            blockBuf[baseOff + 32] = cube.highlight;\n\n            blockUbo.usedEls += 1;\n        }\n        uploadFloatBuffer(gl, blockRender.blockUbo);\n    }\n\n    {\n        resetFloatBufferMap(blockRender.blockAccessUbo);\n        ensureFloatBufferSize(blockAccessUbo, cubes.length);\n        let blockBuf = blockAccessUbo.buf;\n        for (let cube of allCubes) {\n            let baseOff = blockAccessUbo.usedEls * blockAccessUbo.strideFloats;\n            if (cube.access && cube.access.disable !== true) {\n                blockBuf.set(cube.access.mat.slice(0, 8), baseOff);\n                let c = cube.access.channel;\n\n                blockBuf[baseOff + 8] = c === 'r' ? 0.0 : c === 'g' ? 1.0 : c === 'b' ? 2.0 : 3.0;\n                blockBuf[baseOff + 9] = cube.access.scale;\n            } else {\n                blockBuf[baseOff + 9] = 0.0;\n            }\n            blockAccessUbo.usedEls += 1;\n        }\n        uploadFloatBuffer(gl, blockRender.blockAccessUbo);\n    }\n\n    let prevHasAccess = true;\n    let idx = 0;\n    for (let cube of allCubes) {\n        if (idx === firstTransparent) {\n            gl.depthMask(false);\n        }\n\n        gl.bindBufferRange(gl.UNIFORM_BUFFER, UboBindings.Block, blockRender.blockUbo.buf, idx * blockUbo.strideBytes, blockUbo.strideBytes);\n\n        let hasAccess = !!cube.access && cube.access.disable !== true;\n        if (prevHasAccess || hasAccess) {\n            gl.bindBufferRange(gl.UNIFORM_BUFFER, UboBindings.BlockAccess, blockRender.blockAccessUbo.buf, idx * blockAccessUbo.strideBytes, blockAccessUbo.strideBytes);\n            gl.bindTexture(gl.TEXTURE_2D, hasAccess && cube.access ? cube.access.src.texture : blockRender.dummyTexture);\n            prevHasAccess = hasAccess;\n        }\n\n        gl.drawArrays(geom.type, 0, geom.numVerts);\n        idx++;\n    }\n\n    gl.depthMask(true);\n}\n\n\nexport function renderAllBlocksInstanced(blockRender: IBlockRender, layout: IModelLayout, modelMtx: Mat4f, camPos: Vec3) {\n    if (!blockRender.instancedShader.ready) {\n        return;\n    }\n\n    let gl = blockRender.gl;\n    let locs = blockRender.instancedShader.locs;\n    let blockAccessUbo = blockRender.blockAccessUbo.localBufs[0];\n    gl.useProgram(blockRender.instancedShader.program);\n\n    let modelMtxInv = modelMtx.invert();\n    let camPosModel = modelMtxInv.mulVec3Proj(camPos);\n    gl.uniform3f(locs.u_camPos, camPosModel.x, camPosModel.y, camPosModel.z);\n\n    gl.uniform1i(locs.u_accessSampler, 0);\n    gl.enable(gl.BLEND);\n    gl.enable(gl.CULL_FACE);\n\n    gl.activeTexture(gl.TEXTURE0);\n    gl.bindTexture(gl.TEXTURE_2D, blockRender.dummyTexture);\n\n    gl.bindVertexArray(blockRender.instancedVao);\n\n    if (blockRender.instancedDataStale) {\n        blockRender.instancedDataStale = false;\n\n        {\n            resetFloatBufferMap(blockRender.instancedFloatBuf);\n            let vboBuf = blockRender.instancedFloatBuf.localBufs[0];\n            ensureFloatBufferSize(vboBuf, layout.cubes.length);\n            let buf = vboBuf.buf;\n\n            for (let cube of layout.cubes) {\n                if (cube.small) {\n                    continue;\n                }\n\n                let baseOff = vboBuf.usedEls * vboBuf.strideFloats;\n                buf[baseOff + 0] = cube.x;\n                buf[baseOff + 1] = cube.y;\n                buf[baseOff + 2] = cube.z;\n\n                buf[baseOff + 4] = cube.dx;\n                buf[baseOff + 5] = cube.dy;\n                buf[baseOff + 6] = cube.dz;\n\n                buf[baseOff + 8] = cube.cx;\n                buf[baseOff + 9] = cube.cy;\n                buf[baseOff + 10] = cube.cz;\n\n                buf.set(cube.localMtx ?? new Mat4f(), baseOff + 12);\n\n                let color = (cube.t === 'w' ? Colors.Weights : cube.t === 'i' ? Colors.Intermediates : Colors.Aggregates);\n                let baseColor = new Vec4(color.x, color.y, color.z, cube.opacity);\n                baseColor.writeToBuf(buf, baseOff + 28);\n\n                buf[baseOff + 32] = cube.highlight;\n\n                vboBuf.usedEls += 1;\n            }\n            uploadFloatBuffer(gl, blockRender.instancedFloatBuf);\n            blockRender.instancedNumBlocks = vboBuf.usedEls;\n        }\n\n        {\n            resetFloatBufferMap(blockRender.blockAccessUbo);\n            ensureFloatBufferSize(blockAccessUbo, 1);\n            let blockBuf = blockAccessUbo.buf;\n            blockBuf[0 + 9] = 0.0;\n            blockAccessUbo.usedEls += 1;\n            uploadFloatBuffer(gl, blockRender.blockAccessUbo);\n        }\n    }\n\n    gl.bindBufferRange(gl.UNIFORM_BUFFER, UboBindings.BlockAccess, blockRender.blockAccessUbo.buf, 0, blockAccessUbo.strideBytes);\n    gl.drawArraysInstanced(blockRender.cubeGeom.type, 0, blockRender.cubeGeom.numVerts, blockRender.instancedNumBlocks);\n\n    gl.depthMask(true);\n}\n","import { createShaderProgram, IGLContext } from \"@/src/utils/shader\";\nimport { Dim, Vec3 } from \"@/src/utils/vector\";\nimport { UboBindings } from \"./sharedRender\";\n\nexport type IBlurRender = ReturnType<typeof initBlurRender>;\n\nexport function initBlurRender(ctx: IGLContext, quadVao: WebGLVertexArrayObject) {\n    let gl = ctx.gl;\n\n    // have a pair of framebuffers to ping-pong between\n    // we'll render to a half-size buffer to save memory/compute\n\n    // will need a few different shaders to draw our buffers, since most things (like text or blocks)\n    // have unusual drawing behaviour (wait text is OK)\n\n    // Draw all our targets to a buffer.\n    // Blur it to another buffer.\n    // Blur it in the other dir to yet another buffer.\n    // Ping-pong between 2 & 3 as desired\n    // Draw the final result to the screen, subtracting the original from the blurred result, since\n    // we're after the outline of the original objects.\n    // Composite that directly onto the output buffer.\n    // We want our blurred colors to participate in the depth test\n\n\n    // For respecting the depth buffer:\n    //  - Render the object to our buffer, with a depth test (no write)\n    //  - Render an expanded version of the object to our buffer, with a depth test (no write)\n    //    - Write to the stencil buffer\n    //  - Now do the blur, applying the stencil test\n    let w = Math.max(gl.canvas.width, 1);\n    let h = Math.max(gl.canvas.height, 1);\n\n    // let stencilRenderBuf = gl.createRenderbuffer();\n    // gl.bindRenderbuffer(gl.RENDERBUFFER, stencilRenderBuf);\n    // gl.renderbufferStorage(gl.RENDERBUFFER, gl.STENCIL_INDEX8, w, h);\n\n    let initialFbo = gl.createFramebuffer()!;\n    let initialTex = gl.createTexture()!;\n    gl.bindFramebuffer(gl.FRAMEBUFFER, initialFbo);\n    gl.bindTexture(gl.TEXTURE_2D, initialTex);\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, w, h, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, initialTex, 0);\n\n    // gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.STENCIL_ATTACHMENT, gl.RENDERBUFFER, stencilRenderBuf); // sharing the stencil buffer\n    // gl.drawBuffers([gl.COLOR_ATTACHMENT0]);\n    // also attach depth buffer of primary scene fbo\n\n    function createBlurFbo() {\n        let fbo = gl.createFramebuffer()!;\n        let tex = gl.createTexture()!;\n        gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);\n        gl.bindTexture(gl.TEXTURE_2D, tex);\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, w, h, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex, 0);\n        // gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.STENCIL_ATTACHMENT, gl.RENDERBUFFER, stencilRenderBuf); // sharing the stencil buffer\n        // gl.drawBuffers([gl.COLOR_ATTACHMENT0]);\n\n        {\n            let status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);\n            if (status !== gl.FRAMEBUFFER_COMPLETE) {\n                console.log(`Blur framebuffer not complete: ${status.toString(16)}`);\n            }\n        }\n\n        return { fbo, tex };\n    }\n\n    let blurFbos = [createBlurFbo(), createBlurFbo()];\n\n    let radiusPx = 4;\n    let blurPixelStride = 2;\n\n    // create ubo for blur shader, which are the [0..4] weights for the 5 samples (to the right of the center pixel & including)\n    let blurWeights = new Float32Array((radiusPx * 2 + 1) * 4);\n    let blurWeightsSum = 0;\n    let blurSigma = radiusPx / 2;\n    for (let i = -radiusPx; i <= radiusPx; i++) {\n        let x = i / blurSigma;\n        let w = Math.exp(-x * x * 0.5);\n        let wIdx = i + radiusPx;\n        blurWeights[wIdx * 4] = w;\n        blurWeightsSum += w;\n    }\n    for (let i = 0; i < radiusPx * 2 + 1; i++) {\n        blurWeights[i * 4] /= blurWeightsSum;\n    }\n\n    let blurUbo = gl.createBuffer();\n    gl.bindBuffer(gl.UNIFORM_BUFFER, blurUbo);\n    gl.bufferData(gl.UNIFORM_BUFFER, blurWeights.buffer, gl.STATIC_DRAW);\n    gl.bindBufferBase(gl.UNIFORM_BUFFER, UboBindings.blur, blurUbo);\n\n    function createBlurShader(name: string, dim: Dim) {\n        return createShaderProgram(ctx.shaderManager, name, /*glsl*/`#version 300 es\n            precision highp float;\n            layout(location = 0) in vec2 a_position;\n            void main() {\n                gl_Position = vec4(a_position, 0, 1);\n            }\n        `, /*glsl*/`#version 300 es\n            precision highp float;\n\n            layout(std140) uniform BlurWeights {\n                float weights[${radiusPx * 2 + 1}];\n            };\n\n            uniform sampler2D u_texture;\n            out vec4 o_color;\n\n            void main() {\n                ivec2 pos = ivec2(gl_FragCoord.xy);\n                vec4 color = vec4(0);\n                vec4 center = texelFetch(u_texture, pos, 0);\n                for (int i = -${radiusPx}; i <= ${radiusPx}; i++) {\n                    int wId = i + ${radiusPx};\n                    color += texelFetch(u_texture, pos + ivec2(${dim === Dim.X ? 'i, 0' : '0, i'}) * ${blurPixelStride}, 0) * weights[wId];\n                }\n                o_color = max(color, center);\n            }\n        `, ['u_texture'], { uboBindings: { 'BlurWeights': UboBindings.blur } })!;\n    }\n\n    let horizShader = createBlurShader(\"blurHoriz\", Dim.X);\n    let vertShader = createBlurShader(\"blurVert\", Dim.Y);\n\n    let overlayShader = createShaderProgram(ctx.shaderManager, \"blurOverlay\", /*glsl*/`#version 300 es\n            precision highp float;\n            layout(location = 0) in vec2 a_position;\n            out vec2 v_uv;\n            void main() {\n                gl_Position = vec4(a_position, 0, 1);\n                v_uv = a_position * 0.5 + 0.5;\n            }\n        `, /*glsl*/`#version 300 es\n            precision highp float;\n            uniform sampler2D u_texture;\n            uniform sampler2D u_initTexture;\n            in vec2 v_uv;\n            out vec4 o_color;\n\n            void main() {\n                ivec2 pos = ivec2(gl_FragCoord.xy);\n                vec4 blurColor = texture(u_texture, v_uv);\n                // vec4 initColor = texture(u_initTexture, v_uv);\n\n                vec4 base = vec4(0.9, 0.9, 0.9, 0.1);\n                // if (blurColor.a == 0.0) {\n                //     blurColor = vec4(0.1, 0.1, 0.1, 1.0);\n                // }\n                o_color = blurColor; // + initColor * (1.0 - blurColor.a);\n                // o_color = initColor;\n            }\n        `, ['u_texture'])!;\n\n    return {\n        gl,\n        quadVao,\n        // stencilRenderBuf,\n        initialFbo,\n        initialTex,\n        blurFbos,\n        horizShader,\n        vertShader,\n        overlayShader,\n        currViewSize: new Vec3(0, 0),\n        blurFactor: 0.3,\n    };\n}\n\nexport function setupBlurTarget(blur: IBlurRender) {\n    let gl = blur.gl;\n    let w = gl.canvas.width;\n    let h = gl.canvas.height;\n    let blurW = Math.floor(w * blur.blurFactor);\n    let blurH = Math.floor(h * blur.blurFactor);\n\n    if (blur.currViewSize.x !== w || blur.currViewSize.y !== h) {\n        // gl.bindRenderbuffer(gl.RENDERBUFFER, blur.stencilRenderBuf);\n        // gl.renderbufferStorage(gl.RENDERBUFFER, gl.STENCIL_INDEX8, blurW, blurH);\n\n        gl.bindTexture(gl.TEXTURE_2D, blur.initialTex);\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, blurW, blurH, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n\n        for (let fbo of blur.blurFbos) {\n            gl.bindTexture(gl.TEXTURE_2D, fbo.tex);\n            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, blurW, blurH, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n        }\n\n        blur.currViewSize = new Vec3(w, h);\n    }\n\n    gl.bindFramebuffer(gl.FRAMEBUFFER, blur.initialFbo);\n    gl.viewport(0, 0, blurW, blurH);\n    gl.clearColor(0, 0, 0, 0);\n    gl.clear(gl.COLOR_BUFFER_BIT);\n}\n\nexport function renderBlur(blur: IBlurRender, destFbo: WebGLFramebuffer | null) {\n    let gl = blur.gl;\n    let w = gl.canvas.width;\n    let h = gl.canvas.height;\n    let blurW = Math.floor(w * blur.blurFactor);\n    let blurH = Math.floor(h * blur.blurFactor);\n    gl.bindVertexArray(blur.quadVao);\n    gl.disable(gl.DEPTH_TEST);\n    gl.disable(gl.BLEND);\n    gl.disable(gl.CULL_FACE);\n    gl.disable(gl.STENCIL_TEST);\n\n    gl.activeTexture(gl.TEXTURE0);\n\n    { // initial -> blurFbos[0] (horizontal pass)\n        gl.bindTexture(gl.TEXTURE_2D, blur.initialTex);\n        gl.bindFramebuffer(gl.FRAMEBUFFER, blur.blurFbos[0].fbo);\n        gl.viewport(0, 0, blurW, blurH);\n\n        gl.useProgram(blur.horizShader.program);\n        gl.uniform1i(blur.horizShader.locs.u_texture, 0);\n\n        gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);\n    }\n\n    { // blurFbos[0] -> blurFbos[1] (vertical pass)\n        gl.bindTexture(gl.TEXTURE_2D, blur.blurFbos[0].tex);\n        gl.bindFramebuffer(gl.FRAMEBUFFER, blur.blurFbos[1].fbo);\n        gl.viewport(0, 0, blurW, blurH);\n\n        gl.useProgram(blur.vertShader.program);\n        gl.uniform1i(blur.vertShader.locs.u_texture, 0);\n        gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);\n    }\n\n    { // blurFbos[1] -> destFbo (overlay)\n        gl.enable(gl.BLEND);\n        gl.viewport(0, 0, w, h);\n\n        gl.bindFramebuffer(gl.FRAMEBUFFER, destFbo);\n        gl.bindTexture(gl.TEXTURE_2D, blur.blurFbos[1].tex);\n        gl.activeTexture(gl.TEXTURE1);\n        gl.bindTexture(gl.TEXTURE_2D, blur.initialTex);\n\n        gl.useProgram(blur.overlayShader.program);\n        gl.uniform1i(blur.overlayShader.locs.u_texture, 0);\n        // gl.uniform1i(blur.overlayShader.locs.u_initTexture, 1);\n        gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);\n    }\n}\n","import { IGLContext } from \"@/src/utils/shader\";\n\nexport interface IQueryManager {\n    ctx: IGLContext;\n    queries: Map<string, IQuery>;\n    TIME_ELAPSED_EXT: number;\n}\n\nexport interface IQuery {\n    query: WebGLQuery;\n    hasRun: boolean;\n    hasStarted: boolean;\n}\n\nexport function createQueryManager(ctx: IGLContext): IQueryManager {\n\n    return {\n        ctx,\n        queries: new Map(),\n        TIME_ELAPSED_EXT: ctx.ext.disjointTimerQuery?.TIME_ELAPSED_EXT!,\n    };\n}\n\nexport function beginQueryAndGetPrevMs(manager: IQueryManager, name: string): number | null {\n    if (!manager.ctx.ext.disjointTimerQuery) {\n        return null;\n    }\n\n    let existing = manager.queries.get(name);\n    if (!existing) {\n        let query = manager.ctx.gl.createQuery()!;\n        manager.queries.set(name, existing = { query, hasRun: false, hasStarted: false });\n    }\n\n    let resultAvailable = false\n    if (existing.hasRun) {\n        resultAvailable = manager.ctx.gl.getQueryParameter(existing.query, manager.ctx.gl.QUERY_RESULT_AVAILABLE);\n    }\n\n    let resultMs: number | null = null;\n\n    if (resultAvailable) {\n        let timeElapsed = manager.ctx.gl.getQueryParameter(existing.query, manager.ctx.gl.QUERY_RESULT);\n        resultMs = timeElapsed / 1000000;\n    }\n\n    if (!existing.hasRun || resultAvailable) {\n        manager.ctx.gl.beginQuery(manager.TIME_ELAPSED_EXT, existing.query);\n        existing.hasRun = true;\n        existing.hasStarted = true;\n    }\n\n    return resultMs;\n}\n\nexport function endQuery(manager: IQueryManager, name: string) {\n    if (!manager.ctx.ext.disjointTimerQuery) {\n        return;\n    }\n    let existing = manager.queries.get(name);\n    if (existing && existing.hasRun && existing.hasStarted) {\n        manager.ctx.gl.endQuery(manager.TIME_ELAPSED_EXT);\n        existing.hasStarted = false;\n    }\n}\n","import { createFontBuffers, IFontAtlas, IFontAtlasData, IFontBuffers, measureTextWidth, renderAllText, resetFontBuffers, setupFontAtlas, uploadAllText, writeTextToBuffer } from \"./fontRender\";\nimport { Mat4f } from \"@/src/utils/matrix\";\nimport { createShaderManager, ensureShadersReady, IGLContext } from \"@/src/utils/shader\";\nimport { Vec3, Vec4 } from \"@/src/utils/vector\";\nimport { IBlockRender, initBlockRender, renderAllBlocks, renderAllBlocksInstanced, renderBlocksSimple } from \"./blockRender\";\nimport { initBlurRender, renderBlur, setupBlurTarget } from \"./blurRender\";\nimport { createLineRender, renderAllLines, resetLineRender, uploadAllLines } from \"./lineRender\";\nimport { renderAllThreads, initThreadRender } from \"./threadRender\";\nimport { initSharedRender, RenderPhase, writeModelViewUbo } from \"./sharedRender\";\nimport { cameraToMatrixView } from \"../Camera\";\nimport { initTriRender, renderAllTris, resetTriRender, uploadAllTris } from \"./triRender\";\nimport { createQueryManager, IQueryManager } from \"./queryManager\";\nimport { IProgramState } from \"../Program\";\nimport { ISyncObject } from \"./syncObjects\";\n\nexport interface IRenderView {\n    time: number;\n    dt: number;\n    markDirty: () => void;\n}\n\nexport interface IRenderState {\n    gl: WebGL2RenderingContext;\n    canvasEl: HTMLCanvasElement;\n    ctx: IGLContext;\n    blockRender: IBlockRender;\n    lineRender: ReturnType<typeof createLineRender>;\n    threadRender: ReturnType<typeof initThreadRender>;\n    blurRender: ReturnType<typeof initBlurRender>;\n    sharedRender: ReturnType<typeof initSharedRender>;\n    triRender: ReturnType<typeof initTriRender>;\n    fontAtlas: IFontAtlas;\n    modelFontBuf: IFontBuffers;\n    quadVao: WebGLVertexArrayObject;\n    queryManager: IQueryManager;\n    syncObjects: ISyncObject[];\n    size: Vec3;\n\n    renderTiming: boolean;\n    lastGpuMs: number;\n    lastJsMs: number;\n}\n\nexport function initRender(canvasEl: HTMLCanvasElement, fontAtlasData: IFontAtlasData): IRenderState | null {\n    // init shaders for various block types\n\n    // console.clear();\n    let gl = canvasEl.getContext(\"webgl2\", { antialias: true })!;\n\n    if (!gl) {\n        return null;\n    }\n\n    let ext: IGLContext['ext'] = {\n        colorBufferFloat: gl.getExtension(\"EXT_color_buffer_float\"),\n        disjointTimerQuery: gl.getExtension('EXT_disjoint_timer_query_webgl2'),\n    };\n\n    if (!ext.colorBufferFloat) {\n        console.log(\"initRender: EXT_color_buffer_float not supported: floating point textures will not work.\");\n    }\n\n    if (!ext.disjointTimerQuery) {\n        console.log(\"initRender: EXT_disjoint_timer_query_webgl2 not supported: GPU timing will not work.\");\n    }\n\n    let shaderManager = createShaderManager(gl);\n\n    let ctx: IGLContext = { gl, shaderManager, ext };\n\n    let quadVbo = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, quadVbo);\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([\n        -1, -1,\n        1, -1,\n        1, 1,\n        -1, 1,\n    ]), gl.STATIC_DRAW);\n\n    let quadVao = gl.createVertexArray()!;\n    gl.bindVertexArray(quadVao);\n    gl.enableVertexAttribArray(0);\n    gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);\n\n    let sharedRender = initSharedRender(ctx);\n\n    let fontAtlas = setupFontAtlas(ctx, fontAtlasData);\n\n    let modelFontBuf = createFontBuffers(fontAtlas, sharedRender);\n    let threadRender = initThreadRender(ctx);\n    let lineRender = createLineRender(ctx, sharedRender);\n    let blockRender = initBlockRender(ctx);\n    let triRender = initTriRender(ctx, sharedRender);\n    let blurRender = initBlurRender(ctx, quadVao);\n    let queryManager = createQueryManager(ctx);\n\n    ensureShadersReady(shaderManager);\n\n    return {\n        canvasEl,\n        gl,\n        ctx,\n        blockRender,\n        threadRender,\n        lineRender,\n        blurRender,\n        triRender,\n        sharedRender,\n        fontAtlas,\n        modelFontBuf,\n        quadVao,\n        queryManager,\n        syncObjects: [],\n        size: new Vec3(1, 1),\n        lastGpuMs: 0,\n        lastJsMs: 0,\n        renderTiming: false,\n    };\n}\n\nexport function resetRenderBuffers(args: IRenderState) {\n    resetLineRender(args.lineRender);\n    resetFontBuffers(args.modelFontBuf);\n    resetTriRender(args.triRender);\n}\n\nexport function renderModel(state: IProgramState) {\n    let { layout, render: args, camera } = state;\n    let { gl, blockRender, size } = args;\n\n    let { modelMtx, viewMtx } = camera;\n    let { camPos } = cameraToMatrixView(camera);\n\n    let lightPos = [\n        new Vec3(100, 400, 600),\n        new Vec3(-200, -300, -300),\n        new Vec3(200, -100, 0),\n    ];\n    let lightColor = [\n        new Vec3(1, 0.2, 0.2),\n        new Vec3(1, 0.2, 0.2),\n        new Vec3(1, 0.2, 0.2),\n    ];\n    let lightPosArr = new Float32Array(3 * 3);\n    let lightColorArr = new Float32Array(3 * 3);\n    for (let i = 0; i < 3; i++) {\n        modelMtx.mulVec3Proj(lightPos[i]).writeToBuf(lightPosArr, i * 3);\n        modelMtx.mulVec3Proj(lightColor[i]).writeToBuf(lightColorArr, i * 3);\n    }\n\n\n    /// ------ The render pass ------ ///\n\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n    gl.viewport(0, 0, size.x, size.y);\n\n    gl.clearColor(0, 0, 0, 0);\n    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n\n    gl.enable(gl.BLEND);\n    gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n\n    gl.enable(gl.DEPTH_TEST);\n    gl.enable(gl.CULL_FACE);\n    gl.cullFace(gl.FRONT);\n\n    gl.frontFace(gl.CW); // our transform has a -ve determinant, so we switch this for correct rendering\n\n    if (args.renderTiming) {\n        let text = `GPU: ${args.lastGpuMs.toFixed(1)}ms JS: ${args.lastJsMs.toFixed(1)}ms`;\n        let w = size.x;\n        let fontSize = 14;\n        args.sharedRender.activePhase = RenderPhase.Overlay2D;\n        let tw = measureTextWidth(args.modelFontBuf, text, fontSize);\n        writeTextToBuffer(args.modelFontBuf, text, new Vec4(0,0,0,1), w - tw - 4, 4, fontSize, new Mat4f());\n    }\n\n    writeModelViewUbo(args.sharedRender, modelMtx, viewMtx);\n\n    {\n        let blurBlocks = layout.cubes.filter(a => a.highlight > 0)\n        setupBlurTarget(args.blurRender);\n        renderBlocksSimple(blockRender, blurBlocks);\n\n        renderBlur(args.blurRender, null);\n    }\n    gl.enable(gl.DEPTH_TEST);\n\n    uploadAllLines(args.lineRender);\n    uploadAllTris(args.triRender);\n    uploadAllText(args.modelFontBuf);\n\n    renderAllBlocks(blockRender, layout, modelMtx, camPos, lightPosArr, lightColorArr);\n\n    args.sharedRender.activePhase = RenderPhase.Opaque;\n\n    for (let example of state.examples) {\n        if (example.enabled && example.layout) {\n            let { modelMtx, viewMtx } = camera;\n            let { camPos } = cameraToMatrixView(camera);\n            var modelMtxLocal = modelMtx.mul(Mat4f.fromTranslation(example.offset));\n            writeModelViewUbo(args.sharedRender, modelMtxLocal, viewMtx);\n            renderAllBlocksInstanced(example.blockRender, example.layout, modelMtxLocal, camPos);\n        }\n    }\n\n    writeModelViewUbo(args.sharedRender, modelMtx, viewMtx);\n\n    renderAllThreads(args.threadRender);\n\n    gl.polygonOffset(-1.0, -2.0);\n\n    let phaseOrder = [RenderPhase.Opaque, RenderPhase.Arrows, RenderPhase.Overlay, RenderPhase.Overlay2D];\n    for (let phase of phaseOrder) {\n\n        if (phase === RenderPhase.Overlay2D) {\n            let w = size.x;\n            let h = size.y;\n            gl.clear(gl.DEPTH_BUFFER_BIT);\n            writeModelViewUbo(args.sharedRender, new Mat4f(), Mat4f.fromOrtho(0, w, h, 0, -1, 1));\n        }\n\n        if (phase === RenderPhase.Overlay || phase === RenderPhase.Overlay2D) {\n            gl.enable(gl.POLYGON_OFFSET_FILL);\n        } else {\n            gl.disable(gl.POLYGON_OFFSET_FILL);\n        }\n        renderAllTris(args.triRender, phase);\n        renderAllText(args.modelFontBuf, phase);\n        renderAllLines(args.lineRender, phase);\n    }\n    gl.disable(gl.POLYGON_OFFSET_FILL);\n\n}\n","import { camScaleToScreen } from \"../Camera\";\nimport { IProgramState } from \"../Program\";\nimport { drawText, IFontOpts, measureText } from \"../render/fontRender\";\nimport { RenderPhase } from \"../render/sharedRender\";\nimport { Mat4f } from \"@/src/utils/matrix\";\nimport { Vec3, Vec4 } from \"@/src/utils/vector\";\nimport { drawRoundedRect } from \"./DataFlow\";\n\nexport function drawBlockInfo(state: IProgramState) {\n\n    for (let blk of state.layout.cubes) {\n\n        let blkTopMid = new Vec3(blk.x + blk.dx / 2, blk.y, blk.z + blk.dz / 2);\n\n        let scale = camScaleToScreen(state, blkTopMid);\n\n        scale = Math.min(scale, 1.45);\n        // have a max scale\n\n        let textColor = new Vec4(1, 1, 1, 1).mul(blk.opacity);\n        let bgColor = new Vec4(0, 0, 0, 1).mul(blk.opacity);\n\n        if (blk.opacity === 0 || !blk.name) {\n            continue;\n        }\n\n        // draw text, centered on top of the block\n        let text = blk.name;\n        let mtx = Mat4f.fromTranslation(blkTopMid);\n        let textOpts: IFontOpts = { color: textColor, size: scale * 2.5, mtx };\n        let textW = measureText(state.render.modelFontBuf, text, textOpts);\n\n        let pad = 0.4;\n        state.render.sharedRender.activePhase = RenderPhase.Opaque;\n        drawRoundedRect(state.render, new Vec3(-textW / 2 - pad, -textOpts.size - pad * 2, 0), new Vec3(textW / 2 + pad, 0, 0), bgColor, mtx, scale * 0.4);\n\n        state.render.sharedRender.activePhase = RenderPhase.Overlay;\n        drawText(state.render.modelFontBuf, text, -textW / 2, -textOpts.size - pad, textOpts);\n    }\n}\n","import { IGptModelConfig, TensorF32 } from \"@/src/utils/tensor\";\n\nexport async function loadNativeBindings() {\n\n    let resp = await fetch('/native.wasm');\n    // load wasm file and return the module\n\n    let lineStr = \"\";\n\n    let memory = new WebAssembly.Memory({ initial: 1, maximum: 256 });\n\n    let importObject = {\n        env: {\n            memory,\n        },\n        odin_env: {\n            write: (fd: number, ptr: number, len: number) => {\n                let mem = new Uint8Array(importObject.env.memory.buffer, ptr, len);\n                let strPart = new TextDecoder().decode(mem);\n                let lines = strPart.split('\\n');\n                for (let i = 0; i < lines.length - 1; i++) {\n                    console.log(lineStr + lines[i]);\n                    lineStr = \"\";\n                }\n                lineStr += lines[lines.length - 1];\n            },\n            time_now: () => {\n                return BigInt(Date.now()) * BigInt(1e6);\n            },\n        },\n        odin_dom: {\n            init_event_raw: (ptr: number) => {\n                console.log('ODIN: init_event_raw', ptr);\n            },\n        },\n    };\n\n    let wasmModule = await WebAssembly.instantiateStreaming(resp, importObject);\n\n    let exports = wasmModule.instance.exports as unknown as INativeExports;\n    exports.init_allocator(exports.__heap_base);\n    // let res = exports.add_numbers(4, 5);\n    // let sin = exports.sinf_custom(0.25);\n\n    // console.log(module);\n    // console.log(initRes, res, sin);\n\n    let nativeFuncs = new NativeFunctions(wasmModule, exports, memory);\n\n    // checkNativeFns(exports);\n\n    return nativeFuncs;\n}\n\ninterface INativeExports {\n    __heap_base: number;\n    init_allocator: (heapBase: number) => number;\n    add_numbers: (a: number, b: number) => number;\n    sinf_custom: (a: number) => number;\n    cosf_custom: (a: number) => number;\n    expf_custom: (a: number) => number;\n    wasm_create_model: (B: number, T: number, C: number, n_layers: number, n_heads: number, n_vocab: number) => number;\n    wasm_run_model: (model: number) => number;\n    wasm_get_model_tensor: (model: number, tensor: number, index: number) => number;\n}\n\nexport class NativeFunctions {\n\n    viewBuf: ArrayBuffer;\n    int32View: Int32Array;\n    ptrView: Uint32Array;\n\n    constructor(\n        public module: WebAssembly.WebAssemblyInstantiatedSource,\n        public exports: INativeExports,\n        public memory: WebAssembly.Memory,\n    ) {\n\n        this.viewBuf = memory.buffer;\n        this.int32View = new Int32Array(memory.buffer);\n        this.ptrView = new Uint32Array(memory.buffer);\n    }\n\n    createModel(config: IGptModelConfig) {\n        let model = this.exports.wasm_create_model(config.B ?? 1, config.block_size, config.n_embd, config.n_layer, config.n_head, config.vocab_size)\n        return model;\n    }\n\n    runModel(model: number) {\n        this.exports.wasm_run_model(model);\n    }\n\n    getModelTensor(model: number, tensor: TensorType, index: number = 0) {\n        let ptr = this.exports.wasm_get_model_tensor(model, tensor, index);\n        this.checkViews();\n        let bufNElem = this.int32View[ptr / 4];\n        let ndimsSize = this.int32View[ptr / 4 + 1];\n        let dataPtr = this.ptrView[ptr / 4 + 2];\n        let shapeArrPtr = this.ptrView[ptr / 4 + 3];\n        let strideArrPtr = this.ptrView[ptr / 4 + 4];\n\n        let shape = new Int32Array(this.memory.buffer, shapeArrPtr, ndimsSize);\n        let stride = new Int32Array(this.memory.buffer, strideArrPtr, ndimsSize);\n        let data = new Float32Array(this.memory.buffer, dataPtr, bufNElem);\n\n        return new TensorF32([...shape], data, [...stride]);\n    }\n\n    checkViews() {\n        if (this.viewBuf === this.memory.buffer) {\n            return;\n        }\n\n        this.viewBuf = this.memory.buffer;\n        this.int32View = new Int32Array(this.memory.buffer);\n        this.ptrView = new Uint32Array(this.memory.buffer);\n    }\n}\n\nexport enum TensorType {\n    // weights\n    Wte,\n    Wpe,\n    LmHeadW,\n    AttnQkvW,\n    AttnQkvB,\n    AttnProjW,\n    AttnProjB,\n    MlpW,\n    MlpB,\n    MlpProjW,\n    MlpProjB,\n    Ln1Gamma,\n    Ln1Beta,\n    Ln2Gamma,\n    Ln2Beta,\n    LnFGamma,\n    LnFBeta,\n\n    // intermediate values\n    InputTokens,\n    InputTokenEmbed,\n    InputEmbed,\n\n    Ln1Agg,\n    Ln1Norm,\n    AttnQkv,\n    Attn,\n    AttnSmAgg,\n    AttnSm,\n    AttnVOut,\n    AttnProj,\n    AttnResidual,\n\n    Ln2Agg,\n    Ln2Norm,\n    MlpMlp,\n    MlpAct,\n    MlpProj,\n    MlpResidual,\n\n    LnFAgg,\n    LnFNorm,\n    Logits,\n    LogitsSmAgg,\n    LogitsSm,\n}\n\nfunction checkNativeFns(exports: INativeExports) {\n     checkFn((f) => [Math.sin(f), exports.sinf_custom(f)], 'sinf');\n     checkFn((f) => [Math.cos(f), exports.cosf_custom(f)], 'cosf');\n     checkFn((f) => [Math.exp(f), exports.expf_custom(f)], 'expf');\n}\n\nfunction createTestValues() {\n    let actualTestValues: number[] = [];\n\n    for (let vals in testValues) {\n        // we'll use a range of 100 values either side of each test value\n        let start = testValues[vals];\n        let startI = floatAsInt(start);\n        for (let i = 0; i < 100; i++) {\n            let f = intAsFloat(startI + i);\n            actualTestValues.push(f);\n            let f2 = intAsFloat(startI - i);\n            i > 0 && actualTestValues.push(f2);\n        }\n    }\n\n    for (let i = 0; i < 10000; i++) {\n        actualTestValues.push(-10 + Math.random() * 20);\n    }\n\n    for (let i = 0; i < 10000; i++) {\n        actualTestValues.push(-Math.PI / 4 + Math.random() * Math.PI / 2);\n    }\n\n    return actualTestValues;\n}\n\nfunction checkFn(testFn: (f: number) => [number, number], name: string) {\n    let actualTestValues = createTestValues();\n\n    let arr0 = new Float32Array(1);\n    let arr1 = new Float32Array(1);\n    let arr2 = new Float32Array(1);\n    let maxAbsError = 0;\n    let maxAbsErrorVal = 0;\n    let maxRelError = 0;\n    let maxRelErrorVal = 0;\n    for (let i = 0; i < actualTestValues.length; i++) {\n        arr0[0] = actualTestValues[i];\n\n        let res = testFn(arr0[0]);\n\n        arr1[0] = res[0];\n        arr2[0] = res[1];\n\n        let absError = Math.abs(arr1[0] - arr2[0]);\n        let relError = absError / Math.abs(arr1[0]);\n\n        if (absError > maxAbsError) {\n            maxAbsError = absError;\n            maxAbsErrorVal = arr0[0];\n        }\n        if (relError > maxRelError) {\n            maxRelError = relError;\n            maxRelErrorVal = arr0[0];\n        }\n    }\n\n    console.log(`${name}: max abs error: ${maxAbsError} (at ${maxAbsErrorVal}), max rel error: ${maxRelError} (at ${maxRelErrorVal})`);\n}\n\nfunction floatAsInt(f: number) {\n    let buf = new ArrayBuffer(4);\n    let view = new DataView(buf);\n    view.setFloat32(0, f, true);\n    return view.getInt32(0, true);\n}\n\nfunction intAsFloat(i: number) {\n    let buf = new ArrayBuffer(4);\n    let view = new DataView(buf);\n    view.setInt32(0, i, true);\n    return view.getFloat32(0, true);\n}\n\nconst pi = Math.PI;\nconst piOver2 = pi / 2;\nconst piOver4 = pi / 4;\nconst twoPi = 2 * pi;\nconst threePiOver2 = 3 * pi / 2;\n\nconst testValues = [\n  -10, -pi, -piOver2, -piOver4, -1e-7, -1e-6, 0, 1e-6, 1e-7, piOver4, piOver2, pi, threePiOver2, twoPi, 10\n];\n\n","import { IAddLayerLink, IAttentionLayerLink, IBlockLayerLink, IEmbedLayerLink, IGptModelLink, ILayerNormLayerLink, ILinearLayerLink, IMlpLayerLink, IModelShape, ISoftmaxLayerLink } from \"./GptModel\";\nimport { NativeFunctions, TensorType } from \"./NativeBindings\";\nimport { makeArray } from \"@/src/utils/data\";\nimport { createBufferTex as createBufferTex2, IBufferTex, writeToBufferTex } from \"@/src/utils/renderPhases\";\nimport { IGptModelConfig, ITensorSet, TensorF32 } from \"@/src/utils/tensor\";\n\nfunction createBufferTex(gl: WebGL2RenderingContext, height: number, width: number, channels: number) {\n    return createBufferTex2(gl, width, height, channels);\n}\n\ninterface IWasmLayerBuilder {\n    gl: WebGL2RenderingContext;\n    shape: IModelShape;\n}\n\nexport function createGpuModelForWasm(gl: WebGL2RenderingContext, config: IGptModelConfig): IGptModelLink {\n    let B = 1;\n    let C = config.n_embd;\n    let nHeads = config.n_head;\n    let T = config.block_size;\n    let nBlocks = config.n_layer;\n    let vocabSize = config.vocab_size;\n    let A = C / nHeads; // n elements in each Q, K, V vector, i.e. what we project down to\n\n    let shape: IModelShape = { B, C, nHeads, T, A, nBlocks, vocabSize };\n    let layerBuilder: IWasmLayerBuilder = { gl, shape };\n\n    let inputTokens = createBufferTex(gl, B * T, 1, 1);\n    let softmaxFinal = createSoftmaxLayer(layerBuilder);\n\n    return {\n         gl,\n         add: createAddLayer(layerBuilder),\n         inputBuf: new Float32Array(),\n         inputLen: 6,\n         ln_f: createLayerNormLayer(layerBuilder),\n         inputTokens,\n         lm_head: createLinearLayer(layerBuilder, T, C, vocabSize),\n         blocks: makeArray(nBlocks).map(() => createBlockLayer(layerBuilder)),\n         output: softmaxFinal.output,\n         posEmbed: createEmbedLayer(layerBuilder, inputTokens, T), // fix source?\n         vocabEmbed: createEmbedLayer(layerBuilder, inputTokens, vocabSize),\n         shape: shape,\n         softmaxFinal,\n         resultBuf: null,\n         sortedBuf: null,\n    };\n}\n\nfunction createAddLayer(builder: IWasmLayerBuilder): IAddLayerLink {\n    let { gl, shape: { B, T, C } } = builder;\n\n    return {\n        output: createBufferTex(gl, B * T, C, 1),\n    };\n}\n\nfunction createEmbedLayer(builder: IWasmLayerBuilder, input: IBufferTex, size: number): IEmbedLayerLink {\n    let { gl, shape: { B, T, C } } = builder;\n\n    return {\n        weight: createBufferTex(gl, size, C, 1),\n        output: createBufferTex(gl, B * T, C, 1),\n    };\n}\n\nfunction createLinearLayer(builder: IWasmLayerBuilder, t: number, cIn: number, cOut: number): ILinearLayerLink {\n    let { gl, shape: { B, T } } = builder;\n\n    return {\n        weight: createBufferTex(gl, cOut, cIn, 1),\n        bias: createBufferTex(gl, cOut, 1, 1),\n        output: createBufferTex(gl, B * T, cOut, 1),\n    };\n}\n\nfunction createLayerNormLayer(builder: IWasmLayerBuilder): ILayerNormLayerLink {\n    let { gl, shape: { B, T, C } } = builder;\n\n    return {\n        normWeight: createBufferTex(gl, C, 1, 1),\n        normBias: createBufferTex(gl, C, 1, 1),\n        normAgg: createBufferTex(gl, B * T, 1, 2),\n        output: createBufferTex(gl, B * T, C, 1),\n    };\n}\n\nfunction createSoftmaxLayer(builder: IWasmLayerBuilder): ISoftmaxLayerLink {\n    let { gl, shape: { B, T, vocabSize } } = builder;\n\n    return {\n        agg: createBufferTex(gl, B * T, 1, 2),\n        output: createBufferTex(gl, B * T, vocabSize, 1),\n    };\n}\n\nfunction createBlockLayer(builder: IWasmLayerBuilder): IBlockLayerLink {\n    let mlp = createMlpLayer(builder);\n\n    return {\n        ln_1: createLayerNormLayer(builder),\n        attn: createAttentionLayer(builder),\n        ln_2: createLayerNormLayer(builder),\n        mlp,\n        output: mlp.output,\n    };\n}\n\nfunction createAttentionLayer(builder: IWasmLayerBuilder): IAttentionLayerLink {\n    let { gl, shape: { B, T, C, nHeads, A } } = builder;\n\n    let add = createAddLayer(builder);\n\n    return {\n        qkvWeight:         createBufferTex(gl, 3 * nHeads * A, C, 1),\n        qkvBias:           createBufferTex(gl, 3 * nHeads * A, 1, 1),\n        attnMatrix:        createBufferTex(gl, B * nHeads * T, T, 1),\n        attnMatrixAgg:     createBufferTex(gl, B * nHeads * T, 1, 2),\n        attnMatrixSoftmax: createBufferTex(gl, B * nHeads * T, T, 1),\n        qkvOutput:         createBufferTex(gl, B * T, 3 * nHeads * A, 1),\n        add: createAddLayer(builder),\n        proj: createLinearLayer(builder, T, C, C),\n        scaledVectors: createBufferTex(gl, B * T, nHeads * A, 1),\n        output: add.output,\n    };\n}\n\nfunction createMlpLayer(builder: IWasmLayerBuilder): IMlpLayerLink {\n    let { gl, shape: { B, T, C } } = builder;\n\n    let add = createAddLayer(builder);\n\n    return {\n        fcLayer: createLinearLayer(builder, T, C, C * 4),\n        mlpGelu: createBufferTex(gl, B * T, C * 4, 1),\n        projLayer: createLinearLayer(builder, T, C * 4, C),\n        addLayer: add,\n        output: add.output,\n    };\n}\n\nexport interface IWasmGptModel {\n    native: NativeFunctions;\n    modelPtr: number;\n    lastMemoryBuffer: ArrayBuffer | null; // need to check against this to see if our js copies of the buffers are still valid\n    weightsDirty: boolean;\n    intersDirty: boolean;\n}\n\nexport function constructModel(model: ITensorSet, config: IGptModelConfig, native: NativeFunctions): IWasmGptModel {\n    let nativeModel = native.createModel(config);\n\n    copyFrom('transformer.wte.weight', TensorType.Wte);\n    copyFrom('transformer.wpe.weight', TensorType.Wpe);\n    copyFrom('lm_head.weight', TensorType.LmHeadW);\n    copyWeightBias('transformer.ln_f', TensorType.LnFGamma, TensorType.LnFBeta);\n\n    for (let i = 0; i < config.n_layer; i++) {\n        let layerPrefix = `transformer.h.${i}`;\n\n        copyWeightBias(layerPrefix + '.ln_1', TensorType.Ln1Gamma, TensorType.Ln1Beta, i);\n        copyWeightBias(layerPrefix + '.ln_2', TensorType.Ln2Gamma, TensorType.Ln2Beta, i);\n\n        copyWeightBias(layerPrefix + '.attn.c_attn', TensorType.AttnQkvW, TensorType.AttnQkvB, i);\n        copyWeightBias(layerPrefix + '.attn.c_proj', TensorType.AttnProjW, TensorType.AttnProjB, i);\n\n        copyWeightBias(layerPrefix + '.mlp.c_fc', TensorType.MlpW, TensorType.MlpB, i);\n        copyWeightBias(layerPrefix + '.mlp.c_proj', TensorType.MlpProjW, TensorType.MlpProjB, i);\n    }\n\n    function copyWeightBias(prefix: string, weightType: TensorType, biasType: TensorType, idx: number = 0) {\n        copyFrom(prefix + '.weight', weightType, idx);\n        copyFrom(prefix + '.bias', biasType, idx);\n    }\n\n    function copyFrom(name: string, type: TensorType, idx: number = 0) {\n        let m = model[name];\n        if (!m) {\n            console.log('ERROR: missing tensor name:', name)\n        } else {\n            native.getModelTensor(nativeModel, type, idx).copyFrom(model[name]);\n        }\n    }\n\n    let inputTokens = native.getModelTensor(nativeModel, TensorType.InputTokens);\n\n    inputTokens.buffer.set([2, 1, 0, 1, 1, 2, 0, 0, 0, 0, 0]);\n\n    {\n        let sw = performance.now();\n        native.runModel(nativeModel);\n        console.log('runModel', (performance.now() - sw).toFixed(2) + 'ms');\n    }\n\n    return {\n        native: native,\n        modelPtr: nativeModel,\n        lastMemoryBuffer: null,\n        weightsDirty: true,\n        intersDirty: true,\n    };\n}\n\nexport function stepWasmModel(wasmModel: IWasmGptModel, jsModel: IGptModelLink) {\n    let { native, modelPtr } = wasmModel;\n    let { shape: { B, T, vocabSize } } = jsModel;\n\n    let tIdx = jsModel.inputLen - 1;\n\n    if (!jsModel.sortedBuf || tIdx >= T - 1) {\n        return;\n    }\n\n    let inputTokensTensor = native.getModelTensor(modelPtr, TensorType.InputTokens);\n    for (let b = 0; b < B; b++) {\n        let topSortedIdx = jsModel.sortedBuf![b * T * vocabSize * 2 + tIdx * vocabSize * 2 + 0];\n        // let topSortedValue = jsModel.sortedBuf![b * T * 2 + tIdx * 2 + 1];\n        inputTokensTensor.buffer[b * T + tIdx + 1] = topSortedIdx;\n    }\n\n    jsModel.inputLen += 1;\n\n    native.runModel(modelPtr);\n\n    wasmModel.intersDirty = true;\n\n    syncWasmDataWithJsAndGpu(wasmModel, jsModel);\n}\n\nexport function syncWasmDataWithJsAndGpu(wasmModel: IWasmGptModel, jsModel: IGptModelLink) {\n    let needsSync = wasmModel.weightsDirty || wasmModel.intersDirty;\n\n    if (wasmModel.lastMemoryBuffer !== wasmModel.native.memory.buffer) {\n        wasmModel.lastMemoryBuffer = wasmModel.native.memory.buffer;\n        needsSync = true;\n    }\n\n    if (needsSync) {\n        readLocalBuffersFromWasm(wasmModel, jsModel, wasmModel.intersDirty, wasmModel.weightsDirty);\n        wasmModel.weightsDirty = false;\n        wasmModel.intersDirty = false;\n    }\n}\n\nfunction readLocalBuffersFromWasm(wasmModel: IWasmGptModel, jsModel: IGptModelLink, writeIntersToGpu: boolean = false, writeWeightsToGpu: boolean = false) {\n    readFromWasmToBufferTex(TensorType.Wte, 0, jsModel.vocabEmbed.weight, true);\n    readFromWasmToBufferTex(TensorType.Wpe, 0, jsModel.posEmbed.weight, true);\n\n    readFromWasmToBufferTex(TensorType.InputTokens, 0, jsModel.inputTokens);\n    readFromWasmToBufferTex(TensorType.InputEmbed, 0, jsModel.add.output);\n\n    for (let i = 0; i < jsModel.blocks.length; i++) {\n        let block = jsModel.blocks[i];\n\n        readFromWasmToBufferTex(TensorType.Ln1Gamma, i, block.ln_1.normWeight, true);\n        readFromWasmToBufferTex(TensorType.Ln1Beta, i, block.ln_1.normBias, true);\n        readFromWasmToBufferTex(TensorType.Ln1Agg, i, block.ln_1.normAgg);\n        readFromWasmToBufferTex(TensorType.Ln1Norm, i, block.ln_1.output);\n\n        readFromWasmToBufferTex(TensorType.AttnQkvW, i, block.attn.qkvWeight, true);\n        readFromWasmToBufferTex(TensorType.AttnQkvB, i, block.attn.qkvBias, true);\n\n        readFromWasmToBufferTex(TensorType.AttnQkv, i, block.attn.qkvOutput);\n        readFromWasmToBufferTex(TensorType.Attn, i, block.attn.attnMatrix);\n        // @TODO: attn agg (which we don't have buffers for yet in wasm)\n        readFromWasmToBufferTex(TensorType.AttnSmAgg, i, block.attn.attnMatrixAgg);\n        readFromWasmToBufferTex(TensorType.AttnSm, i, block.attn.attnMatrixSoftmax);\n        readFromWasmToBufferTex(TensorType.AttnVOut, i, block.attn.scaledVectors);\n\n        readFromWasmToBufferTex(TensorType.AttnProjW, i, block.attn.proj.weight, true);\n        readFromWasmToBufferTex(TensorType.AttnProjB, i, block.attn.proj.bias!, true);\n\n        readFromWasmToBufferTex(TensorType.AttnProj, i, block.attn.proj.output);\n        readFromWasmToBufferTex(TensorType.AttnResidual, i, block.attn.output);\n\n        readFromWasmToBufferTex(TensorType.Ln2Gamma, i, block.ln_2.normWeight, true);\n        readFromWasmToBufferTex(TensorType.Ln2Beta, i, block.ln_2.normBias, true);\n        readFromWasmToBufferTex(TensorType.Ln2Agg, i, block.ln_2.normAgg);\n        readFromWasmToBufferTex(TensorType.Ln2Norm, i, block.ln_2.output);\n\n        readFromWasmToBufferTex(TensorType.MlpW, i, block.mlp.fcLayer.weight, true);\n        readFromWasmToBufferTex(TensorType.MlpB, i, block.mlp.fcLayer.bias!, true);\n        readFromWasmToBufferTex(TensorType.MlpProjW, i, block.mlp.projLayer.weight, true);\n        readFromWasmToBufferTex(TensorType.MlpProjB, i, block.mlp.projLayer.bias!, true);\n\n        readFromWasmToBufferTex(TensorType.MlpMlp, i, block.mlp.fcLayer.output);\n        readFromWasmToBufferTex(TensorType.MlpAct, i, block.mlp.mlpGelu);\n        readFromWasmToBufferTex(TensorType.MlpProj, i, block.mlp.projLayer.output);\n        readFromWasmToBufferTex(TensorType.MlpResidual, i, block.mlp.addLayer.output);\n    }\n\n    readFromWasmToBufferTex(TensorType.LnFGamma, 0, jsModel.ln_f.normWeight, true);\n    readFromWasmToBufferTex(TensorType.LnFBeta, 0, jsModel.ln_f.normBias, true);\n    readFromWasmToBufferTex(TensorType.LnFAgg, 0, jsModel.ln_f.normAgg);\n    readFromWasmToBufferTex(TensorType.LnFNorm, 0, jsModel.ln_f.output);\n\n    readFromWasmToBufferTex(TensorType.LmHeadW, 0, jsModel.lm_head.weight, true);\n\n    readFromWasmToBufferTex(TensorType.Logits, 0, jsModel.lm_head.output);\n    readFromWasmToBufferTex(TensorType.LogitsSmAgg, 0, jsModel.softmaxFinal.agg);\n    readFromWasmToBufferTex(TensorType.LogitsSm, 0, jsModel.softmaxFinal.output);\n\n\n    let { T, vocabSize } = jsModel.shape;\n    let resultBuf = jsModel.softmaxFinal.output.localBuffer!;\n    let sortedBuf = new Float32Array(resultBuf.length * 2);\n    for (let t = 0; t < T; t++) {\n        let options = [...resultBuf.slice(t * vocabSize, (t + 1) * vocabSize)].map((v, i) => ({ v, i }));\n        options.sort((a, b) => b.v - a.v);\n        for (let i = 0; i < options.length; i++) {\n            sortedBuf[(t * vocabSize + i) * 2 + 0] = options[i].i;\n            sortedBuf[(t * vocabSize + i) * 2 + 1] = options[i].v;\n        }\n    }\n    jsModel.sortedBuf = sortedBuf;\n\n    function readFromWasmToBufferTex(type: TensorType, idx: number, tex: IBufferTex, isWeight?: boolean) {\n        let t = wasmModel.native.getModelTensor(wasmModel.modelPtr, type, idx);\n        readToBufferTex(`${TensorType[type]}${idx}`, t, tex);\n        let writeToGpu = isWeight ? writeWeightsToGpu : writeIntersToGpu;\n        if (writeToGpu) {\n            writeToBufferTex(jsModel.gl, tex, tex.localBuffer!);\n        }\n    }\n\n    function readToBufferTex(name: string, t: TensorF32, tex: IBufferTex) {\n        let texSize = tex.height * tex.width * tex.channels;\n        if (t.buffer.length !== texSize) {\n            throw new Error(`readToBufferTex: buffer size mismatch for ${name}. ` +\n            `bufferTex: ${texSize} [h: ${tex.height}, w: ${tex.width}, c: ${tex.channels}], ` +\n            `wasmBuffer:  ${t.buffer.length} [${t.shape.join(', ')}]`);\n        }\n        tex.localBuffer = t.buffer;\n    }\n\n}\n\n/*\n\nMini plan: init wasm side, with our model config.\n\ninit gpu side with the above,\nlink k\n\n\n*/\n\n// export function\n","import React, { useState } from 'react';\nimport clsx from 'clsx';\n\nexport interface IOperand {\n    name: string,\n    shapeString: string\n    isShapeStringValid: boolean\n    shape: number[]\n}\n\nexport function createOperand(name: string, shape:number[] ) : IOperand{\n    return {name, shape, shapeString: JSON.stringify(shape), isShapeStringValid: true}\n}\n\nfunction tryParseShape(shapeStr: string): number[] | null {\n    // Remove spaces and parentheses\n    shapeStr = shapeStr.replace(/\\s|\\(|\\)|\\[|\\]/g, \"\");\n\n    // Return null if the string is empty\n    if (!shapeStr) return null;\n\n    // Split the string by commas\n    const parts = shapeStr.split(',');\n\n    // Validate each part and convert to an integer\n    const numbers: number[] = [];\n    for (const part of parts) {\n        if (/^-?\\d+$/.test(part)) {\n            numbers.push(parseInt(part, 10));\n        } else {\n            // If any part is not a valid integer, return null\n            return null;\n        }\n    }\n\n    return numbers;\n}\n\n\ninterface OperandItemProps {\n    operand: IOperand;\n    onUpdate: (operand: IOperand) => void;\n    onRemove: () => void;\n}\n\nconst OperandItem: React.FC<OperandItemProps> = ({ operand, onUpdate, onRemove }) => {\n    const [ text, setText ] = useState(operand.shapeString);\n\n    const handleNameChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n        onUpdate({ ...operand, name: event.target.value });\n    };\n\n    const handleShapeStringChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n        const shapeString = event.target.value;\n        setText(shapeString);\n\n        const parsedShape = tryParseShape(shapeString);\n        const isShapeStringValid = Boolean(parsedShape);\n        const newShape = isShapeStringValid ? parsedShape : operand.shape;\n        onUpdate({...operand, shape: newShape, shapeString, isShapeStringValid});\n    };\n\n    const shapeInputStyle = operand.isShapeStringValid\n        ? {}\n        : { color: 'red', borderWidth: '2px' };\n        const inputStyle = {\n            border: '1px solid #007bff', // A blue border\n            borderRadius: '2px',         // Rounded corners\n            padding: '4px 4px',         // Padding inside the input\n            margin: '1px 4px',             // Margin around the input\n            outline: 'none',             // Remove the default focus outline\n            boxShadow: 'inset 0 1px 1px rgba(0, 0, 0, 0.1)', // Inner shadow for depth\n            width: '100px', // Set width to 50% of the parent element's width\n\n            fontSize: '0.8rem',          // Smaller font size\n            transition: 'border-color 0.15s ease-in-out, box-shadow 0.15s ease-in-out' // Smooth transition for focus\n        };\n    return (\n        <div>\n        <input\n            type= \"text\"\n    value = { operand.name }\n    onChange = { handleNameChange }\n    placeholder = \"Name\"\n    style={inputStyle}\n        />\n        <input\n                type=\"text\"\n        className=''\n    value = { operand.shapeString }\n    onChange = { handleShapeStringChange }\n    placeholder = \"Shape (e.g., 2,3)\"\n    style={{ ...inputStyle, ...shapeInputStyle }}\n    />\n        <button onClick={ onRemove }>❌ </button>\n        </div>\n    );\n}\n\nexport default OperandItem;\n","import React, {useState} from 'react';\nimport OperandItem, {IOperand} from './OperandItem'; // Import the child component\n\ninterface IEinsumEquation {\n    operands: IOperand[],\n    equation: string\n}\n\ninterface EinsumInputManagerProps {\n    operands: IOperand[],\n    equation: string,\n    isEquationValid: boolean | undefined,\n    onEquationChange: (equation: string) => void,\n    onAddOperand: () => void,\n    onRemoveOperand: (index: number) => void,\n    onUpdateOperand: (index: number, updatedOperand: IOperand) => void\n}\n\nfunction EinsumInputManager({\n    operands,\n    equation,\n    isEquationValid,\n    onEquationChange,\n    onAddOperand,\n    onRemoveOperand,\n    onUpdateOperand\n}: EinsumInputManagerProps) {\n    const [ equationText, setEquationText ] = useState(equation);\n\n    const handleEquationChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n        const newEquation = event.target.value;\n        setEquationText(newEquation);\n        onEquationChange(newEquation);\n    };\n    const equationInputStyle = isEquationValid\n        ? {}\n        : { color: 'red', borderWidth: '2px' };\n    \n    return (\n        <div>\n            {operands.map((operand, index) => (\n                <OperandItem\n                    key={index}\n                    operand={operand}\n                    onUpdate={(updatedOperand) => onUpdateOperand(index, updatedOperand)}\n                    onRemove={() => onRemoveOperand(index)}\n                />\n            ))}\n\n            <button onClick={onAddOperand} className=\"Commentary_btn__qpOgN  flex-[2] bg-blue-300 border border-blue-600 hover:bg-blue-400\"  >\n                <div>Add Operand</div>\n            </button>\n\n            <div>\n                <label>\n                    Equation:\n                    <input \n                        type=\"text\" \n                        value={equation}\n                        style={equationInputStyle} \n                        onChange={handleEquationChange} \n                    />\n                </label>\n            </div>\n        </div>\n    );\n}\n\nexport default EinsumInputManager;\n\n","// class MultidimArray {\nexport class MultidimArray {\n    constructor(shape) {\n      this.shape = shape;\n      this.array = this.initArray(shape);\n    }\n\n    static fromArray(array) {\n      function checkShape(arr, shape = []) {\n        if (!Array.isArray(arr)) return shape;\n        const len = arr.length;\n        shape.push(len);\n        for (let i = 0; i < len; i++) {\n          if (Array.isArray(arr[i])) {\n            const innerShape = checkShape(arr[i]);\n            if (shape.length > 1 && innerShape.length + shape.length - 1 !== shape.length) {\n              throw new Error('Non-uniform shape detected');\n            }\n            if (innerShape.length > 0) {\n              shape.push(...innerShape);\n              break;\n            }\n          }\n        }\n        return shape;\n      }\n      const shape = checkShape(array);\n      const multidimArray = new MultidimArray(shape);\n      multidimArray.array = array;\n      return multidimArray;\n    }\n  \n    initArray(shape) {\n      if (shape.length === 0) return [];\n      return Array.from({ length: shape[0] }, () => this.initArray(shape.slice(1)));\n    }\n  \n    getItem(indices) {\n      return indices.reduce((arr, index) => arr[index], this.array);\n    }\n  \n    setItem(indices, value) {\n      indices.reduce((arr, index, idx) => {\n        if (idx === indices.length - 1) {\n          arr[index] = value;\n          return value;\n        }\n        return arr[index];\n      }, this.array);\n    }\n  \n    toString() {\n      return JSON.stringify(this.array);\n    }\n  }\n  \n  function iterate(dims, dim2size) {\n    function _iterate(sizeTuple) {\n      if (sizeTuple.length === 0) return [[]];\n      const smallerIters = _iterate(sizeTuple.slice(1));\n      return [].concat(...Array.from({ length: sizeTuple[0] }, (_, i) => smallerIters.map(coords => [i].concat(coords))));\n    }\n    const sizeTuple = dims.map(d => dim2size[d]);\n    return _iterate(sizeTuple);\n  }\n  \n  function deindex(dims, idx, dimNames) {\n    const globalCoords = Object.fromEntries(dimNames.map((name, i) => [name, idx[i]]));\n    return dims.map(name => globalCoords[name]);\n  }\n\n\n\nexport function buildRelationMap(equation, ...shapes) {\n// function buildRelationMap(equation, ...shapes) {\n  // Check if the equation is a string\n    if (typeof equation !== 'string') {\n      return { valid: false, reason: 'Equation must be a string.' };\n    }\n\n    if (!Array.isArray(shapes)) {\n      return { valid: false, reason: 'Shapes should be an array' };\n    }\n\n    if (!equation.includes('->')) {\n      equation += '->';\n    }\n\n  \n    const [inputs, outputs] = equation.split('->');\n    const inputDims = inputs.split(',');\n    const outputDims = outputs.split(',');\n    const outputDim = outputDims[0];\n   // Check if the number of input dimensions matches the number of provided shapes\n   if (inputDims.length !== shapes.length) {\n    return { valid: false, reason: 'Number of input dimensions does not match the number of provided shapes.' };\n  }\n\n  // Check if each input shape matches its corresponding subscript\n  for (let i = 0; i < shapes.length; i++) {\n    if (inputDims[i].length !== shapes[i].length) {\n      return { valid: false, reason: `Shape at index ${i} does not match its corresponding subscript.` };\n    }\n  }\n\n  // Check for repeated subscripts in the output\n  const uniqueOutputDims = [...new Set(outputDims.join(''))];\n  if (uniqueOutputDims.length !== outputDims.join('').length) {\n    return { valid: false, reason: 'Repeated subscripts in the output are not allowed.' };\n  }\n\n  // Check if all output subscripts appear in the input\n  for (let i = 0; i < uniqueOutputDims.length; i++) {\n\n        const dim = uniqueOutputDims[i]\n        \n        let includes = false;\n\n        for (let inputD of inputDims) {\n          if (inputD.includes(dim)){\n            includes = true;\n          }\n        }\n        if (!includes) {\n          return { valid: false, reason: `Output subscript '${dim}' does not appear in the input.` };\n        }\n\n    }\n    const dim2size = {};\n  \n    inputDims.forEach((dims, i) => {\n      dims.split('').forEach((dim, j) => {\n        dim2size[dim] = shapes[i][j];\n      });\n    });\n\n    const dimsOfEachOp = {};\n\n    for (let i = 0; i < shapes.length; i++) {\n      const shape = shapes[i];\n      for (let j = 0; j < shape.length; j++) {\n        const dim = inputDims[i][j];\n        const info = {opi: i, size: shape[j]};\n        if (dim in dimsOfEachOp){\n          dimsOfEachOp[dim].push(info)\n        } else{\n          dimsOfEachOp[dim] = [info]\n        }\n      }\n    }\n\n\n    for (const dim in dimsOfEachOp) {\n      const opsInfo = dimsOfEachOp[dim];\n      const trueSize = opsInfo[0].size;\n\n      for (let i = 0; i < opsInfo.length; i++) {\n        const opInfo = opsInfo[i];\n        if (opInfo.size != trueSize) {\n          return { \n            valid: false, \n            reason: `Dimension '${dim}' has mismatched sizes across operands. operands[0].shape=${trueSize} while operands[${opInfo.opi}].shape=${opInfo.size}` };\n        }\n      }\n\n    }\n  \n    const freeDims = outputDim.split('');\n    const summationDims = [...new Set([].concat(...inputDims.map(dim => dim.split(''))))].filter(d => !freeDims.includes(d));\n  \n    const outputShape = freeDims.map(d => dim2size[d]);\n  \n    const isScalar = outputShape.length === 0;\n    let relmap = isScalar ? 0 : new MultidimArray(outputShape);\n  \n    const dimNames = freeDims.concat(summationDims);\n  \n    iterate(freeDims, dim2size).forEach(freeIdx => {\n      const sumCoords = [];\n  \n      iterate(summationDims, dim2size).forEach(summationIdx => {\n        const idx = freeIdx.concat(summationIdx);\n        const mulCoords = inputDims.map((dims, oi) => {\n          const localIdx = deindex(dims.split(''), idx, dimNames);\n          return { operand_i: oi, local_idx: localIdx };\n        });\n        sumCoords.push(mulCoords);\n      });\n  \n      if (isScalar) {\n\n        relmap = new MultidimArray([1]);\n        relmap.shape = [];\n        relmap.array = sumCoords;\n      } else {\n        relmap.setItem(freeIdx, sumCoords);\n      }\n    });\n  \n    return { valid: true, relmap, freeDims, dim2size, summationDims, inputDims };\n  }\n  \n  function sumRelmap(relmap, freeDims, dim2size, ...operands) {\n    const isScalar = freeDims.length === 0;\n    let R = isScalar ? 0 : new MultidimArray(relmap.shape);\n  \n    iterate(freeDims, dim2size).forEach(freeIdx => {\n      const sumCoords = isScalar ? relmap.array : relmap.getItem(freeIdx);\n      let s = 0;\n  \n      sumCoords.forEach(sumIdx => {\n        let m = 1;\n        sumIdx.forEach(({ operand_i, local_idx }) => {\n          m *= operands[operand_i].getItem(local_idx);\n        });\n        s += m;\n      });\n  \n      if (isScalar) {\n        R = s;\n      } else {\n        R.setItem(freeIdx, s);\n      }\n    });\n  \n    return R;\n  }\n  \n  function allDtypeEquals(operands) {\n    const dtype = operands[0].dtype;\n    return operands.every(o => o.dtype === dtype);\n  }\n  \n  function myEinsum(equation, ...operands) {\n    operands = operands.map(op => op instanceof MultidimArray ? op : MultidimArray.fromArray(op));\n    const shapes = operands.map(o => o.shape);\n    const output = buildRelationMap(equation, ...shapes);\n    if (!output.valid) {\n      throw new Error(output);\n    }\n\n    const { relmap, freeDims, dim2size } = output;\n    let R = sumRelmap(relmap, freeDims, dim2size, ...operands);\n    return R;\n  }\n  \n  function assert(condition, message) {\n    if (!condition) {\n      throw new Error(message || 'Assertion failed');\n    }\n  }\n\n// Example usage:\n  function assertArraysEqual(a, b) {\n    if (a instanceof MultidimArray) a = a.array;\n    if (b instanceof MultidimArray) b = b.array;\n    function isArrayEqual(a, b) {\n      if (a.length !== b.length) return false;\n      for (let i = 0; i < a.length; i++) {\n        if (Array.isArray(a[i]) && Array.isArray(b[i])) {\n          if (!isArrayEqual(a[i], b[i])) return false;\n        } else if (a[i] !== b[i]) {\n          return false;\n        }\n      }\n      return true;\n    }\n    if (!isArrayEqual(a, b)) {\n      throw new Error('Arrays are not equal');\n    }\n  }\n\n\n\nmyEinsum('ij,kj->ij', [[1, 2, 3]], [[1,2,3], [1,2,3]]);\n\n\nconst result1 = myEinsum('i->', [1, 2, 3]);\nassert(result1 == 6)\n\nconst result2 = myEinsum('i,i->', [1, 2], [3, 4]);\nassert(result2 == 11)\n\nlet result\nresult = myEinsum('i,i->i', [1, 2], [3, 4]);\nassertArraysEqual(result, [3, 8])\n\n\nresult = myEinsum('i,j->i', [1, 2], [3, 4]);\nassertArraysEqual(result, [7, 14])\n\n\n","export function createPythonLoopString(\n  operandNames: string[],\n  inputDims: string[],\n  summationDims: string[],\n  freeDims: string[],\n  dim2size: any): string {\n  // summationDims and freeDims: lists of indices\n  // dim2size: mapping from index to shape\n\n  // *** EXAMPLE 1\n  // INPUT:\n  // operandNames = ['A', 'B', 'C', 'D']\n  // inputDims = ['ia', 'jb', 'ab', 'ij']\n  // summationDims = ['a', 'b']\n  // freeDims = ['i', 'j']\n  // dim2size = {'i': 8, 'j': 16, 'a': 42, 'b': 12}\n\n  // OUTPUT:\n  /*\n      ```python\n      R = zeros(shape=(8,16))\n      for i in range(8):\n          for j in range(16):\n              total = 0\n              for a in range(42):\n                  for b in range(12):\n                      total += A[i,a] * B[j,b] * C[a,b] * D[i,j]\n              R[i,j] = total\n      ```\n  */\n\n  // *** EXAMPLE 2\n  // INPUT:\n  // operandNames = ['A']\n  // inputDims = ['i']\n  // summationDims = ['i']\n  // freeDims = []\n  // dim2size = {'i': 8}\n\n  // OUTPUT:\n  /*\n      ```python\n      R = 0\n      total = 0\n      for i in range(8):\n        total += A[i]\n      R = total\n      ```\n  */\n\n  // *** EXAMPLE 3\n  // INPUT:\n  // operandNames = ['A', 'B']\n  // inputDims = ['i', 'j']\n  // summationDims = ['j']\n  // freeDims = ['i']\n  // dim2size = {'i': 8, 'j': 16}\n\n  // OUTPUT:\n  /*\n      ```python\n      R = zeros(shape=(8,))\n      for i in range(8):\n        total = 0\n        for j in range(16):\n          total += A[i] * B[j]\n        R[i] = total\n      ```\n  */\n\n  // *** EXAMPLE 4\n  // INPUT:\n  // operandNames = ['A']\n  // inputDims = ['i']\n  // summationDims = ['']\n  // freeDims = ['i']\n  // dim2size = {'i': 8,}\n\n  // OUTPUT:\n  /*\n      ```python\n      R = zeros(shape=(8,))\n      for i in range(8):\n        total = 0\n        total += A[i]\n        R[i] = total\n      ```\n  */\n  let pythonCode = '';\n  let indent = '';\n  if (freeDims.length === 0) {\n    pythonCode += 'R = 0\\n';\n  } else {\n    const shape = freeDims.map(dim => dim2size[dim]).join(', ');\n    pythonCode += `R = zeros(shape=(${shape}))\\n`;\n  }\n\n  indent = ''\n  for (const dim of freeDims) {\n    const size = dim2size[dim];\n    pythonCode += `${indent}for ${dim} in range(${size}):\\n`;\n    indent += '    ';\n  }\n\n  pythonCode += indent + 'total = 0\\n'\n\n  // TODO: loop through summation indices:\n  let summationIndent = indent;\n  for (const dim of summationDims) {\n    const size = dim2size[dim];\n    pythonCode += `${summationIndent}for ${dim} in range(${size}):\\n`;\n    summationIndent += '    ';\n  }\n\n  function _indexedArray(name: string, dims: string | string[]) {\n    if (typeof dims === 'string') {\n      dims = dims.split('');\n    }\n    const dimString = dims.join(',');\n    return `${name}[${dimString}]`\n  }\n\n  const operandsIndexed = [];\n\n  for (let i = 0; i < inputDims.length; i++) {\n    operandsIndexed.push(_indexedArray(operandNames[i], inputDims[i]))\n  }\n  let mulString = operandsIndexed.join(' * ');\n  pythonCode += `${summationIndent}total += ${mulString}\\n`\n\n\n  const indexedR = freeDims.length > 0 ? _indexedArray('R', freeDims) : 'R'\n  pythonCode += `${indent}${indexedR} = total`\n\n  return pythonCode.trimEnd();\n}\n\n\n\nfunction runTests() {\n  let testsPassed = 0;\n  const testCases = [\n    {\n      args: {\n        operandNames: ['A', 'B', 'C', 'D'],\n        inputDims: ['ia', 'jb', 'ab', 'ij'],\n        summationDims: ['a', 'b'],\n        freeDims: ['i', 'j'],\n        dim2size: { 'i': 8, 'j': 16, 'a': 42, 'b': 12 }\n      },\n      expected: `\nR = zeros(shape=(8, 16))\nfor i in range(8):\n    for j in range(16):\n        total = 0\n        for a in range(42):\n            for b in range(12):\n                total += A[i,a] * B[j,b] * C[a,b] * D[i,j]\n        R[i,j] = total\n`\n    },\n    {\n      args: {\n        operandNames: ['A'],\n        inputDims: ['i'],\n        summationDims: ['i'],\n        freeDims: [],\n        dim2size: { 'i': 8 }\n      },\n      expected: `\nR = 0\ntotal = 0\nfor i in range(8):\n    total += A[i]\nR = total\n`\n    },\n    {\n      args: {\n        operandNames: ['A', 'B'],\n        inputDims: ['i', 'j'],\n        summationDims: ['j'],\n        freeDims: ['i'],\n        dim2size: { 'i': 8, 'j': 16 }\n      },\n      expected: `\nR = zeros(shape=(8))\nfor i in range(8):\n    total = 0\n    for j in range(16):\n        total += A[i] * B[j]\n    R[i] = total\n`\n    },\n    {\n      args: {\n        operandNames: ['A', 'B'],\n        inputDims: ['Bi', 'Bj'],\n        summationDims: [],\n        freeDims: ['B', 'j', 'i'],\n        dim2size: { 'B': 32, 'i': 8, 'j': 12 }\n      },\n      expected: `\nR = zeros(shape=(32, 12, 8))\nfor B in range(32):\n    for j in range(12):\n        for i in range(8):\n            total = 0\n            total += A[B,i] * B[B,j]\n            R[B,j,i] = total`\n    },\n    {\n      args: {\n        operandNames: ['A'],\n        inputDims: ['i'],\n        summationDims: [],\n        freeDims: ['i'],\n        dim2size: { 'i': 8 }\n      },\n      expected: `\nR = zeros(shape=(8))\nfor i in range(8):\n    total = 0\n    total += A[i]\n    R[i] = total`\n    },\n  ];\n\n  for (let { args, expected } of testCases) {\n    expected = expected.slice(1) // remove first newline\n    const result = createPythonLoopString(args.operandNames, args.inputDims, args.summationDims, args.freeDims, args.dim2size);\n    console.log(args)\n    if (result.trimEnd() === expected.trimEnd()) {\n      console.log('✅ Test passed');\n      console.log('Expected:');\n      console.log(expected)\n      testsPassed++;\n    } else {\n      console.log('❌ Test failed');\n      console.log('Expected:');\n      console.log(expected)\n      console.log('Received:');\n      console.log(result)\n    }\n    console.log('******************************')\n  }\n\n  console.log(`Tests passed: ${testsPassed} / ${testCases.length}`);\n}\n\nrunTests();\n\n\n\n\n\n\n\n\n// console.log('*** EXAMPLE 1 ***');\n// console.log(createPythonLoopString(['A', 'B', 'C', 'D'], ['i', 'j'], ['a', 'b'], ['i', 'j'], { 'i': 8, 'j': 16 }));\n\n// console.log('*** EXAMPLE 2 ***');\n// console.log(createPythonLoopString(['A'], ['i'], ['i'], [], { 'i': 8 }));\n\n// console.log('*** EXAMPLE 3 ***');\n// console.log(createPythonLoopString(\n//   ['A', 'B'],\n//   ['i', 'j'],\n//   ['j'],\n//   ['i'],\n//   { 'i': 8, 'j': 16 }\n// ));\n\n\n// // function createPythonLoopString(\n// //   operandNames: string[],\n// //   inputDims: string[],\n// //   summationDims: string[],\n// //   freeDims: string[],\n// //   dim2size: any)\n// console.log('*** EXAMPLE 4 ***');\n// console.log(createPythonLoopString(['A'], ['i'], [], ['i'], { 'i': 8 }));\n\n\n\n\n\n\n","import React from 'react';\nimport { Prism as SyntaxHighlighter } from 'react-syntax-highlighter';\nimport EinsumInputManager from './EinsumInputManager';\nimport { IOperand, createOperand } from './OperandItem';\nimport { buildRelationMap, MultidimArray } from '@/src/llm/meinsum';\nimport {createPythonLoopString} from './MeinsumStringification';\n\nexport {createOperand};\nexport interface IOutput extends IOperand {\n    relmap: MultidimArray\n}\n\n\nfunction tryCreateRelmap(einsumProgramState: IEinsumProgramState) {\n    const {equation, operands} = einsumProgramState;\n    const shapes = operands.map(op => op.shape)\n\n\n\n    let relmap;\n    let inputDims;\n    let freeDims;\n\n    let displayPythonString = '';\n    try {\n        const relmapOutput = buildRelationMap(equation, ...shapes);\n        if (!relmapOutput.valid) {\n            displayPythonString = `raise ValueError(\"${relmapOutput.reason}\")`;\n        } else {\n            const { dim2size, summationDims } = relmapOutput;\n            inputDims = relmapOutput.inputDims;\n            freeDims = relmapOutput.freeDims;\n            relmap = relmapOutput.relmap;\n            // function createPythonLoopString(\n            //     operandNames: string[],\n            //     inputDims: string[],\n            //     summationDims: string[],\n            //     freeDims: string[],\n            //     dim2size: any)\n            const operandNames = operands.map(op => op.name);\n            displayPythonString = createPythonLoopString(\n                operandNames,\n                inputDims,\n                summationDims,\n                freeDims,\n                dim2size\n            );\n        }\n    } catch (exception) {\n        displayPythonString = ''+exception\n    }\n\n    return {relmap, displayPythonString, inputDims, freeDims}\n}\nexport interface IEinsumProgramState {\n    equation: string,\n    output: IOutput | undefined,\n    operands: IOperand[]\n}\n\nexport interface IEinsumDemoAppProps {\n    einsumProgramState: IEinsumProgramState,\n    onStateChanged: (newState: IEinsumProgramState) => void\n}\n\nexport function calculateOutput(state: IEinsumProgramState) {\n    const {relmap, inputDims, freeDims} = tryCreateRelmap(state);\n    let output;\n    if (relmap) {\n        output = createOperand('Result', relmap.shape);\n        output.relmap = relmap;\n        output.freeDims = freeDims;\n        output.inputDims = inputDims;\n    }\n    return output;\n}\n\nexport const EinsumDemoApp = ({einsumProgramState, onStateChanged}: IEinsumDemoAppProps) => {\n    const {equation, output, operands} = einsumProgramState;\n\n    const {relmap, displayPythonString} = tryCreateRelmap(einsumProgramState);\n    const isEquationValid = Boolean(relmap);\n\n    function createNewOperand(){\n        const defaultShape = [8, 32];\n        let newName = 'Q'; // Fallback name\n        if (operands.length > 0) {\n            const lastOperandName = operands[operands.length - 1].name;\n            if (lastOperandName.length === 1) {\n                const lastCharCode = lastOperandName.charCodeAt(0);\n                newName = String.fromCharCode(lastCharCode + 1);\n            }\n        }\n        return createOperand(newName, defaultShape);\n    }\n\n    function _onWithOutput(state: IEinsumProgramState) {\n        const newState = {...state}\n        newState.output = calculateOutput(newState);\n        onStateChanged(newState);\n    }\n\n    if (!output) {\n       let output = calculateOutput(einsumProgramState)\n       if (output) {\n       } else {\n        output = createOperand('ERROR', [1,1,1,1]);\n       }\n       onStateChanged({...einsumProgramState, output})\n    }\n\n    const handleEquationChange = (equation: string) => {\n        _onWithOutput({...einsumProgramState, equation});\n    };\n\n    const handleAddOperand = () => {\n        const newOperands = [...operands, createNewOperand()]\n        _onWithOutput({...einsumProgramState, operands: newOperands})\n    };\n\n    const handleRemoveOperand = (index: number) => {\n        const newOperands = operands.slice(0, index).concat(operands.slice(index+1));\n        _onWithOutput({...einsumProgramState, operands: newOperands})\n    };\n\n    const handleUpdateOperand = (index: number, updatedOperand: IOperand) => {\n        const newOperands = [...operands.slice(0, index), updatedOperand, ...(operands.slice(index+1))]\n        _onWithOutput({...einsumProgramState, operands: newOperands})\n    };\n\n    return (\n\n        <>\n                <EinsumInputManager\n            operands={operands}\n            equation={equation}\n            isEquationValid={isEquationValid}\n            onEquationChange={handleEquationChange}\n            onAddOperand={handleAddOperand}\n            onRemoveOperand={handleRemoveOperand}\n            onUpdateOperand={handleUpdateOperand}\n        />\n\n<SyntaxHighlighter language=\"python\">\n      {displayPythonString}\n    </SyntaxHighlighter>\n\n        </>\n    );\n};\n\n","import { genModelViewMatrices, ICamera, ICameraPos, updateCamera } from \"./Camera\";\nimport { drawAllArrows } from \"./components/Arrow\";\nimport { drawBlockLabels, drawSectionLabel } from \"./components/SectionLabels\";\nimport { drawModelCard } from \"./components/ModelCard\";\nimport { IGptModelLink, IGpuGptModel, IModelShape } from \"./GptModel\";\nimport { genGptModelLayout, IBlkDef, IGptModelLayout } from \"./GptModelLayout\";\nimport { genEinsumLayout } from \"./EinsumLayout\";\nimport { drawText, IFontAtlasData, IFontOpts, measureText } from \"./render/fontRender\";\nimport { initRender, IRenderState, IRenderView, renderModel, resetRenderBuffers } from \"./render/modelRender\";\nimport { beginQueryAndGetPrevMs, endQuery } from \"./render/queryManager\";\nimport { SavedState } from \"./SavedState\";\nimport { isNotNil } from \"@/src/utils/data\";\nimport { Vec3, Vec4 } from \"@/src/utils/vector\";\nimport { initWalkthrough, runWalkthrough } from \"./walkthrough/Walkthrough\";\nimport { IColorMix } from \"./Annotations\";\nimport { Mat4f } from \"@/src/utils/matrix\";\nimport { runMouseHitTesting } from \"./Interaction\";\nimport { RenderPhase } from \"./render/sharedRender\";\nimport { drawBlockInfo } from \"./components/BlockInfo\";\nimport { NativeFunctions } from \"./NativeBindings\";\nimport { IWasmGptModel, stepWasmModel, syncWasmDataWithJsAndGpu } from \"./GptModelWasm\";\nimport { IMovementInfo, manageMovement } from \"./components/MovementControls\";\nimport { IBlockRender, initBlockRender } from \"./render/blockRender\";\nimport { ILayout } from \"../utils/layout\";\nimport { DimStyle } from \"./walkthrough/WalkthroughTools\";\nimport { Subscriptions } from \"../utils/hooks\";\n\nimport { IProgramState, IEinsumMenuItem } from \"./Program\";\nimport { createOperand, calculateOutput } from \"../app/meinsum/EinsumDemoApp\";\nexport interface IModelExample {\n    name: string;\n    shape: IModelShape;\n    enabled: boolean;\n    layout?: IGptModelLayout;\n    blockRender: IBlockRender;\n    offset: Vec3;\n    modelCardOffset: Vec3;\n    camera?: ICameraPos;\n}\n\nexport interface IMouseState {\n    mousePos: Vec3;\n}\n\nexport interface IDisplayState {\n    tokenColors: IColorMix | null;\n    tokenIdxColors: IColorMix | null;\n    tokenOutputColors: IColorMix | null;\n    tokenIdxModelOpacity?: number[];\n    topOutputOpacity?: number;\n    lines: string[];\n    hoverTarget: IHoverTarget | null;\n    blkIdxHover: number[] | null;\n    dimHover: DimStyle | null;\n}\n\nexport interface IHoverTarget {\n    subCube: IBlkDef;\n    mainCube: IBlkDef;\n    mainIdx: Vec3;\n}\n\n\n\nfunction addOutput(mi: IEinsumMenuItem): IEinsumMenuItem {\n    return { ...mi, state: { ...mi.state, output: calculateOutput(mi.state) } }\n}\n\nconst nHeads = 4;\nconst hiddenSize = 8;\nconst nQueries = 4;\nconst nKeys = 12;\nconst batch_size = 8;\n\nconst menuItems = [\n    {\n        name: \"Multihead Query-Key Attention scores (similarity between each query and each key)\",\n        state: {\n            equation: 'Bnqh,Bnkh->Bnqk',\n            operands: [\n                createOperand('Q', [batch_size, nHeads, nQueries, hiddenSize]),\n                createOperand('K', [batch_size, nHeads, nKeys, hiddenSize]),\n            ]\n        },\n    },\n\n    {\n        name: \"Quadratic form\",\n        state: {\n            equation: 'a,ab,b->',\n            operands: [createOperand('x', [7]), createOperand('Symmetric Q', [7, 7]), createOperand('x', [7])]\n        },\n    },\n\n    {\n        name: \"Dot product\",\n        state: {\n            equation: 'i,i->',\n            operands: [createOperand('A', [16]), createOperand('B', [16])]\n        },\n    },\n\n    {\n        name: \"Outer product transposed\",\n        state: {\n            equation: 'i,j->ji',\n            operands: [createOperand('A', [7]), createOperand('B', [22])]\n        },\n    },\n\n\n    {\n        name: \"Matrix Multiplication\",\n        state: {\n            equation: 'ik,kj->ij',\n            operands: [createOperand('A', [16, 8]), createOperand('B', [8, 12])]\n        }\n    },\n\n    {\n        name: \"Return a diagonal\",\n        state: {\n            equation: 'ii->i',\n            operands: [createOperand('A', [16, 16])]\n        },\n    },\n\n    {\n        name: \"Batched Matrix Multiplication\",\n        state: {\n            equation: 'Bik,Bkj->Bij',\n            operands: [createOperand('A', [32, 16, 8]), createOperand('B', [32, 8, 12])]\n        }\n    },\n    {\n        name: \"Custom\",\n        state: {\n            equation: 'abcdefg,h->he',\n            operands: [createOperand('A', [2, 2, 2, 2, 2, 3, 3]), createOperand('B', [8])]\n        }\n    },\n];\n\nexport function initProgramState(canvasEl: HTMLCanvasElement, fontAtlasData: IFontAtlasData): IProgramState {\n\n    let render = initRender(canvasEl, fontAtlasData);\n    let walkthrough = initWalkthrough();\n\n    let prevState = SavedState.state;\n    let camera: ICamera = {\n        angle: prevState?.camera.angle ?? new Vec3(296, 16, 13.5),\n        center: prevState?.camera.center ?? new Vec3(-8.4, 0, -481.5),\n        transition: {},\n        modelMtx: new Mat4f(),\n        viewMtx: new Mat4f(),\n        lookAtMtx: new Mat4f(),\n        camPos: new Vec3(),\n        camPosModel: new Vec3(),\n    }\n\n    let shape: IModelShape = {\n        B: 1,\n        T: 11,\n        C: 48,\n        nHeads: 3,\n        A: 48 / 3,\n        nBlocks: 3,\n        vocabSize: 3,\n    };\n\n    let gpt2ShapeSmall: IModelShape = {\n        B: 1,\n        T: 1024,\n        C: 768,\n        nHeads: 12,\n        A: 768 / 12,\n        nBlocks: 12,\n        vocabSize: 50257,\n    };\n\n    let gpt2ShapeLarge: IModelShape = {\n        B: 1,\n        T: 1024,\n        C: 1600,\n        nHeads: 25,\n        A: 1600 / 25,\n        nBlocks: 48,\n        vocabSize: 50257,\n    };\n\n    let gpt3Shape: IModelShape = {\n        B: 1,\n        T: 1024,\n        C: 12288,\n        nHeads: 96,\n        A: 12288 / 96,\n        nBlocks: 96,\n        vocabSize: 50257,\n    };\n\n    function makeCamera(center: Vec3, angle: Vec3): ICameraPos {\n        return { center, angle };\n    }\n\n    let delta = new Vec3(10000, 0, 0);\n\n    const einsumProgramState: IEinsumProgramState = {\n        equation: 'i,j->i',\n        operands: [createOperand('A', [8]), createOperand('B', [7])],\n        output: createOperand('Q', [2, 2, 2])\n    };\n    return {\n        einsumStates: menuItems,\n        currentEinsumState: 0,\n        // currentEinsumState: menuItems.length - 1,\n        native: null,\n        wasmGptModel: null,\n        render: render!,\n        inWalkthrough: true,\n        walkthrough,\n        camera,\n        shape: shape,\n        layout: genEinsumLayout(shape),\n        currExampleId: -1,\n        mainExample: {\n            name: 'nano-gpt',\n            enabled: true,\n            shape: shape,\n            offset: new Vec3(),\n            modelCardOffset: new Vec3(),\n            blockRender: null!,\n            camera: makeCamera(new Vec3(42.771, 0.000, -569.287), new Vec3(284.959, 26.501, 12.867)),\n        },\n        examples: [{\n            name: 'GPT-2 (small)',\n            enabled: true,\n            shape: gpt2ShapeSmall,\n            offset: delta.mul(-5),\n            modelCardOffset: delta.mul(-2.0),\n            blockRender: initBlockRender(render?.ctx ?? null),\n            camera: makeCamera(new Vec3(-65141.321, 0.000, -69843.439), new Vec3(224.459, 24.501, 1574.240)),\n        }, {\n            name: 'GPT-2 (XL)',\n            enabled: true,\n            shape: gpt2ShapeLarge,\n            offset: delta.mul(20),\n            modelCardOffset: delta.mul(0.5),\n            blockRender: initBlockRender(render?.ctx ?? null),\n            camera: makeCamera(new Vec3(237902.688, 0.000, -47282.484), new Vec3(311.959, 23.501, 1382.449)),\n        }, {\n            name: 'GPT-3',\n            enabled: false,\n            shape: gpt3Shape,\n            offset: delta.mul(50.0),\n            modelCardOffset: delta.mul(15.0),\n            blockRender: initBlockRender(render?.ctx ?? null),\n            camera: makeCamera(new Vec3(837678.163, 0.000, -485242.286), new Vec3(238.959, 10.501, 12583.939)),\n        }],\n        gptGpuModel: null,\n        jsGptModel: null,\n        stepModel: false,\n        markDirty: () => { },\n        htmlSubs: new Subscriptions(),\n        mouse: {\n            mousePos: new Vec3(),\n        },\n        movement: {\n            action: null,\n            actionHover: null,\n            target: [0, 0],\n            depth: 1,\n            cameraLerp: null,\n        },\n        display: {\n            tokenColors: null,\n            tokenIdxColors: null,\n            tokenOutputColors: null,\n            lines: [],\n            hoverTarget: null,\n            dimHover: null,\n            blkIdxHover: null,\n        },\n        pageLayout: {\n            height: 0,\n            width: 0,\n            isDesktop: true,\n            isPhone: true,\n        }\n    };\n}\n\nexport function initCamera(state: IProgramState) {\n    const cubes = state.layout.cubes;\n\n    let obj = cubes[cubes.length - 1];\n    // console.log(cubes)\n    let modelTarget = new Vec3(obj.x, obj.y, obj.z);\n    let modelMtx = state.camera.modelMtx.mul(Mat4f.fromTranslation(state.mainExample.offset))\n\n    let center = modelMtx.mulVec3Proj(modelTarget);\n\n    let zoom = 0.7;\n    // state.camera.desiredCamera = {\n    //     center, angle: new Vec3(270, 4.5, zoom),\n    // }\n\n    state.camera.center = center;\n    // state.camera.center = new Vec3(-8.25, 0.75, -13.5)\n    state.camera.angle = new Vec3(270, 4.5, 0.8);\n}\n\nexport function runEinsumProgram(view: IRenderView, state: IProgramState) {\n    // console.log('Banana program!')\n    let timer0 = performance.now();\n\n    if (!state.render) {\n        return;\n    }\n\n    resetRenderBuffers(state.render);\n    state.render.sharedRender.activePhase = RenderPhase.Opaque;\n    state.display.lines = [];\n    state.display.hoverTarget = null;\n    state.display.tokenColors = null;\n    state.display.tokenIdxColors = null;\n\n    if (state.wasmGptModel && state.jsGptModel) {\n        syncWasmDataWithJsAndGpu(state.wasmGptModel, state.jsGptModel);\n    }\n\n    if (state.stepModel && state.wasmGptModel && state.jsGptModel) {\n        state.stepModel = false;\n        stepWasmModel(state.wasmGptModel, state.jsGptModel);\n    }\n\n    // generate the base model, incorporating the gpu-side model if available\n    state.layout = genEinsumLayout(state);\n\n\n    // @TODO: handle different models in the same scene.\n    // Maybe need to copy a lot of different things like the entire render state per model?\n    // for (let example of state.examples) {\n    //     if (example.enabled && !example.layout) {\n    //         let layout = genGptModelLayout(example.shape, null, example.offset);\n    //         example.layout = layout;\n    //     }\n    // }\n\n    genModelViewMatrices(state, state.layout!);\n\n\n    // will modify layout; view; render a few things.\n    // if (state.inWalkthrough) {\n    //     runWalkthrough(state, view);\n    // }\n\n\n    updateCamera(state, view);\n    let queryRes = beginQueryAndGetPrevMs(state.render.queryManager, 'render');\n    if (isNotNil(queryRes)) {\n        state.render.lastGpuMs = queryRes;\n    }\n\n    state.render.renderTiming = false; // state.pageLayout.isDesktop;\n\n\n    drawBlockInfo(state);\n    // // these will get modified by the walkthrough (stored where?)\n    // drawAllArrows(state.render, state.layout);\n\n    // drawModelCard(state, state.layout, 'nano-gpt', new Vec3());\n    // drawTokens(state.render, state.layout, state.display);\n\n    // for (let example of state.examples) {\n    //     if (example.enabled && example.layout) {\n    //         drawModelCard(state, example.layout, example.name, example.offset.add(example.modelCardOffset));\n    //     }\n    // }\n\n    // manageMovement(state, view);\n    runMouseHitTesting(state);\n    state.render.sharedRender.activePhase = RenderPhase.Opaque;\n    // drawBlockLabels(state.render, state.layout);\n    let baseColor = new Vec4(0.4, 0.4, 0.4, 1.0);\n\n    // {\n    //     const layout = state.layout;\n    //     // const st\n\n    //     const x = -10;\n    //     const y = 10;\n    //     const dy = 5;\n\n    //     let color = baseColor.mul(layout.embedLabel.visible);\n    //     let tl = new Vec3(x - layout.margin * 2, y, 0);\n    //     let br = new Vec3(x - layout.margin * 2, y + dy, 0);\n    //     drawSectionLabel(state.render, \"Embedding\", tl, br, { color, fontSize: 6, pad: 4 });\n    // }\n\n    let lineNo = 1;\n    let tw = state.render.size.x;\n    state.render.sharedRender.activePhase = RenderPhase.Overlay2D;\n    for (let line of state.display.lines) {\n        let opts: IFontOpts = { color: new Vec4(), size: 14 };\n        let w = measureText(state.render.modelFontBuf, line, opts);\n        drawText(state.render.modelFontBuf, line, tw - w - 4, lineNo * opts.size * 1.3 + 4, opts)\n        lineNo++;\n    }\n\n    // render everything; i.e. here's where we actually do gl draw calls\n    // up until now, we've just been putting data in cpu-side buffers\n    renderModel(state);\n\n    endQuery(state.render.queryManager, 'render');\n    state.render.gl.flush();\n\n    state.render.lastJsMs = performance.now() - timer0;\n}\n","import React, { useState, useCallback } from \"react\";\nimport { IProgramState } from \"./Program\";\nimport { useProgramState } from \"./Sidebar\";\nimport { clamp } from \"@/src/utils/data\";\nimport { useGlobalDrag, useTouchEvents } from \"@/src/utils/pointer\";\nimport { Vec3 } from \"@/src/utils/vector\";\nimport s from './LayerView.module.scss';\n\nexport const CanvasEventSurface: React.FC<{\n    children?: React.ReactNode;\n}> = ({ children }) => {\n    let [eventSurfaceEl, setEventSurfaceEl] = useState<HTMLDivElement | null>(null);\n    let progState = useProgramState();\n\n    let updateRenderState = useCallback((fn: (ps: IProgramState) => void) => {\n        fn(progState);\n        progState.markDirty();\n    }, [progState]);\n\n    function pan(initial: { camAngle: Vec3, camTarget: Vec3 }, dx: number, dy: number) {\n        let camAngle = initial.camAngle;\n        let target = initial.camTarget.clone();\n        target.z = target.z + dy * 0.1 * camAngle.z; // @TODO: clamp to the bounding box of the model\n        let sideMul = Math.sin(camAngle.x * Math.PI / 180) > 0 ? 1 : -1;\n        target.x = target.x + sideMul * dx * 0.1 * camAngle.z;\n\n        updateRenderState(ps => {\n            ps.camera.center = target;\n        });\n    }\n\n    function rotate(initial: { camAngle: Vec3, camTarget: Vec3 }, dx: number, dy: number) {\n        let camAngle = initial.camAngle.clone();\n        let degPerPixel = 0.5;\n        camAngle.x = camAngle.x - dx * degPerPixel;\n        camAngle.y = clamp(camAngle.y + dy * degPerPixel, -87, 87);\n        updateRenderState(ps => {\n            ps.camera.angle = camAngle;\n        });\n    }\n\n    function zoom(initial: { camAngle: Vec3, camTarget: Vec3 }, dy: number) {\n        let camAngle = initial.camAngle.clone();\n        camAngle.z = clamp(camAngle.z / dy, 0.1, 100000);\n        updateRenderState(ps => {\n            ps.camera.angle = camAngle;\n        });\n    }\n\n    let [dragStart, setDragStart] = useGlobalDrag<{ camAngle: Vec3, camTarget: Vec3 }>(function handleMove(ev, ds) {\n        let dx = ev.clientX - ds.clientX;\n        let dy = ev.clientY - ds.clientY;\n\n        if (!ds.shiftKey && !(ds.button === 1 || ds.button === 2)) {\n            pan(ds.data, dx, dy);\n        } else {\n            rotate(ds.data, dx, dy);\n        }\n\n        ev.preventDefault();\n    });\n\n    useTouchEvents(eventSurfaceEl, { camAngle: progState.camera.angle, camTarget: progState.camera.center }, { alwaysSendDragEvent: true },\n        function handle1PointDrag(ev, ds) {\n            let dsTouch0 = ds.touches[0];\n            let evTouch0 = ev.touches[0];\n            let dx = evTouch0.clientX - dsTouch0.clientX;\n            let dy = evTouch0.clientY - dsTouch0.clientY;\n            pan(ds.data, dx, dy);\n            ev.preventDefault();\n    },  function handle2PointDrag(ev, ds) {\n            let dsTouch0 = ds.touches[0];\n            let dsTouch1 = ds.touches[1];\n            let evTouch0 = ev.touches[0];\n            let evTouch1 = ev.touches[1];\n            let dsMidX = (dsTouch0.clientX + dsTouch1.clientX) / 2;\n            let dsMidY = (dsTouch0.clientY + dsTouch1.clientY) / 2;\n            let evMidX = (evTouch0.clientX + evTouch1.clientX) / 2;\n            let evMidY = (evTouch0.clientY + evTouch1.clientY) / 2;\n            let dx = evMidX - dsMidX;\n            let dy = evMidY - dsMidY;\n            let dsDist = Math.sqrt((dsTouch0.clientX - dsTouch1.clientX) ** 2 + (dsTouch0.clientY - dsTouch1.clientY) ** 2);\n            let evDist = Math.sqrt((evTouch0.clientX - evTouch1.clientX) ** 2 + (evTouch0.clientY - evTouch1.clientY) ** 2);\n            rotate(ds.data, dx, dy);\n            // pan(ds.data, dx, dy);\n            zoom(ds.data, evDist / dsDist);\n            ev.preventDefault();\n    });\n\n    function handleMouseDown(ev: React.MouseEvent) {\n        if (progState) {\n            setDragStart(ev, { camAngle: progState.camera.angle, camTarget: progState.camera.center });\n        }\n    }\n\n    function handleMouseMove(ev: React.MouseEvent) {\n        if (progState) {\n            let canvasBcr = progState.render.canvasEl.getBoundingClientRect();\n            let mousePos = new Vec3(ev.clientX - canvasBcr.left, ev.clientY - canvasBcr.top, 0);\n            updateRenderState(ps => {\n                ps.mouse.mousePos = mousePos;\n            });\n        }\n    }\n\n    function handleWheel(ev: React.WheelEvent) {\n        if (progState) {\n            let camAngle = progState.camera.angle;\n            let zoom = clamp(camAngle.z * Math.pow(1.0013, ev.deltaY), 0.01, 100000);\n            updateRenderState(rs => {\n                rs.camera.angle = new Vec3(camAngle.x, camAngle.y, zoom);\n            });\n        }\n        ev.stopPropagation();\n    }\n\n    if (!progState.render) {\n        return null;\n    }\n\n    return <div\n        ref={setEventSurfaceEl}\n        className={s.canvasEventSurface}\n        onMouseDown={handleMouseDown}\n        onMouseMove={handleMouseMove}\n        onWheel={handleWheel}\n        onContextMenu={ev => ev.preventDefault()}\n        style={{ cursor: dragStart ? 'grabbing' : progState.display.hoverTarget ? 'crosshair' : 'grab' }}\n    >\n        {children}\n    </div>;\n}\n","import { faArrowDown, faArrowLeft, faArrowRight, faArrowUp, faCircleDot, faExpand, faMagnifyingGlassMinus, faMagnifyingGlassPlus, IconDefinition } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport clsx from \"clsx\";\nimport React, { useState } from \"react\";\nimport { ICameraPos } from \"../Camera\";\nimport { getBlkDimensions, IBlkDef, IBlkLabel, IGptLayerNormLayout, IGptModelLayout } from \"../GptModelLayout\";\nimport { IProgramState } from \"../Program\";\nimport { IRenderView } from \"../render/modelRender\";\nimport { useProgramState } from \"../Sidebar\";\nimport { clamp, isNotNil } from \"@/src/utils/data\";\nimport { lerp } from \"@/src/utils/math\";\nimport { useTouchEvents } from \"@/src/utils/pointer\";\nimport { BoundingBox3d, Vec3 } from \"@/src/utils/vector\";\nimport s from './MovementControls.module.scss';\n\nexport interface ICameraLerp {\n    camInitial: ICameraPos;\n    camFinal: ICameraPos;\n    duration: number;\n    t: number;\n}\n\nexport interface IMovementInfo {\n    action: MovementAction | null;\n    actionHover: MovementAction | null;\n\n    depth: number;\n    target: number[]; // index maps to depth, which maps to the INavLevel tree\n\n    cameraLerp: ICameraLerp | null;\n}\n\nexport enum MovementAction {\n    Up,\n    Down,\n    Left,\n    Right,\n    Focus,\n    In,\n    Out,\n    Expand,\n}\n\n/*\n\ndepth 0: show everything (the entire model)\n\ndepth 1:\n  - Embedding\n  - Transformer 0\n  - Transformer 1\n  - ...\n  - Transformer n\n  - Output\n\ndepth 2:\n  - input tokens\n  - embedding matrices\n\n  - self-attention (this pair each form residual loops)\n  - mlp\n\n  - ln_f\n  - lm_head + softmax\n\ndepth 3:\n  - top blocks\n  - bottom blocks\n\n  - ln1\n  - heads\n  - projection\n  - residual_output block\n\n  - ln2\n  - mlp_fc\n  - mlp_act\n  - mlp_fc2\n  - residual_output block\n\ndepth 4:\n  - lnX blocks\n  - mlp blocks\n  - head0\n  - head1\n  - head2\n\ndepth 5:\n  - self-attention blocks\n\nlet's see what our depths are\nalso have a sort of state machine for what to go between\nthe active target may be tighter than the depth says, so we can return to where we were\n\n\n*/\n\nexport interface INavLevel {\n    name?: string;\n    label?: IBlkLabel;\n    block?: IBlkDef;\n    children?: INavLevel[];\n\n    zoomLimit?: boolean; // if true, we won't zoom in further\n\n    childDir?: \"row\" | \"col\";\n    left?: INavLevel;\n    right?: INavLevel;\n    up?: INavLevel;\n    down?: INavLevel;\n}\n\nexport function getCurrentNavLevel(state: IProgramState, navLevels: INavLevel): { level: INavLevel, parent: INavLevel | null, depth: number, parents: INavLevel[] } | null {\n    let target = state.movement.target;\n    let targetDepth = state.movement.depth;\n\n    let parents: INavLevel[] = [];\n    let prevLevel = null;\n    let currLevel = navLevels;\n\n    // if we encounter an invalid index, we'll just return to the level above\n    let depth = -1;\n    for (let idx of target) {\n        if (depth >= targetDepth) {\n            break;\n        }\n        if (!currLevel || !currLevel.children) {\n            break;\n        }\n        let nextChild = currLevel.children[idx] ?? null;\n        if (!nextChild) {\n            break;\n        }\n\n        parents.push(currLevel);\n        prevLevel = currLevel;\n        currLevel = currLevel.children[idx] ?? null;\n        depth += 1;\n    }\n\n    return { level: currLevel, parent: prevLevel, depth, parents };\n}\n\nexport function manageMovement(state: IProgramState, view: IRenderView) {\n    let navLevels = constructNavLevels(state.layout);\n\n    let current = getCurrentNavLevel(state, navLevels) ?? { level: navLevels, parent: null, depth: 0, parents: [] };\n    let mvmt = state.movement;\n    if (isNotNil(mvmt.action)) {\n\n    }\n\n    mvmt.depth = current.depth;\n\n    if (isNotNil(mvmt.action)) {\n        let prevLevel = current.level;\n        let action = mvmt.action;\n        mvmt.action = null;\n\n        let setAtDepthAndTruncate = (depth: number, idx: number) => {\n            if (mvmt.target.length <= depth) {\n                mvmt.target.push(idx);\n            }\n\n            mvmt.target[depth] = idx;\n\n            if (mvmt.target.length > depth + 1) {\n                mvmt.target = state.movement.target.slice(0, depth + 1);\n            }\n        }\n\n        let setChild = (child: INavLevel | undefined) => {\n            if (child && current.parent) {\n                let idx = current.parent.children!.indexOf(child);\n                if (idx >= 0) {\n                    setAtDepthAndTruncate(current.depth, idx);\n                }\n            }\n        };\n\n        if (action === MovementAction.Left) {\n            setChild(current.level.left);\n        }\n        if (action === MovementAction.Right) {\n            setChild(current.level.right);\n        }\n        if (action === MovementAction.Up) {\n            setChild(current.level.up);\n        }\n        if (action === MovementAction.Down) {\n            setChild(current.level.down);\n        }\n        if (action === MovementAction.In) {\n            // choose the first child, unless there are already set values\n            // (occurs if we've previously zoomed out)\n            if (current.level.children) {\n                while (mvmt.target.length <= current.depth + 1) {\n                    mvmt.target.push(0);\n                }\n                mvmt.depth += 1;\n            }\n        }\n        if (action === MovementAction.Out) {\n            // don't actually delete the last element; just adjust the depth\n            if (mvmt.depth > -1) {\n                mvmt.depth -= 1;\n            }\n        }\n        if (action === MovementAction.Expand) {\n            mvmt.target = [];\n            mvmt.depth = -1;\n        }\n\n        state.markDirty();\n\n        current = getCurrentNavLevel(state, navLevels) ?? { level: navLevels, parent: null, depth: 0, parents: [] };\n\n        if (current.level !== prevLevel || action === MovementAction.Focus) {\n            // capture camera position and store as lerp start\n\n            let zoomLevel = [...current.parents, current.level].find(a => a.zoomLimit) ?? current.level;\n\n            let boxToViewMtx = state.camera.modelMtx;\n            let bb = new BoundingBox3d();\n            iterNavLevels(zoomLevel, (level) => {\n                if (level.block) {\n                    let pos = getBlkDimensions(level.block);\n                    bb.addInPlace(boxToViewMtx.mulVec3Proj(pos.tl))\n                        .addInPlace(boxToViewMtx.mulVec3Proj(pos.br));\n                }\n            });\n\n            // want to get the entire cube in screen, but in leui of that, guess the zoom based on the size\n            let zoomFactor = 110;\n            let zoom = clamp(bb.size().len() / zoomFactor, 0.1, 20);\n\n            let destAngle = new Vec3(289, 18.5, zoom);\n            let destPos = bb.center();\n\n            let camInitial: ICameraPos = { angle: state.camera.angle, center: state.camera.center };\n            let camFinal: ICameraPos = { angle: destAngle, center: destPos };\n\n            let lerpDist = Math.max(camFinal.angle.dist(camInitial.angle), camFinal.center.dist(camInitial.center));\n            let duration = clamp(lerpDist * 1, 200, 2000); // Math.min(lerpDist * 0.1, 1.0);\n            // compute camera target\n            // lerp to target\n            if (lerpDist > 0.01) {\n                mvmt.cameraLerp = { camInitial, camFinal, duration, t: 0 };\n            }\n        }\n        // if we're at a new depth, we need to reset the focus\n    }\n\n    if (current.level) {\n        iterNavLevels(current.level, (level) => {\n            if (level.block) {\n                level.block.highlight = 0.2;\n            }\n        });\n\n        for (let level of [current.level, ...current.parents])\n        if (level.label) {\n            level.label.visible = 1.0;\n        }\n    }\n\n    if (mvmt.cameraLerp) {\n        let lerp = mvmt.cameraLerp;\n        lerp.t += view.dt;\n        if (lerp.t >= lerp.duration) {\n             mvmt.cameraLerp = null;\n             lerp.t = lerp.duration;\n        }\n        let t = lerp.t / lerp.duration;\n        state.camera.angle = lerp.camInitial.angle.lerp(lerp.camFinal.angle, t);\n        state.camera.center = lerp.camInitial.center.lerp(lerp.camFinal.center, t);\n        state.markDirty();\n    }\n\n    // state.display.lines.push('Level: ' + current.level?.name);\n}\n\nfunction constructNavLevels(model: IGptModelLayout) {\n\n    function makeRow(children: INavLevel[]): void {\n        for (let i = 0; i < children.length - 1; i++) {\n            children[i].right = children[i + 1];\n            children[i + 1].left = children[i];\n        }\n    }\n\n    function makeCol(children: INavLevel[]): void {\n        for (let i = 0; i < children.length - 1; i++) {\n            children[i].down = children[i + 1];\n            children[i + 1].up = children[i];\n        }\n    }\n\n    let inputToks: INavLevel = {\n        name: \"Input Tokens\",\n        block: model.idxObj,\n    }\n    let tokenEmbeds: INavLevel = {\n        name: \"Token Embeddings\",\n        block: model.tokEmbedObj,\n    };\n    let inputEmbeds: INavLevel = {\n        name: \"Input Embeddings\",\n        block: model.residual0,\n    };\n    let posEmbeds: INavLevel = {\n        name: \"Position Embeddings\",\n        block: model.posEmbedObj,\n    };\n\n    makeRow([tokenEmbeds, inputEmbeds, posEmbeds]);\n    makeCol([inputToks, tokenEmbeds]);\n    makeCol([inputToks, posEmbeds]);\n    makeCol([inputToks, inputEmbeds]); // this one wins for inputToks->down\n\n    let embeddings: INavLevel = {\n        name: \"Embedding\",\n        label: model.embedLabel,\n        zoomLimit: true,\n        children: [inputToks, tokenEmbeds, inputEmbeds, posEmbeds],\n    };\n\n    function makeLayerNorm(name: string, ln: IGptLayerNormLayout): INavLevel {\n        let agg: INavLevel = { name: \"LN Agg\", block: ln.lnAgg1 };\n        let norm: INavLevel = { name: \"LN Normalized\", block: ln.lnResid };\n        let bias: INavLevel = { name: \"LN Bias\", block: ln.lnSigma };\n        let weight: INavLevel = { name: \"LN Weight\", block: ln.lnMu };\n        makeCol([agg, norm]);\n        makeRow([weight, bias, norm]);\n        return {\n            name: \"Layer Norm\",\n            children: [agg, norm, bias, weight],\n        };\n    }\n\n    let transformers: INavLevel[] = model.blocks.map((block, i) => {\n        let ln1 = makeLayerNorm(\"LN1\", block.ln1);\n\n        function makeHead(head: IGptModelLayout['blocks'][0]['heads'][0], idx: number) {\n\n            let qRow: INavLevel[] = [\n                { name: \"Q Bias\", block: head.qBiasBlock },\n                { name: \"Q Weight\", block: head.qWeightBlock },\n                { name: \"Q Vectors\", block: head.qBlock },\n            ];\n            let kRow: INavLevel[] = [\n                { name: \"K Bias\", block: head.kBiasBlock },\n                { name: \"K Weight\", block: head.kWeightBlock },\n                { name: \"K Vectors\", block: head.kBlock },\n            ];\n\n            let vRow: INavLevel[] = [\n                { name: \"V Bias\", block: head.vBiasBlock },\n                { name: \"V Weight\", block: head.vWeightBlock },\n                { name: \"V Vectors\", block: head.vBlock },\n            ];\n\n            makeRow(qRow);\n            makeRow(kRow);\n            makeRow(vRow);\n\n            let attnSm: INavLevel = { name: \"Attention Softmax\", block: head.attnMtxSm };\n            let attnAgg1: INavLevel = { name: \"Attention Agg 1\", block: head.attnMtxAgg1 };\n            let attnAgg2: INavLevel = { name: \"Attention Agg 2\", block: head.attnMtxAgg2 };\n            let attn: INavLevel = { name: \"Attention Matrix\", block: head.attnMtx };\n            let attnOut: INavLevel = { name: \"Attention Output\", block: head.vOutBlock };\n\n            makeCol([qRow[0], kRow[0], vRow[0], attnSm]);\n            makeCol([qRow[1], kRow[1], vRow[1], attnSm]);\n            makeCol([qRow[2], kRow[2], vRow[2], attn, attnOut]);\n            makeRow([attnSm, attnAgg1, attnAgg2, attn]);\n            attnAgg1.up = vRow[1];\n            attnAgg2.up = vRow[1];\n\n            return {\n                name: \"Head \" + idx,\n                children: [...qRow, ...kRow, ...vRow, attnSm, attnAgg1, attnAgg2, attn, attnOut],\n            };\n        }\n\n        let heads: INavLevel = {\n            name: \"Heads\",\n            childDir: \"row\",\n            children: block.heads.map(makeHead).reverse(), // We'll fill this in later\n        };\n\n        let projection: INavLevel = {\n            name: \"Projection\",\n            children: [\n                { name: \"Projection Bias\", block: block.projBias },\n                { name: \"Projection Weight\", block: block.projWeight },\n                { name: \"Projection Output\", block: block.attnOut },\n            ],\n        };\n\n        let attnOutput: INavLevel = {\n            name: \"Self-Attention Output\",\n            block: block.attnResidual,\n        };\n\n        // forms a square\n        makeCol([heads, projection]);\n        makeCol([ln1, attnOutput]);\n        makeRow([heads, ln1]);\n        makeRow([projection, attnOutput]);\n\n        let selfAttention: INavLevel = {\n            name: \"Self-Attention\",\n            label: block.selfAttendLabel,\n            children: [ln1, heads, projection, attnOutput]\n        };\n\n        let ln2 = makeLayerNorm(\"LN2\", block.ln2);\n        let fc1: INavLevel = {\n            name: \"MLP FC\", // and activation\n            children: [\n                { name: \"FC Bias\", block: block.mlpFcBias },\n                { name: \"FC Weight\", block: block.mlpFcWeight },\n                { name: \"FC Output\", block: block.mlpFc },\n            ],\n        };\n        let act: INavLevel = {\n            name: \"MLP Activation\",\n            block: block.mlpAct,\n        };\n        let fc2: INavLevel = {\n            name: \"MLP Projection\",\n            children: [\n                { name: \"FC Bias\", block: block.mlpProjBias },\n                { name: \"FC Weight\", block: block.mlpProjWeight },\n                { name: \"FC Output\", block: block.mlpResult },\n            ]\n        };\n        let mlpResidual: INavLevel = {\n            name: \"MLP Residual\",\n            block: block.mlpResidual,\n        };\n\n        let mlp: INavLevel = {\n            name: \"MLP\",\n            label: block.mlpLabel,\n            children: [ln2, fc1, act, fc2, mlpResidual],\n        };\n\n        return {\n            name: `Transformer ${i}`,\n            label: block.transformerLabel,\n            childDir: \"col\",\n            children: [selfAttention, mlp],\n        };\n    });\n\n    let outputs: INavLevel = {\n\n    };\n\n    let topLevel: INavLevel = {\n        name: \"nanoGPT\",\n        childDir: \"col\",\n        children: [embeddings, ...transformers, outputs],\n    };\n\n    function updateChildDirs(level: INavLevel) {\n        if (!level.children) {\n            return;\n        }\n        if (level.childDir === \"col\") {\n            makeCol(level.children);\n        } else if (level.childDir === \"row\") {\n            makeRow(level.children);\n        }\n        level.childDir = undefined;\n        level.children.forEach(updateChildDirs);\n    }\n    updateChildDirs(topLevel);\n\n    return topLevel;\n}\n\nexport const MovementControls: React.FC<{}> = () => {\n    let [controlsEl, setControlsEl] = useState<HTMLDivElement | null>(null);\n    let progState = useProgramState();\n\n    // ensure we can handle these touch events locally\n    useTouchEvents(controlsEl, 0, { alwaysSendDragEvent: true }, (ev) => ev.stopImmediatePropagation());\n\n    function handleDir(ev: React.MouseEvent, action: MovementAction) {\n        progState.movement.action = action;\n        progState.markDirty();\n    }\n\n    function makeButton(action: MovementAction, icon: IconDefinition, isArrow: boolean = false) {\n        return <button className={clsx(s.control, isArrow && s.arrow)} onClick={ev => handleDir(ev, action)}><FontAwesomeIcon icon={icon} /></button>;\n    }\n\n    return <div ref={setControlsEl} className={s.controls}>\n        {makeButton(MovementAction.In, faMagnifyingGlassPlus)}\n        {makeButton(MovementAction.Up, faArrowUp, true)}\n        {makeButton(MovementAction.Out, faMagnifyingGlassMinus)}\n\n        {makeButton(MovementAction.Left, faArrowLeft, true)}\n        {makeButton(MovementAction.Focus, faCircleDot)}\n        {makeButton(MovementAction.Right, faArrowRight, true)}\n\n        <div />\n        {makeButton(MovementAction.Down, faArrowDown, true)}\n        {makeButton(MovementAction.Expand, faExpand)}\n    </div>;\n};\n\nfunction iterNavLevels(level: INavLevel, f: (level: INavLevel) => void) {\n    if (level.children) {\n        level.children.forEach(child => iterNavLevels(child, f));\n    }\n    f(level);\n}\n/*\nThe movement controls are a good idea I think. What else do I need to get this to completion?\n\n- Tidy up the DOM/css, make it fit on mobile well, being careful with screen real estate\n- Improve drag controls around the screen, and also make it discoverable\n- Improve attention for the guide, and finish remaining guides\n- Embed within a personal webpage website\n- Fix camera + bugs wrt guides\n- Think about adding blurred lines behind the data-lines (effectively drop shadows)\n    - But will require supporting nice big-width lines to get the glow effect working\n    - Not 100% sure this is possible, but worth trying\n-\n\n*/\n","import { useEffect as useLayoutEffect, useState } from \"react\";\nimport { Vec3 } from \"./vector\";\nimport { useFunctionRef } from \"./hooks\";\n\nexport interface ILayout {\n    width: number;\n    height: number;\n    isDesktop: boolean;\n    isPhone: boolean;\n}\n\nexport function useScreenLayout() {\n    let [layout, setLayout] = useState<ILayout>({ width: 0, height: 0, isDesktop: true, isPhone: false });\n\n    useLayoutEffect(() => {\n        // check the media queries that we use in css land\n        let mediaQuery = window.matchMedia('screen and (max-width: 800px)');\n\n        function handleResize() {\n            setLayout({\n                width: window.innerWidth,\n                height: window.innerHeight,\n                isDesktop: !mediaQuery.matches,\n                isPhone: mediaQuery.matches,\n            });\n        }\n\n        handleResize();\n\n        window.addEventListener('resize', handleResize);\n        mediaQuery.addEventListener('change', handleResize);\n        return () => {\n            window.removeEventListener('resize', handleResize);\n            mediaQuery.removeEventListener('change', handleResize);\n        };\n    }, []);\n\n    return layout;\n}\n\nexport function useResizeChangeHandler(el: HTMLElement | undefined | null, handler: (size: Vec3, bcr: DOMRect) => void) {\n    let handlerRef = useFunctionRef(handler);\n    useLayoutEffect(() => {\n        if (!el) return;\n        function handleResize() {\n            let bcr = el!.getBoundingClientRect();\n            handlerRef.current(new Vec3(bcr.width, bcr.height, 0), bcr);\n        }\n        let observer = new ResizeObserver(handleResize);\n        observer.observe(el);\n        handleResize();\n        return () => observer.disconnect();\n    }, [el, handlerRef]);\n}\n","import { createContext, useContext, useEffect } from \"react\";\nimport { useFunctionRef } from \"./hooks\";\n\nexport enum KeyboardOrder {\n    MainPage = 0,\n    Element = 1,\n    Modal = 2,\n}\n\nexport interface IKeyHandler {\n    order: KeyboardOrder;\n    handler: (ev: KeyboardEvent) => void;\n    receiveKeyUp: boolean;\n}\n\nexport interface IKeyHandlerOptions {\n    isActive?: boolean;\n    receiveKeyUp?: boolean;\n}\n\nexport class KeyboardManager {\n    private handlers: IKeyHandler[] = [];\n\n    registerHandler(order: KeyboardOrder, handler: (ev: KeyboardEvent) => void, opts?: IKeyHandlerOptions): () => void {\n        let newHandler: IKeyHandler = { order, handler, receiveKeyUp: opts?.receiveKeyUp ?? false };\n        this.handlers.push(newHandler);\n        return () => {\n            this.handlers = this.handlers.filter(h => h !== newHandler);\n        };\n    }\n\n    handleKey = (ev: KeyboardEvent) => {\n        let handlersSorted = this.handlers.sort((a, b) => a.order - b.order);\n\n        let propagationStopped = false;\n        let oldStopPropagation = ev.stopPropagation;\n\n        ev.stopPropagation = () => {\n            propagationStopped = true;\n            oldStopPropagation.call(ev);\n        };\n\n        for (let handler of handlersSorted) {\n            if (ev.type === \"keyup\" && !handler.receiveKeyUp) {\n                continue;\n            }\n            handler.handler(ev);\n            if (propagationStopped) {\n                break;\n            }\n        }\n    }\n}\n\nexport const KeyboardManagerContext = createContext<KeyboardManager>(new KeyboardManager());\n\nexport function useGlobalKeyboard(order: KeyboardOrder, handler: (ev: KeyboardEvent) => void, opts?: IKeyHandlerOptions) {\n    let manager = useContext(KeyboardManagerContext);\n    let handlerRef = useFunctionRef(handler);\n    let receiveKeyUp = opts?.receiveKeyUp ?? false;\n    let isActive = opts?.isActive ?? true;\n\n    useEffect(() => {\n        if (isActive) {\n            let h = (ev: KeyboardEvent) => handlerRef.current(ev);\n            let unregister = manager.registerHandler(order, h, { receiveKeyUp });\n            return () => unregister();\n        }\n    }, [order, handlerRef, manager, receiveKeyUp, isActive]);\n}\n\nexport function useCreateGlobalKeyboardDocumentListener() {\n    let manager = useContext(KeyboardManagerContext);\n\n    useEffect(() => {\n        window.addEventListener(\"keydown\", manager.handleKey);\n        window.addEventListener(\"keyup\", manager.handleKey);\n        return () => {\n            window.removeEventListener(\"keydown\", manager.handleKey);\n            window.removeEventListener(\"keyup\", manager.handleKey);\n        };\n    }, [manager]);\n}\n\nexport enum Modifiers {\n    None = 0,\n    Alt = 1,\n    CtrlOrCmd = 2,\n    Shift = 4,\n}\n\nexport interface IKeyboardEvent {\n    type: string;\n    key: string;\n    altKey: boolean;\n    ctrlKey: boolean;\n    shiftKey: boolean;\n    metaKey: boolean;\n}\n\nexport interface IModifiersEvent {\n    type: string;\n    altKey: boolean;\n    ctrlKey: boolean;\n    shiftKey: boolean;\n    metaKey: boolean;\n}\n\nexport function isArrowKeyWithModifiers(ev: IKeyboardEvent, direction: \"up\" | \"down\" | \"left\" | \"right\", modifiers: Modifiers = Modifiers.None) {\n    return (ev.key.toLowerCase() === direction || ev.key.toLowerCase() === `arrow${direction}`) && hasModifiers(ev, modifiers);\n}\n\nexport function isKeyWithModifiers(ev: IKeyboardEvent, key: string, modifiers: Modifiers = Modifiers.None) {\n    return key.toLowerCase() === ev.key.toLowerCase() && hasModifiers(ev, modifiers);\n}\n\nexport function hasModifiers(ev: IModifiersEvent, modifiers: Modifiers) {\n    let modifiersActual = Modifiers.None;\n    modifiersActual |= ev.altKey ? Modifiers.Alt : 0;\n    modifiersActual |= ev.ctrlKey || ev.metaKey ? Modifiers.CtrlOrCmd : 0;\n    modifiersActual |= ev.shiftKey ? Modifiers.Shift : 0;\n\n    return modifiersActual === modifiers;\n}\n","import clsx from \"clsx\";\nimport React, { useState } from \"react\";\nimport { clamp } from \"./data\";\nimport { useCombinedMouseTouchDrag } from \"./pointer\";\n\nexport const Resizer: React.FC<{\n    id: string;\n    className?: string;\n    vertical?: boolean;\n    defaultFraction?: number;\n    children: React.ReactNode[];\n}> = ({ id, className, children, vertical, defaultFraction }) => {\n\n    let [parentEl, setParentEl] = useState<HTMLElement | null>(null);\n    let [sliderHitEl, setSliderHitEl] = useState<HTMLElement | null>(null);\n    let childrenArr = React.Children.toArray(children).filter(a => a);\n    let firstChild = childrenArr[0] as React.ReactElement;\n    let scndChild = childrenArr[1] as React.ReactElement;\n\n    let [fraction, setFraction] = useState(defaultFraction ?? 0.4);\n\n    let [, setDragStart] = useCombinedMouseTouchDrag(sliderHitEl, () => fraction, (ev, ds, end) => {\n        let parentBcr = parentEl!.getBoundingClientRect();\n        let deltaPx = vertical ? ev.clientY - ds.clientY : ev.clientX - ds.clientX;\n        let fullSizePx = vertical ? parentBcr.height : parentBcr.width;\n        let newFraction = clamp(ds.data + deltaPx / fullSizePx, 0, 1);\n        setFraction(newFraction);\n        ev.preventDefault();\n        ev.stopPropagation();\n    });\n\n    function handleMouseDown(ev: React.MouseEvent) {\n        setDragStart(ev);\n        ev.stopPropagation();\n        ev.preventDefault();\n    }\n\n    let pct = (fraction * 100) + '%';\n    let invPct = ((1 - fraction) * 100) + '%';\n    let hasBothChildren = firstChild && scndChild;\n\n    return <div ref={setParentEl} className={clsx(\"relative flex\", className, vertical ? 'flex-col' : 'flex-row')}>\n        {firstChild && <div className=\"flex flex-initial overflow-hidden\" style={{ flexBasis: hasBothChildren ? pct : '100%' }}>\n            {firstChild}\n        </div>}\n        {scndChild && <div className=\"flex flex-initial overflow-hidden\" style={{ flexBasis: hasBothChildren ? invPct : '100%' }}>\n            {scndChild}\n        </div>}\n        {hasBothChildren && <>\n            <div\n                ref={setSliderHitEl}\n                className={clsx(\"absolute\", vertical ? \"w-full cursor-ns-resize h-4\" : \"h-full cursor-ew-resize w-4\")}\n                style={{ transform: `translate${vertical ? 'Y' : 'X'}(-50%)`, top: vertical ? pct : undefined, left: vertical ? undefined : pct }}\n                onMouseDown={handleMouseDown}>\n            </div>\n            <div\n                className={clsx(\"absolute bg-slate-200 pointer-events-none\", vertical ? \"w-full h-0 border-t\" : \"h-full w-0 border-l\")}\n                style={{ transform: `translate${vertical ? 'Y' : 'X'}(-50%)`, top: vertical ? pct : undefined, left: vertical ? undefined : pct }}>\n            </div>\n        </>}\n    </div>;\n};\n","import React from 'react';\nimport { useProgramState } from '../Sidebar';\nimport {ShapeEditor} from '../ShapeEditor'\nimport {IOperand, IOutput} from '../Program';\n// import { StringEditor } from \"@/src/utils/Di\";\nimport { StringEditor } from './StringEditor';\nimport clsx from 'clsx';\nimport { FontAwesomeIcon } from '@fortawesome/react-fontawesome';\nimport { faExpand, faMagnifyingGlass } from '@fortawesome/free-solid-svg-icons';\nimport { Vec3 } from '@/src/utils/vector';\nimport { Mat4f } from '@/src/utils/matrix';\nimport { EinsumDemoApp, IOutput as IViewOutput } from '@/src/app/meinsum/EinsumDemoApp';\n\nexport const ModelSelectorToolbar: React.FC<{\n}> = () => {\n    let progState = useProgramState();\n\n    function makeButton(egIndex: number) {\n\n        let example = progState.examples[egIndex] ?? progState.mainExample;\n\n        let isEnabled = example.enabled;\n        let isActive = progState.currExampleId === egIndex;\n\n        function handleClick() {\n            if (!isEnabled) {\n                example.enabled = true;\n            }\n            progState.currExampleId = egIndex;\n            progState.camera.desiredCamera = example.camera;\n            progState.markDirty();\n        }\n\n        return <div className={clsx('m-2 p-2 rounded shadow cursor-pointer hover:bg-blue-300', isActive ? 'bg-blue-200' : 'bg-white')} onClick={handleClick}>\n            {example.name}\n        </div>;\n    }\n\n    function onExpandClick() {\n        let example = progState.examples[progState.currExampleId] ?? progState.mainExample;\n        progState.camera.desiredCamera = example.camera;\n        progState.markDirty();\n    }\n\n    function onEinstringUpdate(end: boolean, value: string) {\n        progState.einstring = value;\n        // progState.markDirty();\n    }\n\n    function onOutputChange(output: IOutput) {\n        progState.output = {...output};\n        // progState.inputs.push(output)\n        // console.log('output!!!', output)\n        // progState.markDirty()\n    }\n\n    function onMagnifyClick() {\n        let example = progState.examples[progState.currExampleId] ?? progState.mainExample;\n        let layout = example.layout ?? progState.layout;\n\n        // new Vec3(3.347, 48.000, -2.634), new Vec3(270.000, 4.500, 1.199)\n\n        // new Vec3(-1.771, 0.750, -4.470), new Vec3(270.000, 4.500, 0.739)\n\n        let obj = layout.cubes[layout.cubes.length-1];\n        let modelTarget = new Vec3(obj.x, obj.y, obj.z);\n        let modelMtx = progState.camera.modelMtx.mul(Mat4f.fromTranslation(example.offset))\n\n        let center = modelMtx.mulVec3Proj(modelTarget);\n        let zoom = progState.currExampleId === -1 ? 0.7 : 4;\n        progState.camera.desiredCamera = {\n            center, angle: new Vec3(270, 4.5, zoom),\n        };\n        progState.markDirty();\n\n    }\n\n    return <div className='absolute top-0 left-0 flex flex-col'>\n        <div className='mt-2 ml-2 flex flex-row'>\n            {/* {makeButton(0)}\n            {makeButton(-1)}\n            {makeButton(1)} */}\n            {/* {makeButton(2)} */}\n            {/* {progState.inputs.map((input, i) => <div key={i}>\n                <p>{input.name}</p> <input value={input.shape} onChange={e => onShapeChanged(e, i)} />\n            </div>)} */}\n\n            {/* <StringEditor value={progState.einstring} update={onEinstringUpdate} /> */}\n            {/* <ShapeEditor onShapesUpdated={handleShapesUpdate}/> */}\n            {/* <EinsumDemoApp /> */}\n            {/* <EinsumDemoApp notifyOperandsChange={onOperandsChange} notifyOutputChange={onOutputChange} /> */}\n        </div>\n        <div className='ml-2 flex flex-row'>\n            <div className={clsx('m-2 p-2 bg-white min-w-[2rem] flex justify-center rounded shadow cursor-pointer hover:bg-blue-300')} onClick={onExpandClick}>\n                <FontAwesomeIcon icon={faExpand} />\n            </div>\n            <div className={clsx('m-2 p-2 bg-white min-w-[2rem] flex justify-center rounded shadow cursor-pointer hover:bg-blue-300')} onClick={onMagnifyClick}>\n                <FontAwesomeIcon icon={faMagnifyingGlass} />\n            </div>\n        </div>\n    </div>;\n\n};\n","import React from 'react';\ninterface TableOfContentsProps {\n    texts: string[];\n    selectedIndex?: number;\n    onEntryClick: (index: number) => void;\n}\n\nconst TableOfContents: React.FC<TableOfContentsProps> = ({ texts, selectedIndex, onEntryClick }) => (\n    <ul style={{ listStyleType: 'none', padding: 0 }}>\n        {texts.map((text, index) => (\n            <li\n                key={index}\n                style={{\n                    padding: '10px 15px',\n                    cursor: 'pointer',\n                    backgroundColor: selectedIndex === index ? '#ADD8E6' : 'transparent', // Light blue background for selected item\n                    border: '1px solid #ddd',\n                    borderTopWidth: index === 0 ? '1px' : '0',\n                    fontWeight: selectedIndex === index ? 'bold' : 'normal'\n                }}\n                onClick={() => onEntryClick(index)}\n            >\n                {text}\n            </li>\n        ))}\n    </ul>\n);\n\nexport default TableOfContents;\n","import s from './Sidebar.module.scss';\nimport React, { createContext, useContext, useState } from 'react';\nimport clsx from 'clsx';\nimport { useProgramState } from './Sidebar';\nimport { PhaseTimeline } from './PhaseTimeline';\nimport { Commentary } from './Commentary';\nimport { IProgramState } from './Program';\nimport { Popup, PopupPos } from '@/src/utils/Portal';\nimport { useSubscriptions } from '../utils/hooks';\nimport { EinsumDemoApp, IEinsumProgramState, IOutput as IViewOutput } from '@/src/app/meinsum/EinsumDemoApp';\nimport TableOfContents from './MeinsumMenu';\nimport { IEinsumMenuItem } from './MyProgram';\n\nexport const MeinsumSidebar: React.FC = () => {\n    let progState = useProgramState();\n    const {einsumStates, currentEinsumState} = progState;\n\n    const {state, name} = einsumStates[currentEinsumState];\n    // console.log(state);\n    // if (!progState) return <div></div>\n\n    function handleStateChanged(newState: IEinsumProgramState) {\n        const i = currentEinsumState;\n        const newStates: IEinsumMenuItem[] = [...einsumStates.slice(0,i), {name, state:newState}, ...einsumStates.slice(i+1)]\n        progState.einsumStates = newStates;\n        progState.markDirty()\n    }\n\n    function handleEntryClick(i: number) {\n        progState.currentEinsumState = i;\n        progState.markDirty();\n    }\n\n    const texts = einsumStates.map(s => s.name)\n\n\n    let menu = <>\n        <div className={s.topSplit}>\n            <div className={s.toc}>\n            </div>\n            {/* <div className={s.helpers}>\n                <div className={s.camStats}>\n                    (center, center) =\n                </div>\n                <div className={s.camStats}>\n                    new {camera.center.toString(1)}, new {camera.angle.toString(1)}\n                </div>\n            </div> */}\n        </div>\n    </>;\n\n    return <div className={s.walkthrough}>\n        <div className={s.split}>\n            <div className={s.content}>\n                {/* <div className={s.menuTopBar}>\n                    <div className={s.menu} ref={setMenuButtonEl} onClick={() => setMenuVisible(a => !a)}>Menu &gt;</div>\n                    {menuVisible && <Popup targetEl={menuButtonEl} placement={PopupPos.BottomLeft} className={s.mainMenu} closeBackdrop onClose={() => setMenuVisible(false)}>\n                        {menu}\n                    </Popup>}\n                    <div onClick={() => stepModel()}>Step</div>\n                </div> */}\n                {/* <Commentary /> */}\n                <TableOfContents texts={texts} selectedIndex={currentEinsumState} onEntryClick={handleEntryClick} />\n            <EinsumDemoApp einsumProgramState={state} onStateChanged={handleStateChanged} />\n            </div>\n\n        </div>\n    </div>;\n};\n\n","'use client';\n\nimport React, { useContext, useEffect, useLayoutEffect, useState } from 'react';\nimport { IDataAndModel, IModelState, initModel } from './GptModel';\nimport s from './LayerView.module.scss';\nimport { IRenderState, IRenderView } from './render/modelRender';\nimport { fetchFontAtlasData, IFontAtlasData } from './render/fontRender';\nimport { Random } from '@/src/utils/random';\nimport { ITensorSet, TensorF32 } from '@/src/utils/tensor';\nimport { ProgramStateContext, WalkthroughSidebar } from './Sidebar';\nimport { IProgramState, runProgram } from './Program';\nimport { runEinsumProgram, initCamera, initProgramState } from './MyProgram'\nimport { CanvasEventSurface } from './CanvasEventSurface';\nimport { Vec3 } from '@/src/utils/vector';\nimport { loadNativeBindings } from './NativeBindings';\nimport { constructModel, createGpuModelForWasm } from './GptModelWasm';\nimport { MovementAction } from './components/MovementControls';\nimport { useScreenLayout } from '@/src/utils/layout';\nimport { jumpPhase } from './Commentary';\nimport { WelcomePopup } from './WelcomePopup';\nimport { KeyboardManagerContext, KeyboardOrder, useGlobalKeyboard } from '@/src/utils/keyboard';\nimport { Resizer } from '../utils/Resizer';\nimport { ModelSelectorToolbar } from './components/ModelSelectorToolbar';\nimport {MeinsumSidebar} from './MeinsumSidebar';\n\nasync function fetchTensorData(url: string): Promise<ITensorSet> {\n    let resp = await fetch(url);\n    let data = await resp.json();\n    for (let k in data) {\n        if (data[k].shape) {\n            data[k] = TensorF32.fromJson(data[k]);\n        }\n    }\n    return data;\n}\n\nexport function LayerView() {\n    let [canvasEl, setCanvasEl] = useState<HTMLCanvasElement | null>(null);\n    let [dataAndModel, setDataAndModel] = useState<IDataAndModel | null>(null);\n    let [canvasRender, setCanvasRender] = useState<CanvasRender | null>(null);\n    let [fontAtlasData, setFontAtlasData] = useState<IFontAtlasData | null>(null);\n    let layout = useScreenLayout();\n    let keyboardManager = useContext(KeyboardManagerContext);\n\n    function handleCopyCamera(ev: React.MouseEvent) {\n        let camera = canvasRender?.progState.camera;\n        if (!camera) {\n            return;\n        }\n\n        let vecToString = (vec: Vec3) => `new Vec3(${vec.x.toFixed(3)}, ${vec.y.toFixed(3)}, ${vec.z.toFixed(3)})`;\n\n        let cameraStr = `${vecToString(camera.center)}, ${vecToString(camera.angle)}`;\n\n        let el = document.createElement('textarea');\n        el.value = cameraStr;\n        document.body.appendChild(el);\n        el.select();\n        document.execCommand('copy');\n        document.body.removeChild(el);\n    }\n\n    useGlobalKeyboard(KeyboardOrder.MainPage, (ev: KeyboardEvent) => {\n        if (!canvasRender?.progState) {\n            return;\n        }\n        let key = ev.key.toLowerCase();\n        let wt = canvasRender.progState.walkthrough;\n        let mvmt = canvasRender.progState.movement;\n        if (ev.key === ' ') {\n            if (wt.time >= wt.phaseLength) {\n                jumpPhase(wt, 1);\n                wt.time = 0;\n            } else {\n                wt.running = !wt.running;\n            }\n            canvasRender.markDirty();\n        }\n        if (ev.key === 'Backspace' || ev.key === 'Delete') {\n            wt.running = false;\n            wt.time = 0;\n            canvasRender.markDirty();\n        }\n\n        if (ev.key === 'ArrowLeft' || key === 'a') {\n            mvmt.action = MovementAction.Left;\n            canvasRender.markDirty();\n        }\n        if (ev.key === 'ArrowRight' || key === 'd') {\n            mvmt.action = MovementAction.Right;\n            canvasRender.markDirty();\n        }\n        if (ev.key === 'ArrowUp' || key === 'w') {\n            mvmt.action = MovementAction.Up;\n            canvasRender.markDirty();\n        }\n        if (ev.key === 'ArrowDown' || key === 's') {\n            mvmt.action = MovementAction.Down;\n            canvasRender.markDirty();\n        }\n        if (ev.key === 'PageUp' || key === 'q') {\n            mvmt.action = MovementAction.In;\n            canvasRender.markDirty();\n        }\n        if (ev.key === 'PageDown' || key === 'e') {\n            mvmt.action = MovementAction.Out;\n            canvasRender.markDirty();\n        }\n        if (key === 'r') {\n            mvmt.action = MovementAction.Expand;\n            canvasRender.markDirty();\n        }\n        if (key === 'f') {\n            mvmt.action = MovementAction.Focus;\n            canvasRender.markDirty();\n        }\n\n        if (ev.key === ' ') {\n            ev.preventDefault();\n        }\n    });\n\n    useEffect(() => {\n        document.addEventListener('keydown', keyboardManager.handleKey);\n        return () => {\n            document.removeEventListener('keydown', keyboardManager.handleKey);\n        };\n    }, [keyboardManager]);\n\n    useEffect(() => {\n        let stale = false;\n        async function getData() {\n            let dataP = fetchTensorData('gpt-nano-sort-t0-partials.json');\n            let modelP = fetchTensorData('gpt-nano-sort-model.json');\n            let nativeBindingsP = loadNativeBindings();\n            let [data, model, native] = await Promise.all([dataP, modelP, nativeBindingsP]);\n            if (stale) return;\n            setDataAndModel({ data, model, native });\n        }\n\n        getData();\n\n        return () => { stale = true; };\n    }, []);\n\n    useEffect(() => {\n        let stale = false;\n        async function getData() {\n            let data = await fetchFontAtlasData();\n            if (stale) return;\n            setFontAtlasData(data);\n        }\n\n        getData();\n\n        return () => { stale = true; };\n    }, []);\n\n    useEffect(() => {\n        if (canvasEl && fontAtlasData) {\n            let canvasRenderLocal = new CanvasRender(canvasEl, null!, fontAtlasData);\n            let resizeObserver = new ResizeObserver(() => {\n                canvasRenderLocal.canvasSizeDirty = true;\n                canvasRenderLocal.markDirty();\n            });\n            let handleWheel = (ev: WheelEvent) => ev.preventDefault();\n            setCanvasRender(canvasRenderLocal);\n            resizeObserver.observe(canvasEl);\n            canvasEl.addEventListener('wheel', handleWheel, { passive: false });\n            return () => {\n                canvasEl!.removeEventListener('wheel', handleWheel);\n                canvasRenderLocal.destroy();\n                resizeObserver.disconnect();\n            };\n        } else {\n            setCanvasRender(null);\n        }\n    }, [canvasEl, fontAtlasData]);\n\n    useEffect(() => {\n        canvasRender?.setData({ dataAndModel });\n    }, [canvasRender, dataAndModel]);\n\n    useLayoutEffect(() => {\n        if (canvasRender) {\n            canvasRender.progState.pageLayout = layout;\n            canvasRender.markDirty();\n        }\n    }, [canvasRender, layout]);\n\n    let sidebar = canvasRender && <div className={s.sidebar}>\n         <ProgramStateContext.Provider value={canvasRender.progState}>\n             <MeinsumSidebar />\n         </ProgramStateContext.Provider>\n     </div>;\n\n    let mainView = <div className={s.canvasWrap}>\n            \n\n        <canvas\n            className={s.canvas}\n            ref={setCanvasEl}\n        />\n        {canvasRender && !canvasRender.progState.render && <div className='absolute flex flex-col items-center w-full h-full justify-center'>\n            <div className='text-2xl'>This application requires a WebGL2 capable browser.</div>\n            <div className='text-lg mt-2'>Please try the latest version of Chrome or Firefox.</div>\n        </div>}\n        {/* <div className={s.cursorFollow} style={{ top: pointPos.y, left: pointPos.x }} /> */}\n        {canvasRender && <ProgramStateContext.Provider value={canvasRender.progState}>\n        \n            <CanvasEventSurface>\n                {/* <MovementControls /> */}\n            </CanvasEventSurface>\n            {/* <WelcomePopup /> */}\n            {/* <div className=\"absolute bottom-0 right-0 m-5 bg-white rounded border\">\n                <button className='hover:bg-blue-400' onClick={handleCopyCamera}>\n                    Copy Camera\n                </button>\n            </div> */}\n            <ModelSelectorToolbar />\n        </ProgramStateContext.Provider>}\n    </div>;\n\n    return <div className={s.view}>\n        <Resizer id={\"llm-sidebar\"} className={\"flex-1\"} vertical={!layout.isDesktop} defaultFraction={0.4}>\n            {layout.isDesktop && sidebar}\n            {mainView}\n            {!layout.isDesktop && sidebar}\n        </Resizer>\n    </div>;\n}\n\ninterface ICanvasData {\n    dataAndModel: IDataAndModel | null;\n}\n\nclass CanvasRender {\n    renderState: IRenderState;\n    progState: IProgramState;\n    modelState: IModelState | null = null;\n    random: Random;\n    stopped = false;\n    canvasSizeDirty = true;\n\n    constructor(canvasEl: HTMLCanvasElement, private canvasData: ICanvasData, fontAtlasData: IFontAtlasData) {\n        this.progState = initProgramState(canvasEl, fontAtlasData);\n        this.progState.markDirty = this.markDirty;\n        this.progState.walkthrough.markDirty = this.markDirty;\n        this.renderState = this.progState.render;\n        this.random = new Random(4);\n\n        initCamera(this.progState);\n    }\n\n    destroy() {\n        this.stopped = true;\n    }\n\n    setData(data: ICanvasData) {\n        this.canvasData = data;\n\n        if (data.dataAndModel && !this.progState.gptGpuModel && this.progState.render) {\n            this.progState.gptGpuModel = initModel(this.renderState, data.dataAndModel, 1);\n            this.progState.native = data.dataAndModel.native;\n            this.progState.wasmGptModel = constructModel(data.dataAndModel.model, data.dataAndModel.model.config, data.dataAndModel.native);\n            // this.progState.jsGptModel = createGpuModelForWasm(this.renderState.gl, data.dataAndModel.model.config);\n            // initWebGpu();\n            // setModelInputData(this.renderState, this.progState.gptGpuModel, this.random);\n            // runModel(this.renderState, this.progState.gptGpuModel);\n        }\n        this.markDirty();\n    }\n\n    prevTime: number = performance.now();\n    rafHandle: number = 0;\n    isDirty = false;\n    isWaitingForSync = false;\n\n    markDirty = () => {\n        if (!this.canvasData || this.stopped) {\n            return;\n        }\n\n        this.isDirty = true;\n        if (!this.rafHandle) {\n            this.prevTime = performance.now();\n            this.rafHandle = requestAnimationFrame(this.loop);\n        }\n    }\n\n    loop = (time: number) => {\n        if (!(this.isDirty || this.isWaitingForSync) || this.stopped) {\n            this.rafHandle = 0;\n            return;\n        }\n        let wasDirty = this.isDirty;\n\n        this.isDirty = false;\n        this.isWaitingForSync = false;\n\n        let dt = time - this.prevTime;\n        this.prevTime = time;\n        if (dt < 8) dt = 16; // sometimes we get -ve dt due to perf.now() vs requestAnimationFrame() timing, so put to 16ms in that case\n\n        // we separate waitingForSync from dirty, so we don't have to render if we're only waiting for sync\n        this.checkSyncObjects();\n        let prevSyncCount = this.progState.render?.syncObjects.length ?? 0;\n\n        if (wasDirty || this.isDirty) {\n            this.render(time, dt);\n        }\n\n        let newSyncCount = this.progState.render?.syncObjects.length ?? 0;\n        if (newSyncCount !== prevSyncCount) {\n            this.isWaitingForSync = true;\n        }\n\n        this.rafHandle = requestAnimationFrame(this.loop);\n    }\n\n    checkSyncObjects() {\n        if (!this.progState.render) {\n            return;\n        }\n\n        let gl = this.renderState.gl;\n        let objs = this.progState.render.syncObjects;\n        let anyToRemove = false;\n\n        for (let i = 0; i < objs.length; i++) {\n            let obj = objs[i];\n            if (obj.isReady) {\n                anyToRemove = true;\n                continue;\n            }\n            let syncStatus = gl.clientWaitSync(obj.sync, 0, 0);\n            if (syncStatus === gl.TIMEOUT_EXPIRED) {\n                this.isWaitingForSync = true;\n            } else {\n                obj.isReady = true;\n                obj.elapsedMs = performance.now() - obj.startTime;\n                gl.deleteSync(obj.sync);\n                anyToRemove = true;\n            }\n        }\n        if (anyToRemove) {\n            this.progState.render.syncObjects = objs.filter(o => !o.isReady);\n            this.markDirty();\n        }\n    }\n\n    render(time: number, dt: number) {\n        if (!this.progState.render) {\n            return;\n        }\n\n        let canvasEl = this.renderState.canvasEl;\n\n        if (this.canvasSizeDirty) {\n            let bcr = canvasEl.getBoundingClientRect();\n            let scale = window.devicePixelRatio;\n            canvasEl.width = bcr.width * scale;\n            canvasEl.height = bcr.height * scale;\n            this.progState.render.size = new Vec3(bcr.width, bcr.height);\n            this.canvasSizeDirty = false;\n        }\n\n        let view: IRenderView = { time, dt, markDirty: this.markDirty };\n        runEinsumProgram(view, this.progState);\n        // runProgram(view, this.progState);\n        \n        this.progState.htmlSubs.notify();\n    }\n\n}\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"view\":\"LayerView_view__Tjb_T\",\"sidebar\":\"LayerView_sidebar__rYQhV\",\"canvasWrap\":\"LayerView_canvasWrap__Nz_uj\",\"canvas\":\"LayerView_canvas__UYk4I\",\"canvasEventSurface\":\"LayerView_canvasEventSurface__1KPkQ\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"split\":\"Sidebar_split___9RZf\",\"walkthrough\":\"Sidebar_walkthrough__Gkr1T\",\"timelineLeft\":\"Sidebar_timelineLeft__e8aE_\",\"content\":\"Sidebar_content__M6iat\",\"phaseGroupTitle\":\"Sidebar_phaseGroupTitle__Li2MO\",\"phase\":\"Sidebar_phase__6CZQs\",\"active\":\"Sidebar_active__5aKCi\",\"phaseTitle\":\"Sidebar_phaseTitle__r6mbd\",\"topSplit\":\"Sidebar_topSplit__cAaab\",\"camStats\":\"Sidebar_camStats__l3zK5\",\"title\":\"Sidebar_title__hqVHx\",\"toc\":\"Sidebar_toc__ncbvo\",\"helpers\":\"Sidebar_helpers__EJodm\",\"popup\":\"Sidebar_popup__V9b4I\",\"mainMenu\":\"Sidebar_mainMenu__jd7I1\",\"menu\":\"Sidebar_menu__z2UJk\",\"menuTopBar\":\"Sidebar_menuTopBar__PPm6Z\"};"],"names":["Promise","resolve","then","__webpack_require__","bind","GlFormat","GlInternalFormat","GlType","Dim","RenderPhase","DimStyle","BlkSpecial","BlKDepSpecial","TextAlignVert","TextAlignHoriz","TextBlockType","PhaseGroup","Phase","ElType","TensorType","MovementAction","KeyboardOrder","Modifiers","vector_Dim","WalkthroughTools_DimStyle","Annotations_TextAlignVert","Annotations_TextAlignHoriz","Walkthrough_Phase","EinsumLayout_BlkSpecial","EinsumLayout_BlKDepSpecial","nonNil","value","createRenderPhase","gl","program","dest","src","names","length","concat","fbo","createFramebuffer","bindFramebuffer","FRAMEBUFFER","i","framebufferTexture2D","COLOR_ATTACHMENT0","TEXTURE_2D","texture","drawBuffers","map","_","status","checkFramebufferStatus","FRAMEBUFFER_COMPLETE","console","log","destBuffers","srcBuffers","uniformNames","uniformsSet","createBufferTex","width","height","channels","createTexture","bindTexture","format","iformat","channelsToFormat","texImage2D","FLOAT","texParameteri","TEXTURE_MIN_FILTER","NEAREST","TEXTURE_MAG_FILTER","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","writeToBufferTex","buffer","data","texSubImage2D","RED","R32F","RG","RG32F","RGB","RGB32F","RGBA","RGBA32F","UNSIGNED_BYTE","X","Y","Z","Vec3","add","a","x","y","z","sub","dot","mul","mulAdd","b","lenSq","distSq","dx","dy","dz","len","Math","sqrt","dist","normalize","mid","abs","clone","toVec4","Vec4","round","round_","copy_","cross","writeToBuf","buf","offset","fromArray","setAt","v","addAt","getAt","withSetAt","withAddAt","toString","dp","numMaxDp","rotateAbout","k","thetaRad","c","cos","s","sin","kCrossV","kDotV","lerp","t","constructor","zero","one","getIdx","w","dw","projToVec3","fromVec3","toArray","fromHexColor","alpha","startsWith","slice","hexVal","parseInt","toHexColor","toPair","floor","padStart","parseFloat","toFixed","BoundingBox3d","addInPlace","empty","min","max","combineInPlace","center","size","contains","p","intersects","expandInPlace","border","shrinkInPlaceXY","inset","args","Vec3Buf","add_","aOff","bOff","out","outOff","sub_","normalize_","lenInv","len_","isNil","isNotNil","clamp","num","base64ToArrayBuffer","base64","binaryString","window","atob","bytes","Uint8Array","charCodeAt","lerpSmoothstep","createShaderProgram","manager","name","vert","frag","extra","shaderManager","createProgram","compileAndAttachShader","type","source","typeStr","shader","get","createShader","shaderSource","compileShader","set","attachShader","vertShader","VERTEX_SHADER","vertShaders","fragShader","FRAGMENT_SHADER","fragShaders","locs","prog","vertSource","fragSource","uboBindings","ready","unlinkedPrograms","push","ensureShadersReady","linkProgram","getProgramParameter","LINK_STATUS","Object","keys","loc","getUniformLocation","uboName","uboIndex","getUniformBlockIndex","uniformBlockBinding","getProgramInfoLog","prefix","replace","trimEnd","logShader","infoLog","getShaderInfoLog","programs","bindFloatAttribs","opts","attribs","bindBuffer","ARRAY_BUFFER","locId","locOffset","bufOffset","divisor","byteStride","nCols","enableVertexAttribArray","vertexAttribPointer","vertexAttribDivisor","createFloatBuffer","target","capacityEls","strideBytes","sharedRender","numPhases","UNIFORM_BUFFER","ceil","getParameter","UNIFORM_BUFFER_OFFSET_ALIGNMENT","strideFloats","bufferData","DYNAMIC_DRAW","localBufs","Float32Array","usedEls","glOffsetEls","glCapacityEls","ensureFloatBufferSize","localBuf","countEls","newUsedEls","newLocalBuf","uploadFloatBuffer","bufMap","totalUsed","offsetEls","bufferSubData","subarray","resetFloatBufferMap","createElementBuffer","capacityVerts","ELEMENT_ARRAY_BUFFER","Uint32Array","usedVerts","glOffsetBytes","glCapacityVerts","ensureElementBufferSize","countVerts","newUsedVerts","newCapacityVerts","uploadElementBuffer","offsetIndex","srcBuf","resetElementBufferMap","basicVertexShader","createLayerNorm","layerBuilder","layerPrefix","input","model","shape","B","T","C","tWeight","tBias","normWeight","normBias","normAgg","output","toFloat32Array","normAggProg","normEps","normApply","aggPhase","applyPhase","createLinearLayer","nIn","nOut","residual","bias","linearWeight","linearBias","linearPhase","filter","weight","createEmbeddingLayer","nEmbed","nDims","phase","createAddLayer","inputA","inputB","addPhase","Mat4f","g","r","res","mulVec4","mulVec3Proj","v4","wInv","mulVec3ProjVec","mulVec3Affine","o","mulVec3Affine_","mulVec3AffineArr_","ax","ay","az","mulVec3AffineVec_","fromRowMajor","Array","isArray","flatMap","flatArr","j","fromColMajor","fromTranslation","fromScaleTranslation","fromAxisAngle","axis","angleRad","u","c2","stride","fromQuat","q","n","fromScale","fromLookAt","eye","up","f","fromPersp","fovDeg","aspect","near","far","h","tan","PI","fromOrtho","left","right","bottom","top","zeros","decomposeToTRS","R","S","tr","invertTRS","determinant","A","Float64Array","P","Int32Array","luDecomp","luDeterminant","det","invert","luInvert","maxA","imax","absA","identity","UboBindings","ModelView","Block","BlockAccess","blur","writeModelViewUbo","modelMtx","viewMtx","modelViewUbo","modelViewBuf","Opaque","Arrows","Overlay","Overlay2D","modelViewUboText","fetchFontAtlasData","imgEl","document","createElement","imgP","reject","onload","onerror","fontDefP","fetch","credentials","mode","json","fontAtlasImage","fontDef","all","measureTextWidth","fontBuf","text","scale","faceName","face","atlas","faceInfos","find","prevCodePoint","codePoint","charDef","charMap","kernKey","kernAmount","kernMap","xadvance","common","lineHeight","measureText","drawText","writeTextToBuffer","color","mtx","activePhase","vertBuf","vertBuffer","segmentsUsed","texWidth","segmentId","bufIdx","atlasWInv","scaleW","atlasHInv","scaleH","numGlyphs","localScale","ux","uy","px","xoffset","py","yoffset","tri","ix","iy","segmentCapacity","newCapacity","newBuf","localTexBuffer","Random","randint","random","seed","d","seeder","normal","xmur3","str","imul","randomGen","TensorF32","view","reduce","existingSize","join","isContiguous","transpose","temp","temp2","permute","_len","arguments","axes","_key","setItems","Set","fill","forEach","delete","index","indexToOffset","indexIterator","contiguous","array","destIdx","fromJson","obj","dtype","error","copyFrom","totalEls","strideContiguous","useFunctionRef","fn","ref","useRef","useEffect","current","Subscriptions","subs","subscribe","notify","useGlobalDrag","handleMove","handleClick","handleMoveEnd","dragStart","setDragStart","useState","isDragging","handleMoveRef","handleClickRef","handleMoveEndRef","handleMouseMove","ev","ev2","clientX","ev1","clientY","handleMouseUp","addEventListener","capture","removeEventListener","useCallback","button","buttons","shiftKey","altKey","ctrlKey","metaKey","useTouchEvents","el","options","handle1PointDrag","handle2PointDrag","handle1PointClick","alwaysSendDragEvent","sendDragEnd","initialData","initialTouches","lastTouch","isDrag","latestData","lastPressTime","handle1PointDragRef","handle2PointDragRef","handle1PointClickRef","captureInitialAndSend","passive","sendEvent","initial","touches","touchPixelDist","time","velocity","touch","copyTouchList","prevTouches","prevData","performance","now","lastTouchTouch","cloneTouchEvent","tl","preventDefault","stopPropagation","extractClientPosFromTouch","dimStyleColor","style","C4","Token","TokenIdx","n_vocab","Intermediates","Weights","Colors","Aggregates","None","n_heads","n_layers","Black","cellPosition","layout","blk","dim","rangeOffsets","dimProps","base","cell","xOff","makeLineOpts","thick","undefined","closed","dash","addLine2","render","addLine","Attention","Softmax","Gelu","LayerNorm","InputEmbed","LayerNormMu","LayerNormSigma","SoftmaxAggMax","SoftmaxAggExp","_lineA","_lineB","_lineDir","thickness","floatLocalBuf","floatBuf","idxLocalBuf","indexBuf","idxBuf","dirLen","pt","_lineSegBufs","_dir","_prevDir","_ptsTransformed","drawLineSegs","pts","ptsLen","nPts","cx","cy","cz","cw","nx","ny","nz","linePos","pOff","segLen","bufOff","idxOff","dirA","dirB","idxCount","cameraToMatrixView","camera","angle","camZoom","angleX","angleY","camLookat","camPos","lookAt","camScaleToScreen","state","modelPt","camDist","camPosModel","blockDimension","vecId","dimConsts","offVecId","customDimText","dimStyleText","start","end","midPos","fontSize","tw","modelFontBuf","textPad","th","botPad","edgeH2","textPos","textYOff","tooSmall","textDx","textDy","lX","lY","lZ","vStart","vEnd","vMid1","vMid2","lineRender","dimConstX","xName","dxName","cxName","offXName","sizeXName","dimConstY","dimConstZ","rangeOffsetsX","offX","sizeX","rangeOffsetsY","offY","sizeY","rangeOffsetsZ","offZ","sizeZ","splitGridForHighlight","xSplit","splitAmt","splitGrid","midBlock","blocks","colX","addSubBlockLocal","iStart","iEnd","xOffset","addSubBlock","subBlock","rangeOffset","fract","addMidBlockBefore","addMidBlockAfter","access","localMtx","Top","Middle","Bottom","Left","Center","Right","SavedState","defaultN","_vertP","_vertN","addVert","vbo","ibo","fBuf","iBuf","fIdx","iIdx","_quadTr","_quadBl","addQuad","br","isEnd","mkTextBlock","Text","Line","data_isNotNil","cellX","cellY","Cells","id","align","rectOpts","draw","sqrtSpacing","inner","cellSizing","pad","cellSize","sizeBlock","maxH","fontOpts","Sqrt","spacing","Divide","subA","subB","padX","padInnerY","Custom","layoutBlock","midY","midX","drawBlock","drawRoundedRect","drawLineRect","xPos","subY","sqrtX","sqrtY","sqrtSize","mathOpts","lineOpts","lineX","lineY","drawCells","nCells","triRender","_lineRectArr","projectToScreen","modelPos","ndc","weightSrcColor","workingSrcColor","opColor","backWhiteColor","nameColor","getBlockValueAtIdx","blkIdx","localBuffer","bufferTex","bufferPos","mat","channelIdx","channel","radius","innerQuadTl","innerQuadBr","cIdx","pivot","startTheta","nRadiusVerts","drawMaths","bottomMiddle","textBlk","getPad","padY","dir","createMapping","range0","range1","domain0","domain1","m","iterVisibleSubCubes","cb","getDepSrcIdx","dep","srcIdxMtx","hasXDot","hasYDot","srcIdx4","srcIdx","dotDim","otherDim","isDot","getDepDotLen","deps","dotLen","triLimit","lowerTri","Intro","Detailed_Input","Intro_Intro","Input_First","Input_Detail_Tables","Input_Detail_TokEmbed","LayerNorm1","Intro_Prelim","Input_Detail_Embedding","Input_Detail_LayerNorm","Input_Detail_SelfAttention","Input_Detail_Softmax","Input_Detail_Projection","Input_Detail_Mlp","Input_Detail_Transformer","Input_Detail_Output","Cell","PosEmbed","Gap","ProgramStateContext","createContext","useProgramState","context","useContext","useSubscriptions","subscription","refresh","useReducer","htmlSubs","genEinsumLayout","freeDims","cubes","einsumState","einsumStates","currentEinsumState","operands","dimNames","inputDims","start_block_at","thisOpDimNames","meinsumResult","dims","relmap","String","fromCharCode","block","generateTensor","n_dims","M","N","coords","blockDescription","frontUpLeft","frontDownLeft","frontUpRight","rearUpLeft","dimN","dimsNminusOne","blockStart","pad_lvl","pad_lvl0","pow","ourBlockDescr","cube","mk","makeBlkDeps","xDef","xL","xR","xM","yDef","zF","zB","zM","JSON","stringify","ensure4","dimX","dimY","depStr","parseDepIdxStr","destI","depIdxVars","indexOf","param","special","opacity","hidden","highlight","small","idx","margin","labels","initBlockRender","ctx","blockUboText","blockAccessUboText","blockUbo","createBuffer","blockAccessUbo","cubeGeom","genCubeGeom","faceVerts","faces","transform","arr","faceMtx","vao","createVertexArray","bindVertexArray","STATIC_DRAW","TRIANGLES","numVerts","instancedVao","instancedVbo","instancedStrideBytes","instancedFloatBuf","dummyTexture","createVertShader","instanced","createFragShader","instancedShader","simpleShader","instancedDataStale","instancedNumBlocks","loadNativeBindings","resp","lineStr","memory","WebAssembly","Memory","maximum","importObject","env","odin_env","write","fd","ptr","mem","lines","strPart","TextDecoder","decode","split","time_now","BigInt","Date","odin_dom","init_event_raw","wasmModule","instantiateStreaming","exports","instance","init_allocator","__heap_base","NativeFunctions","createModel","config","wasm_create_model","block_size","n_embd","n_layer","n_head","vocab_size","runModel","wasm_run_model","getModelTensor","tensor","wasm_get_model_tensor","checkViews","bufNElem","int32View","ndimsSize","dataPtr","ptrView","shapeArrPtr","strideArrPtr","viewBuf","module","syncWasmDataWithJsAndGpu","wasmModel","jsModel","needsSync","weightsDirty","intersDirty","lastMemoryBuffer","native","readLocalBuffersFromWasm","writeIntersToGpu","writeWeightsToGpu","readFromWasmToBufferTex","Wte","vocabEmbed","Wpe","posEmbed","InputTokens","inputTokens","Ln1Gamma","ln_1","Ln1Beta","Ln1Agg","Ln1Norm","AttnQkvW","attn","qkvWeight","AttnQkvB","qkvBias","AttnQkv","qkvOutput","Attn","attnMatrix","AttnSmAgg","attnMatrixAgg","AttnSm","attnMatrixSoftmax","AttnVOut","scaledVectors","AttnProjW","proj","AttnProjB","AttnProj","AttnResidual","Ln2Gamma","ln_2","Ln2Beta","Ln2Agg","Ln2Norm","MlpW","mlp","fcLayer","MlpB","MlpProjW","projLayer","MlpProjB","MlpMlp","MlpAct","mlpGelu","MlpProj","MlpResidual","addLayer","LnFGamma","ln_f","LnFBeta","LnFAgg","LnFNorm","LmHeadW","lm_head","Logits","LogitsSmAgg","softmaxFinal","agg","LogitsSm","vocabSize","resultBuf","sortedBuf","sort","tex","isWeight","modelPtr","readToBufferTex","texSize","InputTokenEmbed","createOperand","shapeString","isShapeStringValid","meinsum_OperandItem","operand","onUpdate","onRemove","setText","shapeInputStyle","borderWidth","inputStyle","borderRadius","padding","outline","boxShadow","transition","jsx_runtime","jsxs","div","jsx","onChange","event","placeholder","className","parsedShape","tryParseShape","shapeStr","parts","numbers","part","test","Boolean","newShape","onClick","meinsum_EinsumInputManager","equation","isEquationValid","onEquationChange","onAddOperand","onRemoveOperand","onUpdateOperand","equationText","setEquationText","OperandItem","updatedOperand","label","newEquation","MultidimArray","checkShape","innerShape","multidimArray","initArray","from","getItem","indices","setItem","iterate","dim2size","sizeTuple","_iterate","smallerIters","buildRelationMap","shapes","valid","reason","includes","inputs","outputs","outputDims","outputDim","uniqueOutputDims","inputD","dimsOfEachOp","info","opi","opsInfo","trueSize","opInfo","summationDims","outputShape","isScalar","freeIdx","sumCoords","summationIdx","mulCoords","oi","localIdx","deindex","globalCoords","fromEntries","operand_i","local_idx","myEinsum","op","sumRelmap","sumIdx","assert","condition","message","assertArraysEqual","isArrayEqual","result1","result2","createPythonLoopString","operandNames","pythonCode","indent","summationIndent","_indexedArray","dimString","operandsIndexed","mulString","indexedR","tryCreateRelmap","einsumProgramState","displayPythonString","relmapOutput","exception","calculateOutput","runTests","testsPassed","testCases","expected","result","EinsumDemoApp","onStateChanged","_onWithOutput","newState","Fragment","EinsumInputManager","newOperands","createNewOperand","newName","lastOperandName","lastCharCode","SyntaxHighlighter","language","menuItems","CanvasEventSurface","children","eventSurfaceEl","setEventSurfaceEl","progState","updateRenderState","markDirty","pan","camAngle","camTarget","sideMul","ps","rotate","ds","dsTouch0","evTouch0","dsTouch1","evTouch1","dsMidX","dsMidY","evMidX","evMidY","dsDist","evDist","onMouseDown","onMouseMove","canvasBcr","canvasEl","getBoundingClientRect","mousePos","mouse","onWheel","zoom","deltaY","rs","onContextMenu","cursor","display","hoverTarget","Up","Down","Focus","In","Out","Expand","MainPage","Element","Modal","KeyboardManagerContext","registerHandler","order","handler","newHandler","receiveKeyUp","handlers","handleKey","handlersSorted","propagationStopped","oldStopPropagation","call","Alt","CtrlOrCmd","Shift","Resizer","vertical","defaultFraction","parentEl","setParentEl","sliderHitEl","setSliderHitEl","childrenArr","React","firstChild","scndChild","fraction","setFraction","useCombinedMouseTouchDrag","captureDragStart","handleDrag","touchDragStart","setTouchDragStart","captureDragStartRef","mouseEvent","dragStartData","setDragStartLocal","parentBcr","deltaPx","fullSizePx","pct","invPct","hasBothChildren","clsx","flexBasis","ModelSelectorToolbar","example","examples","currExampleId","mainExample","desiredCamera","FontAwesomeIcon","icon","faExpand","modelTarget","faMagnifyingGlass","MeinsumMenu","texts","selectedIndex","onEntryClick","ul","listStyleType","li","backgroundColor","borderTopWidth","fontWeight","MeinsumSidebar","TableOfContents","newStates","fetchTensorData","url","LayerView","handlerRef","isActive","setCanvasEl","dataAndModel","setDataAndModel","canvasRender","setCanvasRender","fontAtlasData","setFontAtlasData","useScreenLayout","setLayout","isDesktop","isPhone","useLayoutEffect","mediaQuery","matchMedia","handleResize","innerWidth","innerHeight","matches","keyboardManager","key","toLowerCase","wt","walkthrough","mvmt","movement","phaseLength","jumpPhase","phaseDelta","group","phaseList","phases","groupIdx","newPhaseGroupIdx","phaseGroupIdx","findIndex","newGroup","running","action","unregister","stale","getData","dataP","modelP","nativeBindingsP","canvasRenderLocal","CanvasRender","resizeObserver","ResizeObserver","canvasSizeDirty","handleWheel","observe","destroy","disconnect","setData","pageLayout","sidebar","Provider","mainView","canvas","stopped","canvasData","gptGpuModel","renderState","createGptModel","nHeads","nBlocks","inputBuf","posArr","pos","createBlockLayer","createAttnLayer","tAttnWeight","tAttnBias","qkvProg","selfAttendProg","attnMatrixAggProg","attnMatrixSoftmaxProg","scaledVectorsProg","qkvPhase","selfAttendPhase","attnMatrixAggPhase","attnMatrixSoftmaxPhase","scaledVectorsPhase","createMLP","geluProg","geluPhase","createSoftmaxLayer","softmaxAggProg","softmaxProg","softmaxPhase","bufs","progs","copyOutputToInput","createCopyOutputToInputLayer","prevOutput","currInput","copyPhase","inputLen","readbackSync","wasmGptModel","constructModel","nativeModel","copyWeightBias","weightType","biasType","sw","checkSyncObjects","objs","syncObjects","anyToRemove","isReady","syncStatus","clientWaitSync","sync","TIMEOUT_EXPIRED","isWaitingForSync","elapsedMs","startTime","deleteSync","dt","bcr","devicePixelRatio","runEinsumProgram","timer0","tokenColors","tokenIdxColors","jsGptModel","stepModel","stepWasmModel","tIdx","inputTokensTensor","topSortedIdx","genModelViewMatrices","modelOffset","bb","persp","lookAtMtx","updateCamera","desiredCameraTransition","initialPos","targetPos","queryRes","beginQueryAndGetPrevMs","ext","disjointTimerQuery","existing","queries","query","createQuery","hasRun","hasStarted","resultAvailable","getQueryParameter","QUERY_RESULT_AVAILABLE","resultMs","timeElapsed","QUERY_RESULT","beginQuery","TIME_ELAPSED_EXT","queryManager","lastGpuMs","renderTiming","drawBlockInfo","blkTopMid","textColor","bgColor","textOpts","textW","runMouseHitTesting","canvasSize","ndcX","ndcY","viewMtxInv","modelMtxInv","clipToWorld","v2","v3","clipSpaceA","clipSpaceB","worldA","worldB","visibleCubes","addCube","mainCube","minT","minCube","main","rayAABBIntersect","rayOrigin","rayDir","tx1","tx2","tmin","tmax","ty1","ty2","tz1","tz2","pt2","pt3","ptIdx","subCube","mainIdx","visible","highlightCellUnderMouse","mainBlk","ptLocalIdx","midZ","drawDependences","high","drawDep","tokEmbedObj","tokenIdx","idxObj","findSubBlocks","idxLow","idxHi","offsets","subBlocks","startIdx","endIdx","splitGridAll","drawDataFlow","pinIdx","prevPhase","cellPos","resMtx","dataFlowArgs","screenPos","drawMeinsum","testText","drawZeroSymbol","drawOLInputEmbed","drawOLIndexLookup","tokenPct","heightPct","residual0","colTl","colBr","cellTl","cellBr","lineColor","lineEndX","colW","lineEndY","lineStartX","drawOLPosEmbedLookup","posPct","posEmbedObj","drawLayerNorm","drawLayerNormMuAgg","drawLayerNormSigmaAgg","drawSoftmaxAggMax","drawSoftmaxAggExp","drawSoftmax","drawAttention","dotA","dotB","cellSizeAndColor","isRow","drawGeluActivation","geluX","tanh","mappingX","mappingY","halfH","axisLineOpts","curveLineOpts","srcVal","destVal","drawCircle","nPoints","theta","drawOLMatrixMul","hasAdd","drawResidualAdd","cellIdxBb","drawCellIndexAndValue","mapDimToSub","posValue","dimStyleTextShort","xDim","yDim","textBlock","fullBB","drawDepArrows","drawDepArrow","drawArrow","srcT","reverse","tVals","actualTarget","tmp","drawArc","bisect","endAngle","atan2","startAngle","tangent","blkIdxHover","dimHover","blks","dimHighlightBlocks","lineNo","line","renderModel","blockRender","lightPos","lightColor","lightPosArr","lightColorArr","viewport","clearColor","clear","COLOR_BUFFER_BIT","DEPTH_BUFFER_BIT","enable","BLEND","blendFunc","ONE","ONE_MINUS_SRC_ALPHA","DEPTH_TEST","CULL_FACE","cullFace","FRONT","frontFace","CW","lastJsMs","blurW","blurH","blurBlocks","setupBlurTarget","blurFactor","currViewSize","initialTex","blurFbos","initialFbo","blurRender","renderBlocksSimple","geom","useProgram","uniform3f","u_size","u_offset","baseColor","uniform4f","u_baseColor","drawArrays","quadVao","disable","STENCIL_TEST","activeTexture","TEXTURE0","horizShader","uniform1i","u_texture","TRIANGLE_FAN","TEXTURE1","overlayShader","uploadAllText","transformTex","glSegmentCapacity","renderAllBlocks","u_camPos","u_accessSampler","transparentCubes","allCubes","firstTransparent","blockBuf","baseOff","prevHasAccess","depthMask","bindBufferRange","hasAccess","enabled","modelMtxLocal","renderAllBlocksInstanced","vboBuf","drawArraysInstanced","renderAllThreads","threadRender","threadVao","POLYGON_OFFSET_FILL","polygonOffset","threadInfos","uniform2f","u_nCells","uniformMatrix3x2fv","u_threadDir","threadDir","renderAllTris","renderPhase","localIdxBuf","triShader","drawElements","TRIANGLE_STRIP","UNSIGNED_INT","renderAllText","uniform1f","pxRange","atlasTex","renderAllLines","lineShader","u_viewSizeInv","endQuery","flush","modelState","prevTime","rafHandle","isDirty","requestAnimationFrame","loop","_this_progState_render","_this_progState_render1","_this_progState_render_syncObjects_length","_this_progState_render_syncObjects_length1","wasDirty","prevSyncCount","initProgramState","prevState","initRender","vertVbo","quadVbo","instanceVbo","instanceStride","lineVao","lineVbo","lineFloatBuf","lineIbo","triVbo","triFloatBuf","triIbo","getContext","antialias","colorBufferFloat","getExtension","Map","bindBufferBase","fontAtlas","setupFontAtlas","LINEAR","floatsPerSegment","u_tex","u_transformTex","charArr","Int16Array","chars","numChars","charCodeMap","char","page","chnl","kernArr","kernings","numKerns","kern","first","second","amount","firstChar","secondChar","numSegments","floatsPerVert","instanceBuf","numInstances","initBlurRender","createBlurFbo","blurWeights","blurWeightsSum","radiusPx","exp","wIdx","blurUbo","createBlurShader","blurPixelStride","phaseTime","viewDt","speed","cameraInitial","commentary","times","phaseData","phaseTransitiveData","groupId","title","makeCamera","delta","inWalkthrough","modelCardOffset","actionHover","depth","cameraLerp","tokenOutputColors","initCamera"],"sourceRoot":""}